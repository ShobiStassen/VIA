<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 5.1.1 and Furo 2023.03.27 -->
        <title>VIA.plotting_via - pyvia documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">pyvia  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">pyvia  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">General</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pyVia-home.html">StaVia - Multi-Omic Single-Cell Cartography for Spatial and Temporal Atlases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Release%20History.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorial%20Video.html">VIA Tutorial Videos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Parameters%20and%20Attributes.html">Parameters and Attributes</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api/index.html">API</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/pyVIA%20Core.html">pyVIA core</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Plotting.html">Plotting</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.animate_atlas.html">pyVIA.plotting_via.animate_atlas</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.animate_streamplot.html">pyVIA.plotting_via.animate_streamplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.get_gene_expression.html">pyVIA.plotting_via.get_gene_expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_atlas_view.html">pyVIA.plotting_via.plot_atlas_view</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_differentiation_flow.html">pyVIA.plotting_via.plot_differentiation_flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_gene_trend_heatmaps.html">pyVIA.plotting_via.plot_gene_trend_heatmaps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_piechart_viagraph.html">pyVIA.plotting_via.plot_piechart_viagraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_population_composition.html">pyVIA.plotting_via.plot_population_composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_sc_lineage_probability.html">pyVIA.plotting_via.plot_sc_lineage_probability</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_scatter.html">pyVIA.plotting_via.plot_scatter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_trajectory_curves.html">pyVIA.plotting_via.plot_trajectory_curves</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_viagraph.html">pyVIA.plotting_via.plot_viagraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_streamplot.html">pyVIA.plotting_via.via_streamplot</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Utils.html">Util Functions for plotting</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.make_edgebundle_milestone.html">pyVIA.plotting_via.make_edgebundle_milestone</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_atlas_emb.html">pyVIA.plotting_via.via_atlas_emb</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_forcelayout.html">pyVIA.plotting_via.via_forcelayout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_mds.html">pyVIA.plotting_via.via_mds</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Datasets.html">Datasets</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.cell_cycle.html">VIA.datasets_via.cell_cycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.cell_cycle_cyto_data.html">VIA.datasets_via.cell_cycle_cyto_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.embryoid_body.html">VIA.datasets_via.embryoid_body</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.scATAC_hematopoiesis.html">VIA.datasets_via.scATAC_hematopoiesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.scRNA_hematopoiesis.html">VIA.datasets_via.scRNA_hematopoiesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.toy_disconnected.html">VIA.datasets_via.toy_disconnected</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/VIA.datasets_via.toy_multifurcating.html">VIA.datasets_via.toy_multifurcating</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Basic%20Example%20Code.html">Examples for installation checking</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Via 2.0 Atlas View Gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Atlas%20view%20examples.html">Via2.0 Atlas views</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Mouse_to_pup_atlas.html">Large Mouse Embryo to Pup Developmental Atlas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Via2%20Atlas%20Animation.html">Via 2.0 Atlas Animations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Via%20Atlas%20View%20for%20Spatial%20omics.html">Via2.0 Atlas views for Spatial Omics data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Via 2.0 Cartography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Via2.0%20Cartographic%20Mouse%20Gastrualation.html">1. Via 2.0 Cartography on Mouse Gastrulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Zebrahub%20TI%20tutorial.html">2. Via 2.0 Cartography on Zebrahub (Trajectory Inference)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Zebrahub_tutorial_visualization.html">3. Via 2.0 Cartography on Zebrahub (Visualization)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials Via</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Toy_Multifurcating.html">1. Basic workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Toy_Disconnected.html">2. Disconnected Trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_scRNA_Hematopoiesis.html">3. Via Human Hematopoiesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Imaging%20Cytometry%20%28cell%20cycle%29.html">4. Imaging cytometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/mESC_timeseries.html">5. Using time-series metadata (mESC Cytof)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Pancreas_RNAvelocity.html">6. Using RNA-velocity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_scRNAVelocity_hematopoiesis.html">7. Bone marrow with RNA-velocity</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for VIA.plotting_via</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span> <span class="k">as</span> <span class="n">normal</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">csgraph</span><span class="p">,</span> <span class="n">find</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">issparse</span><span class="p">,</span> <span class="n">spmatrix</span>
<span class="kn">import</span> <span class="nn">hnswlib</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">igraph</span> <span class="k">as</span> <span class="nn">ig</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">pygam</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1">#from utils_via import *</span>
<span class="kn">from</span> <span class="nn">pyVIA.utils_via</span> <span class="kn">import</span> <span class="o">*</span> <span class="c1">#</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>

<span class="k">def</span> <span class="nf">geodesic_distance</span><span class="p">(</span><span class="n">data</span><span class="p">:</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">knn</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mst_mode</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#make knn graph on low dimensional data &quot;data&quot;</span>
    <span class="n">knn_struct</span> <span class="o">=</span> <span class="n">construct_knn_utils</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="n">knn</span><span class="p">)</span>
    <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">knn</span><span class="p">)</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="c1">#https://igraph.org/python/versions/0.10.1/tutorials/shortest_paths/shortest_paths.html</span>
    <span class="c1"># Remove self-loops</span>
    <span class="n">msk</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">neighbors</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])[</span><span class="n">msk</span><span class="p">]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span> <span class="c1">#we keep the distances as the weights here will actually be edge distances</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mst_mode</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MST geodesic mode&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">minimum_spanning_tree</span>
        <span class="n">MST_</span> <span class="o">=</span> <span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">+</span><span class="n">MST_</span>
    <span class="n">result</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
    <span class="n">sources</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">edgelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>
    <span class="k">if</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">VertexClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">membership</span><span class="o">=</span><span class="n">cluster_labels</span><span class="p">)</span><span class="o">.</span><span class="n">cluster_graph</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">recompute_weights</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Counter</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span> <span class="c1">#returns csr matrix</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">graph</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()))</span>

        <span class="n">G</span><span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weights</span><span class="p">})</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">cluster_labels</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="c1">#get shortest distance from root to each point</span>
    <span class="n">geo_distance_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;start computing shortest paths&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vcount</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">1000</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s1"> complete&#39;</span><span class="p">)</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">to</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span>  <span class="n">output</span><span class="o">=</span><span class="s2">&quot;epath&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add up the weights across all edges on the shortest path</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">shortest_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">G</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
            <span class="n">geo_distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
            <span class="c1">#print(&quot;Shortest weighted distance is: &quot;, distance)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">geo_distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">geo_distance_list</span>

<span class="k">def</span> <span class="nf">corr_geodesic_distance_lowdim</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">time_labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span><span class="n">root</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;/home/shobi/Trajectory/Datasets/geodesic_distance.csv&#39;</span><span class="p">,</span> <span class="n">mst_mode</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cluster_labels</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">geodesic_dist</span> <span class="o">=</span> <span class="n">geodesic_distance</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="n">knn</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">mst_mode</span> <span class="o">=</span> <span class="n">mst_mode</span><span class="p">,</span><span class="n">cluster_labels</span><span class="o">=</span><span class="n">cluster_labels</span><span class="p">)</span>
    <span class="n">df_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;true_time&#39;</span><span class="p">]</span> <span class="o">=</span><span class="n">time_labels</span>
    <span class="k">if</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;cluster_labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_labels</span>
        <span class="n">df_</span> <span class="o">=</span> <span class="n">df_</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;cluster_labels&#39;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cluster_labels&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;df_groupby&#39;</span><span class="p">,</span> <span class="n">df_</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
    <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;geo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">geodesic_dist</span>
    <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;geo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;geo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">correlation</span> <span class="o">=</span> <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;geo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">df_</span><span class="p">[</span><span class="s1">&#39;true_time&#39;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">correlation geo 2d and true time, </span><span class="si">{</span><span class="n">correlation</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">df_</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">correlation</span>


<div class="viewcode-block" id="make_edgebundle_milestone"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.make_edgebundle_milestone">[docs]</a><span class="k">def</span> <span class="nf">make_edgebundle_milestone</span><span class="p">(</span><span class="n">embedding</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc_pt</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">initial_bandwidth</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">n_milestones</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">milestone_labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">sc_labels_numeric</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighted</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">global_visual_pruning</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">terminal_cluster_list</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">single_cell_lineage_prob</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform Edgebundling of edges in a milestone level to return a hammer bundle of milestone-level edges. This is more granular than the original parc-clusters but less granular than single-cell level and hence also less computationally expensive</span>
<span class="sd">    requires some type of embedding (n_samples x 2) to be available</span>

<span class="sd">    :param embedding: optional (not required if via_object is provided) embedding single cell. also looks nice when done on via_mds as more streamlined continuous diffused graph structure. Umap is a but &quot;clustery&quot;</span>
<span class="sd">    :param graph: optional (not required if via_object is provided) igraph single cell graph level</span>
<span class="sd">    :param via_object: via_object (best way to run this function by simply providing via_object)</span>
<span class="sd">    :param sc_graph: igraph graph set as the via attribute self.ig_full_graph (affinity graph)</span>
<span class="sd">    :param initial_bandwidth: increasing bw increases merging of minor edges</span>
<span class="sd">    :param decay: increasing decay increases merging of minor edges #https://datashader.org/user_guide/Networks.html</span>
<span class="sd">    :param milestone_labels: default list=[]. Usually autocomputed. but can provide as single-cell level labels (clusters, groups, which function as milestone groupings of the single cells)</span>
<span class="sd">    :param sc_labels_numeric: default is None which automatically chooses via_object&#39;s pseudotime or time_series_labels (when available). otherwise set to a list of numerical values representing some sequential/chronological information</span>
<span class="sd">    :param terminal_cluster_list: default list [] and automatically uses all terminal clusters. otherwise set to any of the terminal cluster numbers within a list</span>
<span class="sd">    :return: dictionary containing keys: hb_dict[&#39;hammerbundle&#39;] = hb hammerbundle class with hb.x and hb.y containing the coords</span>
<span class="sd">                hb_dict[&#39;milestone_embedding&#39;] dataframe with &#39;x&#39; and &#39;y&#39; columns for each milestone and hb_dict[&#39;edges&#39;] dataframe with columns [&#39;source&#39;,&#39;target&#39;] milestone for each each and [&#39;cluster_pop&#39;], hb_dict[&#39;sc_milestone_labels&#39;] is a list of milestone label for each single cell</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>

    <span class="k">if</span> <span class="n">sc_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">sc_graph</span> <span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">ig_full_graph</span>
    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">ERROR: Please provide via_object&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">WARNING: VIA will now autocompute an embedding. It would be better to precompute an embedding using embedding = via_umap() or via_mds() and setting this as the embedding attribute via_object = embedding.&#39;</span><span class="p">)</span>
            <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_mds</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="n">via_object</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_milestones</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_milestones</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1"> n_milestones is </span><span class="si">{</span><span class="n">n_milestones</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#milestone_indices = random.sample(range(n_samples), n_milestones)  # this is sampling without replacement</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">milestone_labels</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Start finding milestones&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_milestones</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
        <span class="n">milestone_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">End milestones with </span><span class="si">{</span><span class="n">n_milestones</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">#plt.scatter(embedding[:, 0], embedding[:, 1], c=milestone_labels, cmap=&#39;tab20&#39;, s=1, alpha=0.3)</span>
        <span class="c1">#plt.show()</span>
    <span class="k">if</span> <span class="n">sc_labels_numeric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sc_labels_numeric</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span>
        <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Will use via-pseudotime for edges, otherwise consider providing a list of numeric labels (single cell level) or via_object&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sc_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sc_pt</span> <span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    numeric_val_of_milestone = []</span>
<span class="sd">    if len(sc_labels_numeric)&gt;0:</span>
<span class="sd">        for cluster_i in set(milestone_labels):</span>
<span class="sd">            loc_cluster_i = np.where(np.asarray(milestone_labels)==cluster_i)[0]</span>
<span class="sd">            majority_ = func_mode(list(np.asarray(sc_labels_numeric)[loc_cluster_i]))</span>
<span class="sd">            numeric_val_of_milestone.append(majority_)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">vertex_milestone_graph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">VertexClustering</span><span class="p">(</span><span class="n">sc_graph</span><span class="p">,</span> <span class="n">membership</span><span class="o">=</span><span class="n">milestone_labels</span><span class="p">)</span><span class="o">.</span><span class="n">cluster_graph</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Recompute weights&#39;</span><span class="p">)</span>
    <span class="n">vertex_milestone_graph</span> <span class="o">=</span> <span class="n">recompute_weights</span><span class="p">(</span><span class="n">vertex_milestone_graph</span><span class="p">,</span> <span class="n">Counter</span><span class="p">(</span><span class="n">milestone_labels</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">pruning milestone graph based on recomputed weights&#39;</span><span class="p">)</span>
    <span class="c1">#was at 0.1 global_pruning for 2000+ milestones</span>
    <span class="n">edgeweights_pruned_milestoneclustergraph</span><span class="p">,</span> <span class="n">edges_pruned_milestoneclustergraph</span><span class="p">,</span> <span class="n">comp_labels</span> <span class="o">=</span> <span class="n">pruning_clustergraph</span><span class="p">(</span><span class="n">vertex_milestone_graph</span><span class="p">,</span>
                                                                                                   <span class="n">global_pruning_std</span><span class="o">=</span><span class="n">global_visual_pruning</span><span class="p">,</span>
                                                                                                   <span class="n">preserve_disconnected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                                                   <span class="n">preserve_disconnected_after_pruning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_max_outgoing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">regenerate igraph on pruned edges&#39;</span><span class="p">)</span>
    <span class="n">vertex_milestone_graph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges_pruned_milestoneclustergraph</span><span class="p">,</span>
                                <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">edgeweights_pruned_milestoneclustergraph</span><span class="p">})</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
    <span class="n">vertex_milestone_csrgraph</span> <span class="o">=</span> <span class="n">get_sparse_from_igraph</span><span class="p">(</span><span class="n">vertex_milestone_graph</span><span class="p">,</span> <span class="n">weight_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

    <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertex_milestone_csrgraph</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># clip weights to prevent distorted visual scale</span>
    <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span>
                                               <span class="mi">80</span><span class="p">))</span>  <span class="c1"># want to clip the weights used to get the layout</span>
    <span class="c1">#print(&#39;weights for layout&#39;, (weights_for_layout))</span>
    <span class="c1">#print(&#39;weights for layout std&#39;, np.std(weights_for_layout))</span>

    <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">weights_for_layout</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">)</span>
    <span class="c1">#print(&#39;weights for layout post-std&#39;, weights_for_layout)</span>
    <span class="c1">#print(f&#39;{datetime.now()}\tregenerate igraph after clipping&#39;)</span>
    <span class="n">vertex_milestone_graph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">vertex_milestone_csrgraph</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())),</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">)})</span>

    <span class="c1">#layout = vertex_milestone_graph.layout_fruchterman_reingold()</span>
    <span class="c1">#embedding = np.asarray(layout.coords)</span>

    <span class="c1">#print(f&#39;{datetime.now()}\tmake node dataframe&#39;)</span>
    <span class="n">data_node</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_node</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
    <span class="n">nodes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_pt</span>
    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">terminal_cluster_list</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
        <span class="n">single_cell_lineage_prob</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_bp_rownormed</span><span class="c1">#_rownormed#_rownormed does not make a huge difference whether or not rownorming is applied. (default not rownormed)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terminal_cluster_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">single_cell_lineage_prob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terminal_cluster_list</span><span class="p">):</span>
            <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;sc_lineage_probability_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">single_cell_lineage_prob</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sc_labels_numeric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Setting numeric label as time_series_labels or other sequential metadata for coloring edges&#39;</span><span class="p">)</span>
        <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_labels_numeric</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Setting numeric label as single cell pseudotime for coloring edges&#39;</span><span class="p">)</span>
        <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_pt</span>

    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;kmeans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">milestone_labels</span>
    <span class="n">group_pop</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">milestone_labels</span><span class="p">)):</span>
        <span class="n">group_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">milestone_labels</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="n">nodes_mean</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;kmeans&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">nodes_mean</span><span class="p">[</span><span class="s1">&#39;cluster population&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_pop</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">tuple</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vertex_milestone_graph</span><span class="o">.</span><span class="n">es</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">])</span>

    <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;weight0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex_milestone_graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span>

    <span class="c1"># seems to work better when allowing the bundling to occur on unweighted representation and later using length of segments to color code significance</span>
    <span class="k">if</span> <span class="n">weighted</span> <span class="o">==</span><span class="kc">True</span><span class="p">:</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;weight0&#39;</span><span class="p">]</span><span class="c1">#1  # [1/i for i in edges[&#39;weight0&#39;]]np.where((edges[&#39;source_cluster&#39;] != edges[&#39;target_cluster&#39;]) , 1,0.1)#[1/i for i in edges[&#39;weight0&#39;]]#</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Making smooth edges&#39;</span><span class="p">)</span>
    <span class="n">hb</span> <span class="o">=</span> <span class="n">hammer_bundle</span><span class="p">(</span><span class="n">nodes_mean</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">initial_bandwidth</span><span class="o">=</span><span class="n">initial_bandwidth</span><span class="p">,</span>
                       <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">)</span>  <span class="c1"># default bw=0.05, dec=0.7</span>
    <span class="c1"># hb.x and hb.y contain all the x and y coords of the points that make up the edge lines.</span>
    <span class="c1"># each new line segment is separated by a nan value</span>
    <span class="c1"># https://datashader.org/_modules/datashader/bundling.html#hammer_bundle</span>
    <span class="c1">#nodes_mean contains the averaged &#39;x&#39; and &#39;y&#39; milestone locations based on the embedding</span>
    <span class="n">hb_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">hb_dict</span><span class="p">[</span><span class="s1">&#39;hammerbundle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hb</span>
    <span class="n">hb_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_mean</span>
    <span class="n">hb_dict</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span>
    <span class="n">hb_dict</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">milestone_labels</span>

    <span class="k">return</span> <span class="n">hb_dict</span></div>

<div class="viewcode-block" id="plot_gene_trend_heatmaps"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_gene_trend_heatmaps">[docs]</a><span class="k">def</span> <span class="nf">plot_gene_trend_heatmaps</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">df_gene_exp</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">marker_lineages</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">fontsize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">cmap</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ytick_labelrotation</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fig_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Plot the gene trends on heatmap: a heatmap is generated for each lineage (identified by terminal cluster number). Default selects all lineages</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param df_gene_exp: pandas DataFrame single-cell level expression [cells x genes]</span>
<span class="sd">    :param marker_lineages: list default = None and plots all detected all lineages. Optionally provide a list of integers corresponding to the cluster number of terminal cell fates</span>
<span class="sd">    :param fontsize: int default = 8</span>
<span class="sd">    :param cmap: str default = &#39;viridis&#39;</span>
<span class="sd">    :param normalize: bool = True</span>
<span class="sd">    :param ytick_labelrotation: int default = 0</span>
<span class="sd">    :return: fig and list of axes</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">marker_lineages</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
    <span class="n">dict_trends</span> <span class="o">=</span> <span class="n">get_gene_trend</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="n">via_object</span><span class="p">,</span> <span class="n">marker_lineages</span><span class="o">=</span><span class="n">marker_lineages</span><span class="p">,</span> <span class="n">df_gene_exp</span><span class="o">=</span><span class="n">df_gene_exp</span><span class="p">)</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_trends</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;branches&#39;</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">dict_trends</span><span class="p">[</span><span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;trends&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span>
    <span class="c1"># Standardize the matrix (standardization along each gene. Since SS function scales the columns, we first transpose the df)</span>
    <span class="c1">#  Set up plot</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="n">fig_width</span><span class="p">,</span> <span class="n">height</span><span class="p">])</span>
    <span class="n">ax_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">df_trends</span><span class="o">=</span><span class="n">dict_trends</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="s1">&#39;trends&#39;</span><span class="p">]</span>
        <span class="c1"># normalize each genes (feature)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">df_trends</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df_trends</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df_trends</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">df_trends</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lineage: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dict_trends</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fontsize</span><span class="o">*</span><span class="mf">1.3</span><span class="p">))</span>
        <span class="c1">#sns.set(size=fontsize)  # set fontsize 2</span>
        <span class="n">b</span><span class="o">=</span><span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">df_trends</span><span class="p">,</span><span class="n">yticklabels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">)</span>
        <span class="n">b</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span><span class="n">labelrotation</span><span class="o">=</span><span class="n">ytick_labelrotation</span><span class="p">)</span>
        <span class="n">b</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;pseudotime&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fontsize</span><span class="o">*</span><span class="mf">1.3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax_list</span></div>

<div class="viewcode-block" id="plot_scatter"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_scatter">[docs]</a><span class="k">def</span> <span class="nf">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">:</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span><span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text_labels</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sc_index_terminal_states</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">true_labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">show_legend</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    General scatter plotting tool for numeric and categorical labels on the single-cell level</span>

<span class="sd">    :param embedding: ndarray n_samples x 2</span>
<span class="sd">    :param labels: list single cell labels list of number or strings</span>
<span class="sd">    :param cmap: str default = &#39;rainbow&#39;</span>
<span class="sd">    :param s: int size of scatter dot</span>
<span class="sd">    :param alpha: float with 0 transparent to 1 opaque default =0.3</span>
<span class="sd">    :param edgecolors:</span>
<span class="sd">    :param title: str</span>
<span class="sd">    :param text_labels: bool default =True</span>
<span class="sd">    :param via_object:</span>
<span class="sd">    :param sc_index_terminal_states: list of integers corresponding to one cell in each of the terminal states</span>
<span class="sd">    :param color_dict: {&#39;true_label_group_1&#39;: #COLOR,&#39;true_label_group_2&#39;: #COLOR2,....} where the dictionary keys correspond to the provided labels</span>
<span class="sd">    :param true_labels: list of single cell labels used to annotate the terminal states</span>
<span class="sd">    :return: matplotlib pyplot fig, ax</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">color_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#:param color_dict: {&#39;true_label_group_1&#39;: #COLOR,&#39;true_label_group_2&#39;: #COLOR2,....} where the dictionary keys correspond to the provided labels</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">color_dict</span><span class="p">:</span>
            <span class="n">loc_key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">)</span>
            <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">text_labels</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">categorical</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">set_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="n">set_labels</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">set_labels</span><span class="p">):</span>
            <span class="n">color_dict</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">palette</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">cmap_</span> <span class="o">=</span> <span class="n">palette</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">color_dict</span><span class="p">:</span>
            <span class="n">loc_key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">cmap_</span><span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]],</span> <span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">)</span>
            <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">text_labels</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                        <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span>
                   <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tsi_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tsi</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
                <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">val_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>

                <span class="n">th_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">val_pt</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># 50</span>
                <span class="n">loc_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_pt</span><span class="p">))</span> <span class="k">if</span> <span class="n">val_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_pt</span><span class="p">]</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">loc_i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">labelsq</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="n">tsi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelsq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;root:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">root_user</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;knn&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;Ncomp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">ncomp</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tsi_list</span><span class="p">:</span>
                <span class="c1"># print(i, &#39; has traj and cell type&#39;, self.df_annot.loc[i, [&#39;Main_trajectory&#39;, &#39;Main_cell_type&#39;]])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;_Cell&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sc_index_terminal_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_index_terminal_states</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;_Cell&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">title</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;scatter plot&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show_legend</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Hide axes ticks</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="c1"># Hide grid lines</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<span class="k">def</span> <span class="nf">_make_knn_embeddedspace</span><span class="p">(</span><span class="n">embedding</span><span class="p">):</span>
    <span class="c1"># knn struct built in the embedded space to be used for drawing the lineage trajectories onto the 2D plot</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="n">hnswlib</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">knn</span><span class="o">.</span><span class="n">init_index</span><span class="p">(</span><span class="n">max_elements</span><span class="o">=</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef_construction</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">knn</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">knn</span><span class="o">.</span><span class="n">set_ef</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">knn</span>

<div class="viewcode-block" id="via_forcelayout"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.via_forcelayout">[docs]</a><span class="k">def</span> <span class="nf">via_forcelayout</span><span class="p">(</span><span class="n">X_pca</span><span class="p">,</span> <span class="n">viagraph_full</span><span class="p">:</span> <span class="n">csr_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
             <span class="n">n_milestones</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">time_series_labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">knn_seq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute force directed layout. #TODO not complete</span>

<span class="sd">    :param X_pca:</span>
<span class="sd">    :param viagraph_full: optional. if calling before via, then None. if calling after or from within via, then we can use the via-graph to reinforce the layout</span>
<span class="sd">    :param k:</span>
<span class="sd">    :param random_seed:</span>
<span class="sd">    :param t_diffusion:</span>
<span class="sd">    :param n_milestones:</span>
<span class="sd">    :param time_series_labels:</span>
<span class="sd">    :param knn_seq:</span>
<span class="sd">    :return: ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># use the csr_full_graph from via and subsample it.</span>
    <span class="c1"># but this results in a very fragmented graph because the subsampling index is too small a fraction of the total number of possible edges.</span>
    <span class="c1"># only works if you take a high enough percentage of the original samples</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Commencing Force Layout&quot;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">milestone_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">X_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">n_milestones</span><span class="p">)</span>  <span class="c1"># this is sampling without replacement</span>
    <span class="k">if</span> <span class="n">viagraph_full</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">viagraph_full</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">]</span>  <span class="c1">#</span>
        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn</span><span class="p">[:,</span> <span class="n">milestone_indices</span><span class="p">]</span>
        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">milestone_knn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>



    <span class="n">knn_struct</span> <span class="o">=</span> <span class="n">construct_knn_utils</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">knn</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># we need to add the new knn (milestone_knn_new) built on the subsampled indices to ensure connectivity. o/w graph is fragmented if only relying on the subsampled graph</span>
    <span class="k">if</span> <span class="n">time_series_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">time_series_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">time_series_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)[</span><span class="n">milestone_indices</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">milestone_knn_new</span> <span class="o">=</span> <span class="n">affinity_milestone_knn</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">knn_struct</span><span class="o">=</span><span class="n">knn_struct</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                               <span class="n">time_series_labels</span><span class="o">=</span><span class="n">time_series_labels</span><span class="p">,</span> <span class="n">knn_seq</span><span class="o">=</span><span class="n">knn_seq</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;milestone knn new&#39;</span><span class="p">,</span> <span class="n">milestone_knn_new</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">milestone_knn_new</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">viagraph_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn_new</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn</span> <span class="o">+</span> <span class="n">milestone_knn_new</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;final reinforced milestone knn&#39;</span><span class="p">,</span> <span class="n">milestone_knn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;number of nonzero edges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">milestone_knn</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;force layout&#39;</span><span class="p">)</span>
    <span class="n">g_layout</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">milestone_knn</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())))</span>  <span class="c1"># , edge_attrs={&#39;weight&#39;: weights_for_layout})</span>
    <span class="n">layout</span> <span class="o">=</span> <span class="n">g_layout</span><span class="o">.</span><span class="n">layout_fruchterman_reingold</span><span class="p">()</span>
    <span class="n">force_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
    <span class="c1">#compute knn used to estimate the embedding values of the full sample set based on embedding values computed just for a milestone subset of the full sample</span>
    <span class="n">neighbor_array</span><span class="p">,</span> <span class="n">distance_array</span> <span class="o">=</span> <span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">X_pca</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of &#39;</span><span class="p">,</span> <span class="n">X_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">row_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distance_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">distance_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_znormed_dist_array</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">distance_array</span> <span class="o">-</span> <span class="n">row_mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">row_var</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># when k is very small, then you can get very large affinities due to var being ~0</span>
    <span class="n">row_znormed_dist_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">row_znormed_dist_array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_znormed_dist_array</span><span class="p">[</span><span class="n">row_znormed_dist_array</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">affinity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">row_znormed_dist_array</span><span class="p">)</span>
    <span class="n">affinity_array</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">affinity_array</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># row stoch</span>

    <span class="n">row_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_cells</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ncells and neighs&#39;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">)</span>

    <span class="n">row_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span> <span class="o">*</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>

    <span class="n">col_list</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">list_affinity</span> <span class="o">=</span> <span class="n">affinity_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">csr_knn</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">list_affinity</span><span class="p">,</span> <span class="p">(</span><span class="n">row_list</span><span class="p">,</span> <span class="n">col_list</span><span class="p">)),</span>
                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">milestone_indices</span><span class="p">)))</span>  <span class="c1"># n_samples*n_milestones</span>

    <span class="n">milestone_force</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">force_layout</span><span class="p">)</span>  <span class="c1">##TODO remove this we are just testing force layout</span>
    <span class="n">full_force</span> <span class="o">=</span> <span class="n">csr_knn</span> <span class="o">*</span> <span class="n">milestone_force</span>  <span class="c1"># is a matrix</span>
    <span class="n">full_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">full_force</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>


    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">full_force</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">full_force</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;full mds&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">full_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">full_force</span><span class="p">,</span> <span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">U_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">full_force</span><span class="p">)</span>
        <span class="n">U_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">full_force</span></div>

<div class="viewcode-block" id="via_mds"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.via_mds">[docs]</a><span class="k">def</span> <span class="nf">via_mds</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X_pca</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">viagraph_full</span><span class="p">:</span> <span class="n">csr_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diffusion_op</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_milestones</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">time_series_labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">knn_seq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k_project_milestones</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">t_difference</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">embedding_type</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;mds&#39;</span><span class="p">,</span> <span class="n">double_diffusion</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Fast computation of a 2D embedding based on previous StaVia analysis.</span>

<span class="sd">    FOR EXAMPLE:</span>
<span class="sd">    via_object.embedding = via.via_mds(via_object = v0)</span>
<span class="sd">    plot_scatter(embedding = via_object.embedding, labels = via_object.true_labels)</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param X_pca: dimension reduced (only if via_object is not passed)</span>
<span class="sd">    :param viagraph_full: optional. if calling before or without via, then None and a milestone graph will be computed. if calling after or from within via, then we can use the via-graph to reinforce the layout of the milestone graph</span>
<span class="sd">    :param k: number of knn for the via_mds reinforcement graph on milestones. default =15. integers 5-20 are reasonable</span>
<span class="sd">    :param random_seed: randomseed integer</span>
<span class="sd">    :param t_diffusion: default integer value = 1 with higher values generate more smoothing</span>
<span class="sd">    :param n_milestones: number of milestones used to generate the initial embedding</span>
<span class="sd">    :param time_series_labels: numerical values in list form representing some sequentual information</span>
<span class="sd">    :param knn_seq: if time-series data is available, this will augment the knn with sequential neighbors (2-10 are reasonable values) default =5</span>
<span class="sd">    :param embedding_type: default = &#39;mds&#39; or set to &#39;umap&#39;</span>
<span class="sd">    :param double_diffusion: default is False. To achieve sharper strokes/lineages, set to True</span>
<span class="sd">    :param k_project_milestones: number of milestones in the milestone-knngraph used to compute the single-cell projection</span>
<span class="sd">    :param n_iterations: number of iterations to run</span>
<span class="sd">    :param neighbors_distances: array of distances of each neighbor for each cell (n_cells x knn) used when called from within via.run() for autocompute via-mds</span>
<span class="sd">    :return: numpy array of size n_samples x 2</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># use the csr_full_graph from via and subsample it.</span>
    <span class="c1"># but this results in a very fragmented graph because the subsampling index is too small a fraction of the total number of possible edges.</span>
    <span class="c1"># only works if you take a high enough percentage of the original samples</span>
    <span class="c1">#however, omitting the integration of csr_full_graph also compromises the ability of the embedding to better reflect the underlying trajectory in terms of global structure</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Commencing Via-MDS&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">X_pca</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">X_pca</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">viagraph_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">viagraph_full</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">csr_full_graph</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_milestones</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_milestones</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span><span class="o">*</span><span class="n">n_samples</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">n_milestones</span> <span class="o">&gt;</span> <span class="n">n_samples</span><span class="p">:</span>
        <span class="n">n_milestones</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Resetting n_milestones to </span><span class="si">{</span><span class="n">n_milestones</span><span class="si">}</span><span class="s2"> as n_samples &gt; original n_milestones&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if n_milestones &lt; n_samples:</span>
<span class="sd">        if via_object is not None: milestone_indices = density_sampling(neighbors_distances= via_object.full_neighbor_array, desired_samples = n_milestones)</span>
<span class="sd">        else: milestone_indices = density_sampling(neighbors_distances= neighbors_distances, desired_samples = n_milestones)</span>
<span class="sd">        print(f&#39;number of milestone indices from density sampling {milestone_indices.shape}&#39;)</span>
<span class="sd">        print(&#39;exp=True, dens sampling&#39;)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="n">milestone_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">X_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">n_milestones</span><span class="p">)</span> <span class="c1">#this is sampling without replacement</span>

    <span class="k">if</span> <span class="n">viagraph_full</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">viagraph_full</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">]</span>  <span class="c1">#</span>
        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn</span><span class="p">[:,</span> <span class="n">milestone_indices</span><span class="p">]</span>
        <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">milestone_knn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#using these effectively emphasises the edges that are pass an even more stringent requirement on Nearest neighbors (since they are selected from the full set of cells, rather than a subset of milestones)</span>
    <span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">knn_struct</span> <span class="o">=</span> <span class="n">construct_knn_utils</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">knn</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># we need to add the new knn (milestone_knn_new) built on the subsampled indices to ensure connectivity. o/w graph is fragmented if only relying on the subsampled graph</span>
    <span class="k">if</span> <span class="n">time_series_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">time_series_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">time_series_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)[</span><span class="n">milestone_indices</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">milestone_knn_new</span> <span class="o">=</span> <span class="n">affinity_milestone_knn</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">knn_struct</span><span class="o">=</span><span class="n">knn_struct</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                               <span class="n">time_series_labels</span><span class="o">=</span><span class="n">time_series_labels</span><span class="p">,</span> <span class="n">knn_seq</span><span class="o">=</span><span class="n">knn_seq</span><span class="p">,</span> <span class="n">t_difference</span><span class="o">=</span><span class="n">t_difference</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">viagraph_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn_new</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">milestone_knn</span> <span class="o">=</span> <span class="n">milestone_knn</span> <span class="o">+</span> <span class="n">milestone_knn_new</span>


    <span class="c1"># build a knn to project the input n_samples based on milestone knn</span>

    <span class="n">neighbor_array</span><span class="p">,</span> <span class="n">distance_array</span> <span class="o">=</span> <span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">X_pca</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k_project_milestones</span><span class="p">)</span> <span class="c1">#[n_samples x n_milestones]</span>

    <span class="n">row_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distance_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">distance_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_znormed_dist_array</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">distance_array</span> <span class="o">-</span> <span class="n">row_mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">row_var</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># when k is very small, then you can get very large affinities due to var being ~0</span>
    <span class="n">row_znormed_dist_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">row_znormed_dist_array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_znormed_dist_array</span><span class="p">[</span><span class="n">row_znormed_dist_array</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">affinity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">row_znormed_dist_array</span><span class="p">)</span>
    <span class="n">affinity_array</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">affinity_array</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># row stoch</span>

    <span class="n">row_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_cells</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">row_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span> <span class="o">*</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>

    <span class="n">col_list</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">list_affinity</span> <span class="o">=</span> <span class="n">affinity_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">csr_knn</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">list_affinity</span><span class="p">,</span> <span class="p">(</span><span class="n">row_list</span><span class="p">,</span> <span class="n">col_list</span><span class="p">)),</span>
                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">milestone_indices</span><span class="p">)))</span>  <span class="c1"># n_samples*n_milestones</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Start computing with diffusion power:</span><span class="si">{</span><span class="n">diffusion_op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#r2w_input = pd.read_csv(        &#39;/home/shobi/Trajectory/Datasets/EB_Phate/RW2/pc20_knn100kseq50krev50RW2_sparse_matrix029_P1_Q10.csv&#39;)</span>
    <span class="c1">#r2w_input = r2w_input.drop([&#39;Unnamed: 0&#39;], axis=1).values</span>
    <span class="c1">#input = r2w_input[:, 0:30]</span>
    <span class="c1">#input = input[milestone_indices, :]</span>
    <span class="c1"># print(&#39;USING RW2 COMPS&#39;)</span>




    <span class="k">if</span> <span class="n">embedding_type</span> <span class="o">==</span> <span class="s1">&#39;mds&#39;</span><span class="p">:</span> <span class="n">milestone_mds</span> <span class="o">=</span> <span class="n">sgd_mds</span><span class="p">(</span><span class="n">via_graph</span><span class="o">=</span><span class="n">milestone_knn</span><span class="p">,</span> <span class="n">X_pca</span><span class="o">=</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">diff_op</span><span class="o">=</span><span class="n">diffusion_op</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span> <span class="n">double_diffusion</span><span class="o">=</span><span class="n">double_diffusion</span><span class="p">)</span>  <span class="c1"># returns an ndarray</span>
    <span class="k">elif</span> <span class="n">embedding_type</span> <span class="o">==</span><span class="s1">&#39;umap&#39;</span><span class="p">:</span> <span class="n">milestone_mds</span> <span class="o">=</span> <span class="n">via_umap</span><span class="p">(</span><span class="n">X_input</span><span class="o">=</span><span class="n">X_pca</span><span class="p">[</span><span class="n">milestone_indices</span><span class="p">,</span> <span class="p">:],</span> <span class="n">graph</span><span class="o">=</span><span class="n">milestone_knn</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">End computing mds with diffusion power:</span><span class="si">{</span><span class="n">diffusion_op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#TESTING</span>
    <span class="c1">#plt.scatter(milestone_mds[:, 0], milestone_mds[:, 1], s=1)</span>
    <span class="c1">#plt.title(&#39;sampled&#39;)</span>
    <span class="c1">#plt.show()</span>

    <span class="n">milestone_mds</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">milestone_mds</span><span class="p">)</span>

    <span class="n">full_mds</span> <span class="o">=</span> <span class="n">csr_knn</span> <span class="o">*</span> <span class="n">milestone_mds</span>  <span class="c1"># is a matrix</span>
    <span class="n">full_mds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">full_mds</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>

    <span class="c1"># TESTING</span>
    <span class="c1">#plt.scatter(full_mds[:, 0].tolist(), full_mds[:, 1].tolist(), s=1, alpha=0.3, c=&#39;green&#39;)</span>
    <span class="c1">#plt.title(&#39;full&#39;)</span>
    <span class="c1">#plt.show()</span>
    <span class="n">full_mds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">full_mds</span><span class="p">,</span> <span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">U_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">full_mds</span><span class="p">)</span>
        <span class="n">U_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full_mds</span></div>

<div class="viewcode-block" id="via_atlas_emb"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.via_atlas_emb">[docs]</a><span class="k">def</span> <span class="nf">via_atlas_emb</span><span class="p">(</span><span class="n">via_object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">X_input</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span><span class="n">csr_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">negative_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                  <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spread</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">init_pos</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;via&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">n_epochs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_membership</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Run dimensionality reduction using the StaVia modified HNSW graph using via cluster graph initialization when Via_object is provided.</span>

<span class="sd">    :param via_object: if via_object is provided then X_input and graph are ignored</span>
<span class="sd">    :param X_input: ndarray nsamples x features (PCs)</span>
<span class="sd">    :param graph: csr_matrix of knngraph. This usually is via&#39;s pruned, sequentially augmented sc-knn graph accessed as an attribute of via via_object.csr_full_graph</span>
<span class="sd">    :param n_components:</span>
<span class="sd">    :param alpha:</span>
<span class="sd">    :param negative_sample_rate:</span>
<span class="sd">    :param gamma: Weight to apply to negative samples.</span>
<span class="sd">    :param spread: The effective scale of embedded points. In combination with min_dist this determines how clustered/clumped the embedded points are.</span>
<span class="sd">    :param min_dist: The effective minimum distance between embedded points. Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points</span>
<span class="sd">    :param init_pos: either a string (default) &#39;via&#39; (uses via graph to initialize), or &#39;spectral&#39;. Or a n_cellx2 dimensional ndarray with initial coordinates</span>
<span class="sd">    :param random_state:</span>
<span class="sd">    :param n_epochs: The number of training epochs to be used in optimizing the low dimensional embedding. Larger values result in more accurate embeddings. If 0 is specified a value will be selected based on the size of the input dataset (200 for large datasets, 500 for small).</span>
<span class="sd">    :param distance_metric:</span>
<span class="sd">    :param layout: ndarray . custom initial layout. (n_cells x2). also requires cluster_membership labels</span>
<span class="sd">    :param cluster_membership: via_object.labels (cluster level labels of length n_samples corresponding to the layout)</span>
<span class="sd">    :return: ndarray of shape (nsamples,n_components)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">X_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">ERROR: please provide both X_input and graph&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">X_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="n">X_input</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">data</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X-input&#39;</span><span class="p">,</span> <span class="n">X_input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">csr_full_graph</span>
        <span class="k">if</span> <span class="n">cluster_membership</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cluster_membership</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
    <span class="c1">#X_input = via0.data</span>
    <span class="n">n_cells</span> <span class="o">=</span> <span class="n">X_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len membership and n_cells&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_membership</span><span class="p">),</span> <span class="n">n_cells</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;n cell </span><span class="si">{</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#graph = graph+graph.T</span>
    <span class="c1">#graph = via0.csr_full_graph</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Computing embedding on sc-Viagraph&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">umap.umap_</span> <span class="kn">import</span> <span class="n">find_ab_params</span><span class="p">,</span> <span class="n">simplicial_set_embedding</span>
    <span class="c1">#graph is a csr matrix</span>
    <span class="c1">#weight all edges as 1 in order to prevent umap from pruning weaker edges away</span>
    <span class="n">layout_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">init_pos</span><span class="o">==</span><span class="s1">&#39;via&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1">#list of lists [[x,y], [x1,y1], []]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">layout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cluster_membership</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;please provide via object or values for arguments: layout and cluster_membership&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cells</span><span class="p">):</span>
                <span class="n">layout_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">layout</span><span class="p">[</span><span class="n">cluster_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">layout_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">layout</span><span class="p">[</span><span class="n">cluster_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">init_pos</span> <span class="o">=</span> <span class="n">layout_array</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">using via cluster graph to initialize embedding&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">init_pos</span> <span class="o">==</span> <span class="s1">&#39;via&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span>
        <span class="n">cluster_membership</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cells</span><span class="p">):</span>
            <span class="n">layout_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">layout</span><span class="p">[</span><span class="n">cluster_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">layout_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">layout</span><span class="p">[</span><span class="n">cluster_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">init_pos</span> <span class="o">=</span> <span class="n">layout_array</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">using via cluster graph to initialize embedding&#39;</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">find_ab_params</span><span class="p">(</span><span class="n">spread</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">)</span>
    <span class="c1">#print(&#39;a,b, spread, dist&#39;, a, b, spread, min_dist)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#m = graph.data.max()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span>
    <span class="c1">#graph.data = 1 + graph.data/m</span>
    <span class="c1">#graph.data.fill(1)</span>
    <span class="c1">#print(&#39;average graph.data&#39;, round(np.mean(graph.data),4), round(np.max(graph.data),2))</span>
    <span class="c1">#graph.data = graph.data + np.mean(graph.data)</span>

    <span class="c1">#transpose =graph.transpose()</span>

    <span class="c1">#prod_matrix = graph.multiply(transpose)</span>
    <span class="c1">#graph = graph + transpose - prod_matrix</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numba</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;before setting numba threads&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;there are </span><span class="si">{</span><span class="n">numba</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">()</span><span class="si">}</span><span class="s1"> threads&#39;</span><span class="p">)</span>
        <span class="n">numba</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;there are now </span><span class="si">{</span><span class="n">numba</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">()</span><span class="si">}</span><span class="s1"> threads&#39;</span><span class="p">)</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using parallel, the random_state will not be used.&#39;</span><span class="p">)</span>

        <span class="n">do_randomize_init</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">do_randomize_init</span><span class="p">:</span>
            <span class="n">init_pos</span> <span class="o">=</span> <span class="n">init_pos</span> <span class="o">+</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                <span class="n">scale</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">init_pos</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">X_emb</span><span class="p">,</span> <span class="n">aux_data</span> <span class="o">=</span> <span class="n">simplicial_set_embedding</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">X_input</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                                                   <span class="n">initial_alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                   <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">metric_kwds</span><span class="o">=</span><span class="p">{},</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                                                   <span class="n">metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
                                                   <span class="n">negative_sample_rate</span><span class="o">=</span><span class="n">negative_sample_rate</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init_pos</span><span class="p">,</span>
                                                   <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                                                   <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_dens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">densmap_kwds</span><span class="o">=</span><span class="p">{},</span> <span class="n">densmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">U_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_emb</span><span class="p">)</span>
        <span class="n">U_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">saveto</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_emb</span></div>


<span class="k">def</span> <span class="nf">run_umap_hnsw</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X_input</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">csr_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                  <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">negative_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                  <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spread</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">init_pos</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;spectral&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                  <span class="n">n_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">cluster_membership</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Warning: in future call via_umap() to run this function&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">via_umap</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="n">via_object</span><span class="p">,</span> <span class="n">X_input</span><span class="o">=</span><span class="n">X_input</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">negative_sample_rate</span><span class="o">=</span><span class="n">negative_sample_rate</span><span class="p">,</span>
                    <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="n">spread</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">init_pos</span><span class="o">=</span><span class="n">init_pos</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
                    <span class="n">cluster_membership</span><span class="o">=</span><span class="n">cluster_membership</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="n">saveto</span><span class="p">)</span>


<div class="viewcode-block" id="plot_population_composition"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_population_composition">[docs]</a><span class="k">def</span> <span class="nf">plot_population_composition</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">time_labels</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">celltype_list</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">legend</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span><span class="n">xlabel</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Cell populations&#39;</span><span class="p">,</span> <span class="n">color_dict</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot population compositions along known time stamps.</span>

<span class="sd">    :param via_object: optional. this is required unless both time_labels and cell_labels are provided as arguments to the function</span>
<span class="sd">    :param time_labels: list length n_cells of pseudotime or known stage numeric labels</span>
<span class="sd">    :param cell_labels:  list of cell type or cluster length n_cells</span>
<span class="sd">    :return: ax</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">time_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>
        <span class="n">maxpt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="n">maxpt</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pt</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">pt</span><span class="o">=</span> <span class="n">time_labels</span>
    <span class="n">maxpt</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="n">minpt</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">celltype_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">celltype_list</span><span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>
    <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">df_full</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pt</span><span class="p">]</span>
    <span class="n">df_full</span><span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">celltype_list</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;head df full </span><span class="si">{</span><span class="n">df_full</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n_intervals</span>
    <span class="n">interval_step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span><span class="o">/</span><span class="n">n_intervals</span>
    <span class="n">interval_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
    <span class="n">set_celltype_sorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">celltype_list</span><span class="p">))))</span>
    <span class="n">df_population</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">minpt</span> <span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">interval_step</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)],</span> <span class="n">columns</span><span class="o">=</span><span class="n">set_celltype_sorted</span><span class="p">)</span>

    <span class="n">index_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">interval_i</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span><span class="p">:</span>
        <span class="n">df_temp</span> <span class="o">=</span> <span class="n">df_full</span><span class="p">[((</span><span class="n">df_full</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">interval_i</span><span class="o">+</span><span class="n">interval_step</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_full</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minpt</span><span class="o">+</span><span class="n">interval_i</span><span class="p">))]</span>

        <span class="n">dict_temp</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">df_temp</span><span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fraction</span><span class="p">:</span>
            <span class="n">n_samples_temp</span> <span class="o">=</span> <span class="n">df_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_temp</span><span class="p">:</span>
                <span class="n">dict_temp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_temp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">n_samples_temp</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dict temp&#39;</span><span class="p">,</span> <span class="n">dict_temp</span><span class="p">)</span>
        <span class="n">dict_temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dict_temp</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="n">interval_i</span> <span class="o">+=</span> <span class="n">interval_step</span>
        <span class="k">for</span> <span class="n">key_pop_i</span> <span class="ow">in</span> <span class="n">dict_temp</span><span class="p">:</span>
            <span class="n">df_population</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">minpt</span><span class="o">+</span><span class="p">(</span><span class="n">index_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">interval_step</span><span class="p">,</span><span class="n">key_pop_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_temp</span><span class="p">[</span><span class="n">key_pop_i</span><span class="p">]</span>
        <span class="n">index_i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">+</span> <span class="s1">&#39;n_intervals&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">color_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>    <span class="n">ax</span> <span class="o">=</span> <span class="n">df_population</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">legend</span> <span class="o">=</span> <span class="n">legend</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color_dict</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span><span class="n">xlabel</span> <span class="o">=</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>     <span class="n">ax</span> <span class="o">=</span> <span class="n">df_population</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">legend</span> <span class="o">=</span> <span class="n">legend</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span><span class="n">xlabel</span> <span class="o">=</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="plot_differentiation_flow"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_differentiation_flow">[docs]</a><span class="k">def</span> <span class="nf">plot_differentiation_flow</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span>  <span class="n">idx</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">marker_lineages</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">label_node</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">do_log_flow</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">alpha_factor</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span><span class="n">majority_cluster_population_dict</span><span class="p">:</span><span class="nb">dict</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap_sankey</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">title_str</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;Differentiation Flow&#39;</span><span class="p">,</span> <span class="n">root_cluster_list</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draws sankey plots visualising lineage and cell fate.</span>

<span class="sd">    #SANKEY PLOTS</span>
<span class="sd">    G is the igraph knn (low K) used for shortest path in high dim space. no idx needed as it&#39;s made on full sample</span>
<span class="sd">    knn_hnsw is the knn made in the embedded space used for query to find the nearest point in the downsampled embedding</span>
<span class="sd">    that corresponds to the single cells in the full graph</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param embedding: n_samples x 2. embedding is 2D representation of the full dataset.</span>
<span class="sd">    :param idx: if one uses a downsampled embedding of the original data, then idx is the selected indices of the downsampled samples used in the visualization</span>
<span class="sd">    :param cmap_name:</span>
<span class="sd">    :param dpi:</span>
<span class="sd">    :param do_log_flow bool True (default) take the natural log (1+edge flow value)</span>
<span class="sd">    :param label_node list of labels for each cell (could be cell type, stage level) length is n_cells</span>
<span class="sd">    :param scatter_size: if None, then auto determined based on n_cells</span>
<span class="sd">    :param marker_lineages: Default is to use all lineage pathways. other provide a list of lineage number (terminal cluster number).</span>
<span class="sd">    :param alpha_factor: float transparency</span>
<span class="sd">    :param root_cluster_list: list of roots by cluster number e.g. [5] means a good root is cluster number 5</span>
<span class="sd">    :return: fig, axs</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">math</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">marker_lineages</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
    <span class="k">if</span> <span class="n">root_cluster_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root_cluster_list</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">root</span>


    <span class="k">else</span><span class="p">:</span> <span class="n">marker_lineages</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">marker_lineages</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">]</span><span class="c1">#via_object.terminal_clusters]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Marker_lineages: </span><span class="si">{</span><span class="n">marker_lineages</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if embedding is None:</span>
<span class="sd">        if via_object.embedding is None:</span>
<span class="sd">            print(&#39;ERROR: please provide a single cell embedding or run re-via with do_compute_embedding==True using either embedding_type = via-umap OR via-mds&#39;)</span>
<span class="sd">            return</span>
<span class="sd">        else:</span>
<span class="sd">            print(f&#39;automatically setting embedding to via_object.embedding&#39;)</span>
<span class="sd">            embedding = via_object.embedding</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#make the sankey node labels either using via_obect.true_label or the labels provided by the user</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Start dictionary modes&#39;</span><span class="p">)</span>
    <span class="n">df_mode</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">df_mode</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
    <span class="c1"># df_mode[&#39;celltype&#39;] = pre_labels_celltype_df[&#39;fine&#39;].tolist()#v0.true_label</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_node</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">df_mode</span><span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_node</span><span class="c1"># v0.true_label</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">df_mode</span><span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>
    <span class="n">majority_cluster_population_dict</span> <span class="o">=</span> <span class="n">df_mode</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;cluster&#39;</span><span class="p">])[</span><span class="s1">&#39;celltype&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># agg(pd.Series.mode would give all modes) #series</span>
    <span class="n">majority_cluster_population_dict</span> <span class="o">=</span> <span class="n">majority_cluster_population_dict</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">End dictionary modes&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="c1">#G = via_object.full_graph_shortpath</span>
    <span class="n">n_original_comp</span><span class="p">,</span> <span class="n">n_original_comp_labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#G = via_object.full_graph_paths(via_object.data, n_original_comp)</span>
    <span class="c1">#knn_hnsw = _make_knn_embeddedspace(embedding)</span>
    <span class="n">y_root</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x_root</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">root1_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span><span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1">#row normalize</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">p1_sc_bp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">p1_sc_bp</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1">#make rowsums a column vector where i&#39;th entry is sum of i&#39;th row in p1-sc-bp</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Check sc pb </span><span class="si">{</span><span class="n">p1_sc_bp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>


    <span class="n">p1_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">p1_cc</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">connected_comp_labels</span>
    <span class="n">p1_sc_pt_markov</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">X_data</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">data</span>

    <span class="n">X_ds</span> <span class="o">=</span> <span class="n">X_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">p_ds</span> <span class="o">=</span> <span class="n">hnswlib</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">X_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">init_index</span><span class="p">(</span><span class="n">max_elements</span><span class="o">=</span><span class="n">X_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef_construction</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span><span class="n">X_ds</span><span class="p">)</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">set_ef</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">num_cluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">G_orange</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">num_cluster</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">edgelist_maxout</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="n">via_object</span><span class="o">.</span><span class="n">edgeweights_maxout</span><span class="p">})</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">root_cluster_list</span><span class="p">):</span>
        <span class="n">sankey_edges</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        loc_i = np.where(p1_labels == via_object.root[ii])[0]</span>
<span class="sd">        x = [embedding[xi, 0] for xi in loc_i]</span>
<span class="sd">        y = [embedding[yi, 1] for yi in loc_i]</span>

<span class="sd">        labels_root, distances_root = knn_hnsw.knn_query(np.array([np.mean(x), np.mean(y)]), k=1)</span>
<span class="sd">        x_root.append(embedding[labels_root, 0][0])</span>
<span class="sd">        y_root.append(embedding[labels_root, 1][0])</span>

<span class="sd">        labelsroot1, distances1 = via_object.knn_struct.knn_query(X_ds[labels_root[0][0], :], k=1)</span>
<span class="sd">        root1_list.append(labelsroot1[0][0])</span>
<span class="sd">        </span>
<span class="sd">        print(&#39;f getting majority comp&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        #VERY SLOW maybe try with dataframe mode  df.groupby([&#39;team&#39;])[&#39;points&#39;].agg(pd.Series.mode)</span>
<span class="sd">        for labels_i in via_object.labels:</span>
<span class="sd">            loc_labels = np.where(np.asarray(via_object.labels) == labels_i)[0]</span>
<span class="sd">            majority_composition = func_mode(list(np.asarray(via_object.true_label)[loc_labels]))</span>
<span class="sd">            majority_cluster_population_dict[labels_i] = majority_composition</span>
<span class="sd">        print(&#39;f End getting majority comp&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fst_i</span> <span class="ow">in</span> <span class="n">marker_lineages</span><span class="p">:</span>

            <span class="n">path_orange</span> <span class="o">=</span> <span class="n">G_orange</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">root_cluster_list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">to</span><span class="o">=</span><span class="n">fst_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            if fst_i in [1,22,71,89,136,10,83,115]: #CNS and periderm for Zebrahub Lange we want the root to be the early CNS</span>
<span class="sd">                #path_orange = G_orange.get_shortest_paths(52, to=fst_i)[0]</span>
<span class="sd">                #path_orange = G_orange.get_shortest_paths(via_object.root[ii], to=fst_i)[0]</span>
<span class="sd">                path_orange = G_orange.get_shortest_paths(3, to=fst_i)[0] #for Zebralange use this CNS root</span>
<span class="sd">            elif fst_i in [10,69,90,95]:</span>
<span class="sd">                path_orange = G_orange.get_shortest_paths(75, to=fst_i)[0]  # for Zebralange use this endoderm (pharynx, liver, intestine) root</span>
<span class="sd">            else:</span>
<span class="sd">                path_orange = G_orange.get_shortest_paths(via_object.root[ii], to=fst_i)[0]</span>
<span class="sd">            &#39;&#39;&#39;</span>
                <span class="c1">#path_orange = G_orange.get_shortest_paths(3, to=fst_i)[0]</span>
            <span class="c1">#if the roots is in the same component as the terminal cluster, then print the path to output</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_orange</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Cluster path on clustergraph starting from Root Cluster </span><span class="si">{</span><span class="n">root_cluster_list</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="si">}</span><span class="s1"> to Terminal Cluster </span><span class="si">{</span><span class="n">fst_i</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">path_orange</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">do_sankey</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                cluster_population_dict = {}</span>
<span class="sd">                for group_i in set(via_object.labels):</span>
<span class="sd">                    loc_i = np.where(via_object.labels == group_i)[0]</span>
<span class="sd">                    cluster_population_dict[group_i] = len(loc_i)</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="k">if</span> <span class="n">do_sankey</span><span class="p">:</span>


                    <span class="kn">import</span> <span class="nn">holoviews</span> <span class="k">as</span> <span class="nn">hv</span>
                    <span class="n">hv</span><span class="o">.</span><span class="n">extension</span><span class="p">(</span><span class="s1">&#39;bokeh&#39;</span><span class="p">)</span>
                    <span class="kn">from</span> <span class="nn">bokeh.plotting</span> <span class="kn">import</span> <span class="n">show</span>
                    <span class="kn">from</span> <span class="nn">holoviews</span> <span class="kn">import</span> <span class="n">opts</span><span class="p">,</span> <span class="n">dim</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Holoviews for TC </span><span class="si">{</span><span class="n">fst_i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">cluster_adjacency</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">cluster_adjacency</span>
                    <span class="c1"># row normalize</span>
                    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">cluster_adjacency</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">cluster_adjacency_rownormed</span> <span class="o">=</span> <span class="n">cluster_adjacency</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">n_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_orange</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">source</span> <span class="o">=</span> <span class="n">path_orange</span><span class="p">[</span><span class="n">n_i</span><span class="p">]</span>
                        <span class="n">dest</span> <span class="o">=</span><span class="n">path_orange</span><span class="p">[</span><span class="n">n_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">n_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_orange</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">do_log_flow</span><span class="p">:</span>

                                <span class="n">val_edge</span> <span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">cluster_adjacency_rownormed</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">]),</span><span class="mi">2</span><span class="p">)</span><span class="c1"># * cluster_population_dict[source] #  natural logarithm (base e) of 1 + x</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">val_edge</span> <span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">cluster_adjacency_rownormed</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
                                <span class="c1">#print(&quot;clipping val edge&quot;)</span>
                                <span class="c1">#if val_edge &gt; 0.5: val_edge = 0.5</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
                                <span class="n">ts_array_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span>
                                <span class="n">loc_ts_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ts_array_original</span> <span class="o">==</span> <span class="n">dest</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dest </span><span class="si">{</span><span class="n">dest</span><span class="si">}</span><span class="s1">, is at loc </span><span class="si">{</span><span class="n">loc_ts_current</span><span class="si">}</span><span class="s1"> on the bp_array&#39;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">do_log_flow</span><span class="p">:</span> <span class="n">val_edge</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">cluster_bp</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">loc_ts_current</span><span class="p">]),</span><span class="mi">2</span><span class="p">)</span><span class="c1">#* cluster_population_dict[source]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">val_edge</span> <span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">cluster_bp</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">loc_ts_current</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
                                    <span class="c1">#print(&quot;clipping val edge&quot;)</span>
                                    <span class="c1">#if val_edge &gt; 0.5: val_edge = 0.5</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">do_log_flow</span><span class="p">:</span>

                                    <span class="n">val_edge</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">cluster_adjacency_rownormed</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">]),</span>      <span class="mi">2</span><span class="p">)</span>  <span class="c1"># * cluster_population_dict[source] #  natural logarithm (base e) of 1 + x</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">val_edge</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">cluster_adjacency_rownormed</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
                                    <span class="c1">#print(&quot;clipping val edge&quot;)</span>
                                    <span class="c1">#val_edge = 0.5</span>
                        <span class="c1">#sankey_edges.append((majority_cluster_population_dict[source]+&#39;_C&#39;+str(source), majority_cluster_population_dict[dest]+&#39;_C&#39;+str(dest), val_edge))#, majority_cluster_population_dict[source],majority_cluster_population_dict[dest]))</span>
                        <span class="n">sankey_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">val_edge</span><span class="p">))</span><span class="c1">#,majority_cluster_population_dict[source]+&#39;_C&#39;+str(source),&#39;magenta&#39; ))</span>


        <span class="c1">#print(f&#39;pre-final sankey set of edges and vals {len(sankey_edges)}, {sankey_edges}&#39;)</span>
        <span class="n">source_dest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sankey_edges</span><span class="p">))</span>
        <span class="c1">#print(f&#39;final sankey set of edges and vals {len(source_dest)}, {source_dest}&#39;)</span>
        <span class="n">source_dest_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">source_dest</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">,</span> <span class="s1">&#39;Dest&#39;</span><span class="p">,</span> <span class="s1">&#39;Count&#39;</span><span class="p">])</span><span class="c1">#,&#39;Label&#39;,&#39;Color&#39;])</span>

        <span class="n">nodes_in_source_dest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">source_dest_df</span><span class="o">.</span><span class="n">Source</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">source_dest_df</span><span class="o">.</span><span class="n">Dest</span><span class="p">)))</span>
        <span class="n">nodes_in_source_dest</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">convert_old_to_new</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">convert_new_to_old</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">majority_newcluster_population_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes_in_source_dest</span><span class="p">):</span>
            <span class="n">convert_old_to_new</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">ei</span>
            <span class="n">convert_new_to_old</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span><span class="o">=</span><span class="n">ii</span>
            <span class="n">majority_newcluster_population_dict</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">majority_cluster_population_dict</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">source_dest_new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tuple_</span> <span class="ow">in</span> <span class="n">source_dest</span><span class="p">:</span>
            <span class="n">source_dest_new</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">convert_old_to_new</span><span class="p">[</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">convert_old_to_new</span><span class="p">[</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">tuple_</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="c1">#print(&#39;new source dest after reindexing&#39;, source_dest_new)</span>
        <span class="c1">#nodes = [majority_cluster_population_dict[i] for i in range(len(majority_cluster_population_dict))]</span>
        <span class="c1">#nodes = [majority_cluster_population_dict[i] for i in nodes_in_source_dest]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">majority_newcluster_population_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span><span class="s1">&#39;_C&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">convert_new_to_old</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">majority_newcluster_population_dict</span><span class="p">]</span>
        <span class="c1">#nodes = [&#39;C&#39; + str(convert_new_to_old[key]) for key in                 majority_newcluster_population_dict]</span>
        <span class="c1">#print(&#39;nodes&#39;, len(nodes), nodes,)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">holoviews.plotting.util</span> <span class="kn">import</span> <span class="n">process_cmap</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Start sankey&#39;</span><span class="p">)</span>
        <span class="n">cmap_list</span> <span class="o">=</span> <span class="n">process_cmap</span><span class="p">(</span><span class="s2">&quot;glasbey_hv&quot;</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">Sankey</span><span class="p">((</span><span class="n">source_dest_new</span><span class="p">,</span> <span class="n">nodes</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">,</span><span class="s2">&quot;Dest&quot;</span><span class="p">])</span>
        <span class="n">p2_2</span> <span class="o">=</span> <span class="n">hv</span><span class="o">.</span><span class="n">Sankey</span><span class="p">((</span><span class="n">source_dest_new</span><span class="p">,</span> <span class="n">nodes</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">,</span> <span class="s2">&quot;Dest&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">make sankey color dict&#39;</span><span class="p">)</span>
        <span class="c1">#Make color map</span>
        <span class="c1"># Extract Unique values dictionary values</span>
        <span class="c1"># Using set comprehension + values() + sorted()</span>
        <span class="n">set_majority_truth</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">majority_newcluster_population_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="n">set_majority_truth</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">set_majority_truth</span><span class="p">):</span>
                <span class="c1">#assign each celltype a number</span>
            <span class="n">color_dict</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="n">palette</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap_sankey</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">cmap_</span> <span class="o">=</span> <span class="n">palette</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">cmap_colors_dict_sankey</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">majority_newcluster_population_dict</span><span class="p">:</span>
            <span class="n">cmap_colors_dict_sankey</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">rgb2hex</span><span class="p">(</span><span class="n">cmap_</span><span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">majority_newcluster_population_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]]])</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">set options and render&#39;</span><span class="p">)</span>

        <span class="n">p2</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">Sankey</span><span class="p">(</span> <span class="n">show_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edge_cmap</span> <span class="o">=</span> <span class="n">cmap_colors_dict_sankey</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">node_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span>
                        <span class="n">edge_line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">1800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_colors_dict_sankey</span><span class="p">,</span>   <span class="n">node_padding</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span><span class="n">title</span><span class="o">=</span><span class="n">title_str</span><span class="p">))</span>
        <span class="n">show</span><span class="p">(</span><span class="n">hv</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span> 


        <span class="n">p2_2</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">Sankey</span><span class="p">(</span><span class="n">show_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edge_cmap</span><span class="o">=</span><span class="n">cmap_colors_dict_sankey</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span>
                        <span class="n">node_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span>
                        <span class="n">edge_line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">node_padding</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_colors_dict_sankey</span><span class="p">,</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title_str</span> <span class="p">))</span>
        <span class="c1">#show(hv.render(p2_2))</span>

        <span class="n">p2_2</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">Sankey</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">edge_cmap</span><span class="o">=</span><span class="n">cmap_colors_dict_sankey</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span>
                        <span class="n">node_color</span><span class="o">=</span><span class="n">dim</span><span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span>
                        <span class="n">edge_line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">node_padding</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_colors_dict_sankey</span><span class="p">,</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title_str</span> <span class="p">))</span>
        <span class="n">show</span><span class="p">(</span><span class="n">hv</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">p2_2</span><span class="p">))</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        p0 = hv.Sankey(source_dest_df)</span>
<span class="sd">        show(hv.render(p0))</span>

<span class="sd">        p = hv.Sankey(source_dest_df, kdims=[&quot;Source&quot;, &quot;Dest&quot;], vdims=[&quot;Count&quot;])</span>
<span class="sd">        p.opts(</span>
<span class="sd">            opts.Sankey(edge_color=dim(&#39;Source&#39;).str(), node_color=dim(&#39;Source&#39;).str(),</span>
<span class="sd">                        edge_line_width=2,</span>
<span class="sd">                        edge_cmap=&#39;tab20&#39;, node_cmap=&#39;tab20&#39;, width=1800, height=1800, title=&#39;test title&#39;, node_padding=3))</span>
<span class="sd">        show(hv.render(p))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#https://stackoverflow.com/questions/57085026/how-do-i-colour-the-individual-categories-in-a-holoviews-sankey-diagram</span>
        <span class="c1">#https://stackoverflow.com/questions/76505156/draw-sankey-diagram-with-holoviews-and-bokeh</span>
        <span class="c1">#https://holoviews.org/reference/elements/bokeh/Sankey.html</span>
        <span class="c1">#https://malouche.github.io/notebooks/Sankey_graphs.html</span>
        <span class="c1">#https://github.com/holoviz/holoviews/issues/3501</span>

    <span class="k">return</span></div>
<div class="viewcode-block" id="plot_sc_lineage_probability"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_sc_lineage_probability">[docs]</a><span class="k">def</span> <span class="nf">plot_sc_lineage_probability</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span>  <span class="n">embedding</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap_name</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">scatter_size</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">marker_lineages</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">fontsize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">alpha_factor</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span><span class="n">majority_cluster_population_dict</span><span class="p">:</span><span class="nb">dict</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap_sankey</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">do_sankey</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot single cell embedding labelled with lieage likelihood.</span>

<span class="sd">    G is the igraph knn (low K) used for shortest path in high dim space. no idx needed as it&#39;s made on full sample</span>
<span class="sd">    knn_hnsw is the knn made in the embedded space used for query to find the nearest point in the downsampled embedding</span>
<span class="sd">    that corresponds to the single cells in the full graph</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param embedding: n_samples x 2. embedding is either the full or downsampled 2D representation of the full dataset.</span>
<span class="sd">    :param idx: if one uses a downsampled embedding of the original data, then idx is the selected indices of the downsampled samples used in the visualization</span>
<span class="sd">    :param cmap_name:</span>
<span class="sd">    :param dpi:</span>
<span class="sd">    :param scatter_size: if None, then auto determined based on n_cells</span>
<span class="sd">    :param marker_lineages: Default is to use all lineage pathways. other provide a list of lineage number (terminal cluster number).</span>
<span class="sd">    :param alpha_factor: float transparency</span>
<span class="sd">    :return: fig, axs</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">marker_lineages</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>

    <span class="k">else</span><span class="p">:</span> <span class="n">marker_lineages</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">marker_lineages</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Marker_lineages: </span><span class="si">{</span><span class="n">marker_lineages</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">ERROR: please provide a single cell embedding or run re-via with do_compute_embedding==True using either embedding_type = via-umap OR via-mds&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Automatically setting embedding to via_object.embedding&#39;</span><span class="p">)</span>
            <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>

    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="c1">#G = via_object.full_graph_shortpath</span>
    <span class="n">n_original_comp</span><span class="p">,</span> <span class="n">n_original_comp_labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">full_graph_paths</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n_original_comp</span><span class="p">)</span>
    <span class="n">knn_hnsw</span> <span class="o">=</span> <span class="n">_make_knn_embeddedspace</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">y_root</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x_root</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">root1_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span><span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1">#row normalize</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">p1_sc_bp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">p1_sc_bp</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1">#make rowsums a column vector where i&#39;th entry is sum of i&#39;th row in p1-sc-bp</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Check sc pb </span><span class="si">{</span><span class="n">p1_sc_bp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>


    <span class="n">p1_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">p1_cc</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">connected_comp_labels</span>
    <span class="n">p1_sc_pt_markov</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">X_data</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">data</span>

    <span class="n">X_ds</span> <span class="o">=</span> <span class="n">X_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">p_ds</span> <span class="o">=</span> <span class="n">hnswlib</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">X_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">init_index</span><span class="p">(</span><span class="n">max_elements</span><span class="o">=</span><span class="n">X_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef_construction</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span><span class="n">X_ds</span><span class="p">)</span>
    <span class="n">p_ds</span><span class="o">.</span><span class="n">set_ef</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">num_cluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">G_orange</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">num_cluster</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">edgelist_maxout</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="n">via_object</span><span class="o">.</span><span class="n">edgeweights_maxout</span><span class="p">})</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">):</span>
        <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p1_labels</span> <span class="o">==</span> <span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">ii</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">embedding</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">embedding</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>

        <span class="n">labels_root</span><span class="p">,</span> <span class="n">distances_root</span> <span class="o">=</span> <span class="n">knn_hnsw</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)]),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">labels_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y_root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">labels_root</span><span class="p">,</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">labelsroot1</span><span class="p">,</span> <span class="n">distances1</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">X_ds</span><span class="p">[</span><span class="n">labels_root</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">root1_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelsroot1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sankey_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;f getting majority comp&#39;</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        #VERY SLOW maybe try with dataframe mode  df.groupby([&#39;team&#39;])[&#39;points&#39;].agg(pd.Series.mode)</span>
<span class="sd">        for labels_i in via_object.labels:</span>
<span class="sd">            loc_labels = np.where(np.asarray(via_object.labels) == labels_i)[0]</span>
<span class="sd">            majority_composition = func_mode(list(np.asarray(via_object.true_label)[loc_labels]))</span>
<span class="sd">            majority_cluster_population_dict[labels_i] = majority_composition</span>
<span class="sd">        print(&#39;f End getting majority comp&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fst_i</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
            <span class="n">path_orange</span> <span class="o">=</span> <span class="n">G_orange</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">to</span><span class="o">=</span><span class="n">fst_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_orange</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Cluster path on clustergraph starting from Root Cluster </span><span class="si">{</span><span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="si">}</span><span class="s1"> to Terminal Cluster </span><span class="si">{</span><span class="n">fst_i</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">path_orange</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="w">                </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                cluster_population_dict = {}</span>
<span class="sd">                for group_i in set(via_object.labels):</span>
<span class="sd">                    loc_i = np.where(via_object.labels == group_i)[0]</span>
<span class="sd">                    cluster_population_dict[group_i] = len(loc_i)</span>
<span class="sd">                &#39;&#39;&#39;</span>
    <span class="c1"># single-cell branch probability evolution probability</span>
    <span class="n">n_terminal_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span>
    <span class="n">fig_ncols</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_terminal_clusters</span><span class="p">)</span>
    <span class="n">fig_nrows</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_terminal_clusters</span><span class="p">,</span> <span class="n">fig_ncols</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fig_nrows</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">fig_nrows</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">fig_nrows</span><span class="o">=</span><span class="n">fig_nrows</span>
    <span class="k">if</span> <span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>        <span class="n">fig_nrows</span><span class="o">+=</span><span class="mi">1</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">,</span><span class="n">fig_ncols</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>

    <span class="n">ts_array_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span>

    <span class="n">ti</span> <span class="o">=</span> <span class="mi">0</span><span class="c1"># counter for terminal cluster</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">fig_ncols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ti</span> <span class="o">&lt;</span> <span class="n">n_terminal_clusters</span><span class="p">:</span>
                <span class="n">ts_current</span> <span class="o">=</span> <span class="n">marker_lineages</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
                <span class="n">loc_ts_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ts_array_original</span><span class="o">==</span><span class="n">ts_current</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">loc_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts_current</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">majority_composition</span> <span class="o">=</span> <span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">loc_labels</span><span class="p">]))</span>

                <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span><span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">p1_sc_bp</span><span class="p">[:,</span> <span class="n">loc_ts_current</span><span class="p">],</span> <span class="n">ti</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span> <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">p1_sc_bp</span><span class="p">[:,</span> <span class="n">loc_ts_current</span><span class="p">],</span> <span class="n">ti</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span> <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span> <span class="n">alpha_factor</span><span class="o">=</span><span class="n">alpha_factor</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">p1_sc_bp</span><span class="p">[:,</span> <span class="n">loc_ts_current</span><span class="p">],</span> <span class="n">ti</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span> <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span><span class="n">alpha_factor</span><span class="o">=</span><span class="n">alpha_factor</span><span class="p">)</span>

                <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p1_labels</span> <span class="o">==</span> <span class="n">ts_current</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">val_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1_sc_pt_markov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>
                <span class="n">th_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">val_pt</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># 50</span>
                <span class="n">loc_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_pt</span><span class="p">))</span> <span class="k">if</span> <span class="n">val_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_pt</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">embedding</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span>
                     <span class="n">loc_i</span><span class="p">]</span>  <span class="c1"># location of sc nearest to average location of terminal clus in the EMBEDDED space</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">embedding</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>
                <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">knn_hnsw</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)]),</span>
                                                       <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># knn_hnsw is knn of embedded space</span>
                <span class="n">x_sc</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># terminal sc location in the embedded space</span>
                <span class="n">y_sc</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>

                <span class="n">labelsq1</span><span class="p">,</span> <span class="n">distances1</span> <span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">X_ds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
                                                               <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># find the nearest neighbor in the PCA-space full graph</span>

                <span class="n">path</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">root1_list</span><span class="p">[</span><span class="n">p1_cc</span><span class="p">[</span><span class="n">loc_ts_current</span><span class="p">]],</span> <span class="n">to</span><span class="o">=</span><span class="n">labelsq1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># weights=&#39;weight&#39;)</span>
                <span class="c1"># G is the knn of all sc points</span>

                <span class="n">path_idx</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># find the single-cell which is nearest to the average-location of a terminal cluster</span>
                <span class="c1"># get the nearest-neighbor in this downsampled PCA-space graph. These will make the new path-way points</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># clusters of path</span>
                <span class="n">cluster_path</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">cell_</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                    <span class="n">cluster_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">cell_</span><span class="p">])</span>

                <span class="n">revised_cluster_path</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">revised_sc_path</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">enum_i</span><span class="p">,</span> <span class="n">clus</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_path</span><span class="p">):</span>
                    <span class="n">num_instances_clus</span> <span class="o">=</span> <span class="n">cluster_path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">clus</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">clus</span> <span class="o">==</span> <span class="n">cluster_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">clus</span> <span class="o">==</span> <span class="n">cluster_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">revised_cluster_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clus</span><span class="p">)</span>
                        <span class="n">revised_sc_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">enum_i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">num_instances_clus</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># typically intermediate stages spend a few transitions at the sc level within a cluster</span>
                            <span class="k">if</span> <span class="n">clus</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">revised_cluster_path</span><span class="p">:</span> <span class="n">revised_cluster_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clus</span><span class="p">)</span>  <span class="c1"># cluster</span>
                            <span class="n">revised_sc_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">enum_i</span><span class="p">])</span>  <span class="c1"># index of single cell</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Revised Cluster level path on sc-knnGraph from Root Cluster </span><span class="si">{</span><span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">p1_cc</span><span class="p">[</span><span class="n">ti</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="s2"> to Terminal Cluster </span><span class="si">{</span><span class="n">ts_current</span><span class="si">}</span><span class="s2"> along path: </span><span class="si">{</span><span class="n">revised_cluster_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fig_nrows</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">axs</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">axs</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>

<div class="viewcode-block" id="plot_viagraph"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_viagraph">[docs]</a><span class="k">def</span> <span class="nf">plot_viagraph</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">type_data</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">df_genes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gene_list</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">arrow_head</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                      <span class="n">edgeweight_scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_text</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size_factor_node</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Cluster level expression of gene/feature intensity</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param type_data:</span>
<span class="sd">    :param gene_exp: pd.Dataframe size n_cells x genes. Otherwise defaults to plotting pseudotime</span>
<span class="sd">    :param gene_list: list of gene names corresponding to the column name</span>
<span class="sd">    :param arrow_head:</span>
<span class="sd">    :param edgeweight_scale:</span>
<span class="sd">    :param cmap:</span>
<span class="sd">    :param label_text: bool to add numeric values of the gene exp level</span>
<span class="sd">    :param size_factor_node size of graph nodes</span>
<span class="sd">    :return: fig, axs</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    #draws the clustergraph for cluster level gene or pseudotime values</span>
<span class="sd">    # type_pt can be &#39;pt&#39; pseudotime or &#39;gene&#39; for gene expression</span>
<span class="sd">    # ax1 is the pseudotime graph</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="n">n_genes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_list</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">)</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">markov_hitting_times</span>
    <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;coolwarm&#39;</span> <span class="k">if</span> <span class="n">type_data</span> <span class="o">==</span> <span class="s1">&#39;gene&#39;</span> <span class="k">else</span> <span class="s1">&#39;viridis_r&#39;</span>

    <span class="n">node_pos</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span>


    <span class="n">node_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">node_pos</span><span class="p">)</span>

    <span class="n">df_genes</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
    <span class="n">df_genes</span> <span class="o">=</span> <span class="n">df_genes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>  <span class="c1"># node_pos.shape[0]</span>

    <span class="n">group_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">via_object</span><span class="o">.</span><span class="n">cluster_population_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">group_i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">group_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">group_pop</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>  <span class="c1"># np.sum(loc_i) / 1000 + 1</span>
        <span class="n">via_object</span><span class="o">.</span><span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_genes</span><span class="p">):</span>
        <span class="n">ax_i</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">gene_i</span> <span class="o">=</span> <span class="n">gene_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">c_edge</span><span class="p">,</span> <span class="n">l_width</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">pti</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
                <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">ax_i</span> <span class="o">=</span> <span class="n">plot_viagraph_</span><span class="p">(</span><span class="n">ax_i</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_cluster</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span><span class="p">,</span> <span class="n">CSM</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">CSM</span><span class="p">,</span>
                                <span class="n">velocity_weight</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">headwidth_bundle</span><span class="o">=</span><span class="n">arrow_head</span><span class="p">,</span> <span class="n">alpha_bundle</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">linewidth_bundle</span><span class="o">=</span><span class="n">edgeweight_scale</span><span class="p">)</span>
        <span class="n">group_pop_scale</span> <span class="o">=</span> <span class="mf">.5</span> <span class="o">*</span> <span class="n">group_pop</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">group_pop</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">ax_i</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">group_pop_scale</span><span class="o">*</span><span class="n">size_factor_node</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">df_genes</span><span class="p">[</span><span class="n">gene_i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                           <span class="n">edgecolors</span><span class="o">=</span><span class="n">c_edge</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">l_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label_text</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax_i</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">node_pos</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">df_genes</span><span class="p">[</span><span class="n">gene_i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                          <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax_i</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;10%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="n">cbar</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">gene_i</span><span class="p">)</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>
<div class="viewcode-block" id="plot_atlas_view"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_atlas_view">[docs]</a><span class="k">def</span> <span class="nf">plot_atlas_view</span><span class="p">(</span><span class="n">hammerbundle_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_bundle_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">linewidth_bundle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">facecolor</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">extra_title_text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">alpha_milestones</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="p">,</span><span class="n">headwidth_bundle</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">headwidth_alpha</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">arrow_frequency</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">show_arrow</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sc_labels_sequential</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sc_labels_expression</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_bandwidth</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">n_milestones</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_scatter_size_pop</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_milestones</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sc_labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">text_labels</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lineage_pathway</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">dpi</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">fontsize_title</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">fontsize_labels</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">global_visual_pruning</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">use_sc_labels_sequential_for_direction</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">sc_scatter_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">sc_scatter_alpha</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">add_sc_embedding</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">size_milestones</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">colorbar_legend</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draws atlas view. Integrated visualisation of edgebundle and single cell embedding.</span>

<span class="sd">    Edges can be colored by time-series numeric labels, pseudotime, lineage pathway probabilities,  or gene expression. If not specificed then time-series is chosen if available, otherwise falls back to pseudotime. to use gene expression the sc_labels_expression is provided as a list.</span>
<span class="sd">    To specify other numeric sequential data provide a list of sc_labels_sequential = [] n_samples in length. via_object.embedding must be an ndarray of shape (nsamples,2)</span>

<span class="sd">    :param hammer_bundle_dict: dictionary with keys: hammerbundle object with coordinates of all the edges to draw. If hammer_bundle and layout are None, then this will be computed internally</span>
<span class="sd">    :param via_object: type via object, if hammerbundle_dict is None, then you must provide a via_object. Ensure that via_object has embedding attribute</span>
<span class="sd">    :param layout: coords of cluster nodes and optionally also contains the numeric value associated with each cluster (such as time-stamp) layout[[&#39;x&#39;,&#39;y&#39;,&#39;numeric label&#39;]] sc/cluster/milestone level</span>
<span class="sd">    :param CSM: cosine similarity matrix. cosine similarity between the RNA velocity between neighbors and the change in gene expression between these neighbors. Only used when available</span>
<span class="sd">    :param velocity_weight: percentage weightage given to the RNA velocity based transition matrix</span>
<span class="sd">    :param pt: cluster-level pseudotime</span>
<span class="sd">    :param alpha_bundle: alpha when drawing lines</span>
<span class="sd">    :param linewidth_bundle: linewidth of bundled lines</span>
<span class="sd">    :param edge_color:</span>
<span class="sd">    :param alpha_milestones: float 0.3 alpha of milestones</span>
<span class="sd">    :param size_milestones: scatter size of the milestones (use sc_size_scatter to control single cell scatter when using in conjunction with lineage probs/ sc embeddings)</span>
<span class="sd">    :param arrow_frequency: min dist between arrows (bundled edges otherwise have overcrowding of arrows)</span>
<span class="sd">    :param show_direction: True will draw arrows along the lines to indicate direction</span>
<span class="sd">    :param milestone_edges: pandas DataFrame milestoone_edges[[&#39;source&#39;,&#39;target&#39;]]</span>
<span class="sd">    :param milestone_numeric_values: the milestone average of numeric values such as time (days, hours), location (position), or other numeric value used for coloring edges in a sequential manner</span>
<span class="sd">            if this is None then the edges are colored by length to distinguish short and long range edges</span>
<span class="sd">    :param arrow_frequency: 0.05. higher means fewer arrows</span>
<span class="sd">    :param n_milestones: int  None. if no hammerbundle_dict is provided, but via_object is provided, then the user can specify level of granularity by setting the n_milestones. otherwise it will be automatically selected</span>
<span class="sd">    :param scale_scatter_size_pop: bool default False</span>
<span class="sd">    :param sc_labels_expression: list single cell numeric values used for coloring edges and nodes of corresponding milestones mean expression levels (len n_single_cell samples)</span>
<span class="sd">            edges can be colored by time-series numeric labels, pseudotime, or gene expression. If not specificed then time-series is chosen if available, otherwise falls back to pseudotime. to use gene expression the sc_labels_expression is provided as a list</span>
<span class="sd">    :param sc_labels_sequential: list single cell numeric sequential values used for directionality inference as replacement for  pseudotime or via_object.time_series_labels (len n_samples single cell)</span>
<span class="sd">    :param sc_labels: list None list of single-cell level labels (categorial or discrete set of numerical values) to label the nodes</span>
<span class="sd">    :param text_labels: bool False if you want to label the nodes based on sc_labels (or true_label if via_object is provided)</span>
<span class="sd">    :param lineage_pathway: list of terminal states to plot lineage pathways</span>
<span class="sd">    :param use_sc_labels_sequential_for_direction: use the sequential data (timeseries labels or other provided by user) to direct the arrows</span>
<span class="sd">    :param lineage_alpha_threshold number representing the percentile (0-100) of lineage likelikhood in a particular lineage pathway, below which edges will be drawn with lower alpha transparency factor</span>
<span class="sd">    :param sc_scatter_alpha: transparency of the background singlecell scatter when plotting lineages</span>
<span class="sd">    :param add_sc_embedding: add background of single cell scatter plot for Atlas</span>
<span class="sd">    :param scatter_size_sc_embedding</span>
<span class="sd">    :param colorbar_legend str title of colorbar</span>
<span class="sd">    :return: fig, axis with bundled edges plotted</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">truncate_colormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">minval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
        <span class="n">new_cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span>
            <span class="s1">&#39;trunc(</span><span class="si">{n}</span><span class="s1">,</span><span class="si">{a:.2f}</span><span class="s1">,</span><span class="si">{b:.2f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">minval</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">maxval</span><span class="p">),</span>
            <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new_cmap</span>
    <span class="n">sc_scatter_alpha</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">sc_scatter_alpha</span>
    <span class="n">cmap_name</span> <span class="o">=</span> <span class="n">cmap</span>
    <span class="n">headwidth_alpha_og</span><span class="o">=</span> <span class="n">headwidth_alpha</span>
    <span class="n">linewidth_bundle_og</span> <span class="o">=</span> <span class="n">linewidth_bundle</span>
    <span class="n">alpha_bundle_factor_og</span> <span class="o">=</span><span class="n">alpha_bundle_factor</span>
    <span class="k">if</span> <span class="n">hammerbundle_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;if hammerbundle_dict is not provided, then you must provide via_object&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hammerbundle_dict</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_milestone_dict</span>
            <span class="k">if</span> <span class="n">hammerbundle_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_milestones</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">n_milestones</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sc_labels_sequential</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">sc_labels_sequential</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sc_labels_sequential</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Computing Edges&#39;</span><span class="p">)</span>
                <span class="n">hammerbundle_dict</span> <span class="o">=</span> <span class="n">make_edgebundle_milestone</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="n">via_object</span><span class="p">,</span>
                    <span class="n">embedding</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">sc_graph</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">ig_full_graph</span><span class="p">,</span> <span class="n">n_milestones</span><span class="o">=</span><span class="n">n_milestones</span><span class="p">,</span>
                    <span class="n">sc_labels_numeric</span><span class="o">=</span><span class="n">sc_labels_sequential</span><span class="p">,</span> <span class="n">initial_bandwidth</span><span class="o">=</span><span class="n">initial_bandwidth</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">global_visual_pruning</span><span class="o">=</span><span class="n">global_visual_pruning</span><span class="p">)</span>
                <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_dict</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span>
            <span class="n">hammer_bundle</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;hammerbundle&#39;</span><span class="p">]</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">milestone_edges</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sc_labels_expression</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sc_labels_expression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">set_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sc_labels_expression</span><span class="p">))</span>
                    <span class="n">set_labels</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">set_labels</span><span class="p">):</span>
                        <span class="n">color_dict</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                    <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_labels_expression</span><span class="p">]</span>
                    <span class="n">sc_labels_expression</span><span class="o">=</span><span class="n">milestone_numeric_values</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">sc_labels_expression</span>
            <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">use_sc_labels_sequential_for_direction</span><span class="p">:</span> <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span>
                <span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sc_labels_expression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if both sclabelexpression and sequential are provided, then sc_labels_expression takes precedence</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_expression&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_labels_expression</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

                <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_expression&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># used to color edges. direction is based on milestone_pt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">hammer_bundle</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;hammerbundle&#39;</span><span class="p">]</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">milestone_edges</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
        <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">sc_labels_expression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#if both sclabelexpression and sequential are provided, then sc_labels_expression takes precedence</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_expression&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_labels_expression</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sc_expression&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="c1">#used to color edges</span>

        <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">use_sc_labels_sequential_for_direction</span><span class="p">:</span> <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span><span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#fig, ax = plt.subplots(facecolor=facecolor)</span>
        <span class="n">fig_nrows</span><span class="p">,</span> <span class="n">fig_ncols</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lineage_pathway_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lineage_pathway</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">]</span> <span class="c1">#checking the clusters are actually in terminal_clusters</span>
        <span class="n">lineage_pathway</span><span class="o">=</span><span class="n">lineage_pathway_temp</span>
        <span class="n">n_terminal_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span>
        <span class="n">fig_ncols</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_terminal_clusters</span><span class="p">)</span>
        <span class="n">fig_nrows</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_terminal_clusters</span><span class="p">,</span> <span class="n">fig_ncols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fig_nrows</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">fig_nrows</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">fig_nrows</span><span class="o">=</span><span class="n">fig_nrows</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">fig_nrows</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">,</span><span class="n">fig_ncols</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="n">counter_</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_real_subplots</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">majority_composition</span> <span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fig_ncols</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">counter_</span> <span class="o">&lt;</span> <span class="n">n_real_subplots</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span>
                        <span class="s1">&#39;sc_lineage_probability_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">[</span><span class="n">counter_</span><span class="p">])]</span>
                    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="c1">#single cell lineage probabilities sc pb</span>
                    <span class="c1"># row normalize</span>
                    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">p1_sc_bp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">p1_sc_bp</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># make rowsums a column vector where i&#39;th entry is sum of i&#39;th row in p1-sc-bp</span>
                    <span class="n">ts_cluster_number</span> <span class="o">=</span> <span class="n">lineage_pathway</span><span class="p">[</span><span class="n">counter_</span><span class="p">]</span>
                    <span class="n">ts_array_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span>
                    <span class="n">loc_ts_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ts_array_original</span> <span class="o">==</span> <span class="n">ts_cluster_number</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;location of </span><span class="si">{</span><span class="n">lineage_pathway</span><span class="p">[</span><span class="n">counter_</span><span class="p">]</span><span class="si">}</span><span class="s1"> is at </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ts_array_original</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ts_cluster_number</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">loc_ts_current</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">p1_sc_bp</span> <span class="o">=</span> <span class="n">p1_sc_bp</span><span class="p">[:,</span> <span class="n">loc_ts_current</span><span class="p">]</span>

                    <span class="c1">#print(f&#39;{datetime.now()}\tCheck sc pb {p1_sc_bp[0, :].sum()} &#39;)</span>
                    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ts_current</span> <span class="o">=</span> <span class="n">lineage_pathway</span><span class="p">[</span><span class="n">counter_</span><span class="p">]</span>
                        <span class="n">loc_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts_current</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">majority_composition</span> <span class="o">=</span> <span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">loc_labels</span><span class="p">]))</span>
                <span class="n">x_</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
                <span class="n">y_</span> <span class="o">=</span>  <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
                <span class="c1">#min_x, max_x = min(x_), max(x_)</span>
                <span class="c1">#min_y, max_y = min(y_), max(y_)</span>
                <span class="n">delta_x</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
                <span class="n">delta_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>

                <span class="n">layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
                <span class="c1"># get each segment. these are separated by nans.</span>
                <span class="n">hbnp</span> <span class="o">=</span> <span class="n">hammer_bundle</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hbnp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#location of each nan values</span>
                <span class="n">edgelist_segments</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">arrow_coords</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">seg_len</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#length of a segment</span>
                <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">hbnp</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                    <span class="n">seg_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>

                <span class="n">min_seg_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
                <span class="n">max_seg_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
                <span class="n">seg_len</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
                <span class="n">seg_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                                  <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span><span class="mi">90</span><span class="p">))</span>
                <span class="c1">#mean_seg_length = sum(seg_len)/len(seg_len)</span>

                <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># every step&#39;th segment is plotted</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">max_numerical_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span>
                    <span class="n">min_numerical_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span>
             <span class="c1">##inserting edits here</span>

                <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
                <span class="n">sc_embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>
                <span class="n">max_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">max_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">max_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">max_dw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">add_sc_embedding</span><span class="p">:</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside add sc embedding second if&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sc_labels_expression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">gene_expression</span><span class="o">=</span><span class="kc">False</span>
                            <span class="k">if</span> <span class="n">gene_expression</span><span class="p">:</span>
                                <span class="n">val_alph</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mf">0.3</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_labels_expression</span><span class="p">]</span>
                                <span class="n">max_alph</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val_alph</span><span class="p">)</span>
                                <span class="n">val_alph</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="n">max_alph</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val_alph</span><span class="p">]</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">val_alph</span><span class="p">,</span>
                                       <span class="n">c</span><span class="o">=</span><span class="n">sc_labels_expression</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sc_scatter_size</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                       <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># alpha=1 change back to</span>
                            <span class="c1">#ax.scatter(via_object.embedding[:, 0], via_object.embedding[:, 1], alpha=0.1,                                       c=&#39;lightgray&#39;, s=5)</span>
                            <span class="c1">#new_cmap= truncate_colormap(cmap, 0.25, 1.0) #use this for gene expression plotting in zebrahub non-neuro ecto</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">sc_labels_expression</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sc_scatter_size</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#alpha=1 change back to</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">max_l</span><span class="p">,</span> <span class="n">max_dw</span><span class="p">),</span> <span class="n">max_r</span> <span class="o">-</span> <span class="n">max_l</span><span class="p">,</span> <span class="n">max_up</span> <span class="o">-</span> <span class="n">max_dw</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">sc_scatter_alpha</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">p1_sc_bp</span><span class="p">,</span>
                                       <span class="n">ti</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                       <span class="n">scatter_size</span><span class="o">=</span><span class="n">sc_scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                                <span class="n">Rectangle</span><span class="p">((</span><span class="n">max_l</span><span class="p">,</span> <span class="n">max_dw</span><span class="p">),</span> <span class="n">max_r</span> <span class="o">-</span> <span class="n">max_l</span><span class="p">,</span> <span class="n">max_up</span> <span class="o">-</span> <span class="n">max_dw</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">sc_scatter_alpha</span><span class="p">))</span>
                            <span class="c1">#ax.scatter(via_object.embedding[:, 0], via_object.embedding[:, 1], alpha=0.05, c=&#39;white&#39;,                                             s=5)</span>

                        <span class="k">else</span><span class="p">:</span>

                            <span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="n">sc_embedding</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">p1_sc_bp</span><span class="p">,</span>
                                   <span class="n">ti</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                   <span class="n">scatter_size</span><span class="o">=</span><span class="n">sc_scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                                <span class="n">Rectangle</span><span class="p">((</span><span class="n">max_l</span><span class="p">,</span> <span class="n">max_dw</span><span class="p">),</span> <span class="n">max_r</span> <span class="o">-</span> <span class="n">max_l</span><span class="p">,</span> <span class="n">max_up</span> <span class="o">-</span> <span class="n">max_dw</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">sc_scatter_alpha</span><span class="p">))</span>
                            <span class="c1">#ax[c].scatter(via_object.embedding[:, 0], via_object.embedding[:, 1], alpha=0.1, c=&#39;white&#39;, s=4)</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">plot_sc_pb</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">fig</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="n">sc_embedding</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">p1_sc_bp</span><span class="p">,</span>
                                   <span class="n">ti</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ts_current</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">),</span> <span class="n">cmap_name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                   <span class="n">scatter_size</span><span class="o">=</span><span class="n">sc_scatter_size</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                        <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">max_l</span><span class="p">,</span> <span class="n">max_dw</span><span class="p">),</span> <span class="n">max_r</span><span class="o">-</span><span class="n">max_l</span><span class="p">,</span> <span class="n">max_up</span><span class="o">-</span><span class="n">max_dw</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">sc_scatter_alpha</span><span class="p">))</span> <span class="c1">#0.7</span>
                        <span class="c1">#ax[r, c].scatter(layout[:, 0], layout[:, 1], s=40,                                         c=&#39;white&#39;, cmap=cmap_name,                                         alpha=0.5, edgecolors=&#39;none&#39;)  # vmax=1)</span>
                        <span class="c1">#ax[r, c].scatter(via_object.embedding[:, 0], via_object.embedding[:, 1], alpha=0.1, c=&#39;white&#39;, s=4,edgecolors=&#39;none&#39;)</span>


                <span class="c1">#end white edits</span>
                <span class="n">seg_count</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[::</span><span class="n">step</span><span class="p">]:</span>
                    <span class="n">do_arrow</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1">#seg_weight = max(0.3, math.log(1+seg[-1,2])) seg[-1,2] column index 2 has the weight information</span>

                    <span class="n">seg_weight</span><span class="o">=</span><span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">seg_len</span><span class="p">[</span><span class="n">seg_count</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">max_seg_length</span><span class="o">-</span><span class="n">min_seg_length</span><span class="p">)</span><span class="c1">##seg.shape[0] / (max_seg_length - min_seg_length)#seg.shape[0]</span>

                    <span class="c1">#cant&#39; quite decide yet if sigmoid is desirable</span>
                    <span class="c1">#seg_weight=sigmoid_scalar(seg.shape[0] / (max_seg_length - min_seg_length), scale=5, shift=mean_seg_length / (max_seg_length - min_seg_length))</span>
                    <span class="n">alpha_bundle</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="n">seg_weight</span><span class="o">*</span><span class="n">alpha_bundle_factor</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span><span class="c1"># max(0.1, math.log(1 + seg[-1, 2]))</span>

                    <span class="k">if</span> <span class="n">alpha_bundle</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="n">alpha_bundle</span><span class="o">=</span><span class="mi">1</span>

                    <span class="n">source_milestone</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">seg_count</span><span class="p">]</span>
                    <span class="n">target_milestone</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">seg_count</span><span class="p">]</span>

                    <span class="n">direction</span> <span class="o">=</span> <span class="n">milestone_pt</span><span class="p">[</span><span class="n">target_milestone</span><span class="p">]</span> <span class="o">-</span> <span class="n">milestone_pt</span><span class="p">[</span><span class="n">source_milestone</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">source_milestone_numerical_value</span> <span class="o">=</span> <span class="n">milestone_numeric_values</span><span class="p">[</span><span class="n">source_milestone</span><span class="p">]</span>

                    <span class="n">target_milestone_numerical_value</span> <span class="o">=</span> <span class="n">milestone_numeric_values</span><span class="p">[</span><span class="n">target_milestone</span><span class="p">]</span>
                    <span class="c1">#print(&#39;source milestone&#39;, source_milestone_numerical_value)</span>
                    <span class="c1">#print(&#39;target milestone&#39;, target_milestone_numerical_value)</span>
                    <span class="n">min_source_target_numerical_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">source_milestone_numerical_value</span><span class="p">,</span><span class="n">target_milestone_numerical_value</span><span class="p">)</span> <span class="c1">#ORIGINALLY USING MIN()</span>
                    <span class="c1">#min_source_target_numerical_value =(source_milestone_numerical_value+       target_milestone_numerical_value)/2</span>
                    <span class="n">max_source_target_numerical_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">source_milestone_numerical_value</span><span class="p">,</span>                                                            <span class="n">target_milestone_numerical_value</span><span class="p">)</span>
                    <span class="c1"># consider using the max value for lineage pathways to better highlight the high probabilties near the cell fate</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#print(&#39;change remove this back to &gt;0 in plotting_via.py and gray segment zorder =2&#39;)</span>

                        <span class="c1">#rgba = cmap((min_source_target_numerical_value - min_numerical_value) / (max_numerical_value - min_numerical_value))</span>

                        <span class="k">if</span> <span class="n">min_source_target_numerical_value</span> <span class="o">&lt;=</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">):</span><span class="c1"># 0.1:#np.percentile(milestone_numeric_values,lineage_alpha_threshold):</span>
                            <span class="n">alpha_bundle</span><span class="o">=</span><span class="mf">0.01</span> <span class="c1">#0.1#0.01</span>
                            <span class="n">headwidth_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="c1">#0.2</span>
                            <span class="n">linewidth_bundle</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">linewidth_bundle_og</span>
                        <span class="k">elif</span> <span class="p">((</span><span class="n">min_source_target_numerical_value</span> <span class="o">&gt;</span><span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">min_source_target_numerical_value</span> <span class="o">&lt;</span><span class="mf">0.7</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">))):</span><span class="c1"># 0.1:#np.percentile(milestone_numeric_values,lineage_alpha_threshold):</span>

                            <span class="n">alpha_bundle</span><span class="o">=</span><span class="mf">0.05</span><span class="c1">#0.2#max(min_source_target_numerical_value/np.max(milestone_numeric_values) *alpha_bundle,0.01)</span>
                            <span class="n">headwidth_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="c1">#0.2</span>
                            <span class="n">linewidth_bundle</span> <span class="o">=</span><span class="n">min_source_target_numerical_value</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span><span class="o">*</span><span class="n">linewidth_bundle_og</span>
                        <span class="k">else</span><span class="p">:</span>

                            <span class="n">headwidth_alpha</span><span class="o">=</span><span class="n">headwidth_alpha_og</span>
                            <span class="n">linewidth_bundle</span> <span class="o">=</span>  <span class="n">linewidth_bundle_og</span><span class="o">*</span><span class="mf">1.4</span>
                    <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">((</span><span class="n">min_source_target_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">))</span>
                    <span class="c1">#rgba = new_cmap((min_source_target_numerical_value - min_numerical_value) / (                                max_numerical_value - min_numerical_value)) #use for non-neuro-ecto zebrahub gene expression</span>

                    <span class="c1">#else: rgba = cmap(min(seg_weight,0.95))#cmap(seg.shape[0]/(max_seg_length-min_seg_length))</span>
                    <span class="c1">#if seg_weight&gt;0.05: seg_weight=0.1</span>
                    <span class="c1">#if seg_count%10000==0: print(&#39;seg weight&#39;, seg_weight)</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">seg_p</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                            <span class="c1">#ax.plot(seg_p[:, 0], seg_p[:, 1], linewidth=0.2,                                    alpha=0.1, color=&#39;gray&#39;)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span><span class="o">*</span><span class="n">seg_weight</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">)</span><span class="c1">#, zorder=2)#edge_color )</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span><span class="o">*</span><span class="n">seg_weight</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">)</span><span class="c1">#edge_color )</span>
                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span> <span class="o">*</span> <span class="n">seg_weight</span><span class="p">,</span>
                                      <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">)</span>  <span class="c1"># edge_color )</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">show_arrow</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">mid_point</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">seg_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrow_coords</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#dont draw arrows in overlapping segments</span>
                            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">arrow_coords</span><span class="p">:</span>
                                <span class="n">dist_</span> <span class="o">=</span> <span class="n">dist_points</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="o">=</span><span class="p">[</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

                                <span class="k">if</span> <span class="n">dist_</span><span class="o">&lt;</span> <span class="n">arrow_frequency</span><span class="o">*</span><span class="n">delta_x</span><span class="p">:</span> <span class="n">do_arrow</span><span class="o">=</span><span class="kc">False</span>
                                <span class="k">if</span> <span class="n">dist_</span><span class="o">&lt;</span> <span class="n">arrow_frequency</span><span class="o">*</span><span class="n">delta_y</span><span class="p">:</span> <span class="n">do_arrow</span><span class="o">=</span><span class="kc">False</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">do_arrow</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="n">headwidth_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="n">headwidth_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

                                <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="n">headwidth_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="n">headwidth_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

                            <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="n">headwidth_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="n">headwidth_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                            <span class="n">arrow_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>


                    <span class="n">seg_count</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">show_milestones</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">size_milestones</span> <span class="o">=</span> <span class="mf">0.01</span>
                    <span class="n">show_milestones</span><span class="o">=</span><span class="kc">True</span>
                    <span class="n">scale_scatter_size_pop</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">show_milestones</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">milestone_numeric_values_normed</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">milestone_numeric_values_rgba</span><span class="o">=</span><span class="p">[]</span>
                    <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">):</span>

                        <span class="c1">#if you have numeric values (days, hours) that need to be scaled to 0-1 so they can be used in cmap()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#these are probabilities and we dont want to normalize the lineage likelihooods</span>

                            <span class="n">rgba_</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">color_numeric</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>

                            <span class="n">rgba_</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">))</span>
                            <span class="n">color_numeric</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span>
                        <span class="n">milestone_numeric_values_normed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color_numeric</span><span class="p">)</span>
                        <span class="n">milestone_numeric_values_rgba</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgba_</span><span class="p">)</span> <span class="c1"># need a list of rgb when also plotting labels as plot colors are done one-by-one</span>
                    <span class="k">if</span> <span class="n">scale_scatter_size_pop</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>

                        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">sqrt_nsamples</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
                        <span class="n">group_pop_scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">6</span><span class="o">+</span><span class="n">i</span> <span class="o">/</span><span class="n">sqrt_nsamples</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                           <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;cluster population&#39;</span><span class="p">]]</span>
                        <span class="n">size_scatter_scaled</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_milestones</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group_pop_scale</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">size_scatter_scaled</span> <span class="o">=</span> <span class="n">size_milestones</span> <span class="c1"># constant value</span>
                    <span class="c1">#NOTE # using vmax=1 in the scatter plot would mean that all values are plotted relative to a 0-1 scale and the legend for all plots is 0-1.</span>
                    <span class="c1"># If we want to allow that each legend is unique then there is autoscaling of the colors such that the max color is set to the max value of that particular subplot (even if that max value is well below 1)</span>
                    <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                            <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                       <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                       <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span> <span class="c1">#without alpha parameter which otherwise gets passed onto the colorbar</span>

                            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span> <span class="n">cmap_name</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>     <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>                                       <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                            <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span> <span class="c1">#without alpha parameter which otherwise gets passed onto the colorbar</span>

                            <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span> <span class="n">cmap_name</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
<span class="w">                        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                       </span>
<span class="sd">                        ax[r, c].scatter(layout[:, 0], layout[:, 1], s=size_scatter_scaled*3,</span>
<span class="sd">                                         c=milestone_numeric_values_normed, cmap=cmap_name,</span>
<span class="sd">                                         alpha=alpha_milestones*0.5, edgecolors=&#39;none&#39;, vmin=min_numerical_value)  # vmax=1)</span>
<span class="sd">                        </span>
<span class="sd">                        </span>
<span class="sd">                        &#39;&#39;&#39;</span>
                        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                              <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">min_numerical_value</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span>
                                        <span class="n">c</span><span class="o">=</span><span class="n">milestone_numeric_values_normed</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">min_numerical_value</span><span class="p">)</span>  <span class="c1"># vmax=1)</span>


<span class="w">                        </span><span class="sd">&#39;&#39;&#39;&#39;</span>
<span class="sd">                        if len(lineage_pathway)&gt;0:</span>
<span class="sd">                            #accentuate the scatter size for nodes significant to a lineage</span>
<span class="sd">                            for j in range(layout.shape[0]):</span>
<span class="sd">                                if milestone_numeric_values_normed[j] &gt; 0.5*max_numerical_value:</span>
<span class="sd">                                    if scale_scatter_size_pop:</span>
<span class="sd">                                        ax[r, c].scatter(layout[j, 0], layout[j, 1], s=size_scatter_scaled[j] * 1.5,</span>
<span class="sd">                                             c=milestone_numeric_values_normed[j], cmap=cmap_name,</span>
<span class="sd">                                             alpha=alpha_milestones * 1.5, edgecolors=&#39;None&#39;,</span>
<span class="sd">                                             vmin=min_numerical_value)  # vmax=1)</span>
<span class="sd">                                    else:</span>
<span class="sd">                                        print(f&#39;node {j} {milestone_numeric_values_normed[j]}&#39;)</span>
<span class="sd">                                        ax[r, c].scatter(layout[j, 0], layout[j, 1], s=size_scatter_scaled*1.5,</span>
<span class="sd">                                                     c=milestone_numeric_values_normed[j], cmap=cmap_name,</span>
<span class="sd">                                                     alpha=alpha_milestones*1.5, edgecolors=&#39;None&#39;,</span>
<span class="sd">                                                     vmin=min_numerical_value)  # vmax=1)</span>
<span class="sd">                        &#39;&#39;&#39;</span>
                    <span class="k">if</span> <span class="n">text_labels</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>

                        <span class="c1">#if text labels is true but user has not provided any labels at the sc level from which to create milestone categorical labels</span>
                        <span class="k">if</span> <span class="n">sc_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">sc_labels</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>
                            <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1"> ERROR: in order to show labels, please provide list of sc_labels at the single cell level OR via_object&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="n">sc_milestone_labels</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;sc_milestone_labels&#39;</span><span class="p">]</span>
                            <span class="n">loc_milestone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_milestone_labels</span><span class="p">)</span><span class="o">==</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                            <span class="n">mode_label</span> <span class="o">=</span> <span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_labels</span><span class="p">)[</span><span class="n">loc_milestone</span><span class="p">]))</span>
                            <span class="k">if</span> <span class="n">scale_scatter_size_pop</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter_scaled</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">milestone_numeric_values_rgba</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_milestones</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mode_label</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mode_label</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_labels</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span><span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mode_label</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_labels</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mode_label</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_labels</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">title_</span> <span class="o">=</span> <span class="n">extra_title_text</span> <span class="o">+</span> <span class="s1">&#39; n_milestones = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#+ &#39; time: &#39; + time</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">title_</span> <span class="o">=</span> <span class="s1">&#39;lineage:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">[</span><span class="n">counter_</span><span class="p">])</span> <span class="o">+</span><span class="s1">&#39;-&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_composition</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">fig_nrows</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolor</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">title_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>
                        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lineage likelihood&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span><span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">)</span>
                        <span class="n">ax_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="n">ax</span>
                        <span class="n">text</span> <span class="o">=</span> <span class="n">ax_cb</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span>
                        <span class="n">font</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>  <span class="c1"># family=&#39;times new roman&#39;, style=&#39;italic&#39;,</span>
                        <span class="n">text</span><span class="o">.</span><span class="n">set_font_properties</span><span class="p">(</span><span class="n">font</span><span class="p">)</span>
                        <span class="n">ax_cb</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fontsize_title</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">))</span>
                        <span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolor</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">title_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>


                        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
                        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">))</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">colorbar_legend</span> <span class="o">=</span> <span class="s1">&#39;lineage likelihood&#39;</span>
                            <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">colorbar_legend</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">colorbar_legend</span><span class="p">)</span>

                        <span class="n">ax_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="n">ax</span>
                        <span class="n">text</span> <span class="o">=</span> <span class="n">ax_cb</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span>
                        <span class="n">font</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>  <span class="c1"># family=&#39;times new roman&#39;, style=&#39;italic&#39;,</span>
                        <span class="n">text</span><span class="o">.</span><span class="n">set_font_properties</span><span class="p">(</span><span class="n">font</span><span class="p">)</span>
                        <span class="n">ax_cb</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fontsize_title</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">))</span>
                        <span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolor</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">title_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>

                    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
                    <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineage_pathway</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lineage likelihood&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">)</span>

                    <span class="n">ax_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="n">ax</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">ax_cb</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span>
                    <span class="n">font</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span>
                        <span class="n">size</span><span class="o">=</span><span class="n">fontsize_title</span><span class="p">)</span>  <span class="c1"># family=&#39;times new roman&#39;, style=&#39;italic&#39;,</span>
                    <span class="n">text</span><span class="o">.</span><span class="n">set_font_properties</span><span class="p">(</span><span class="n">font</span><span class="p">)</span>
                    <span class="n">ax_cb</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fontsize_title</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">))</span>
                    <span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">counter_</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fig_nrows</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fig_ncols</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="animate_atlas"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.animate_atlas">[docs]</a><span class="k">def</span> <span class="nf">animate_atlas</span><span class="p">(</span><span class="n">hammerbundle_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidth_bundle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frame_interval</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n_milestones</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">facecolor</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;plasma_r&#39;</span><span class="p">,</span> <span class="n">extra_title_text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">size_scatter</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha_scatter</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;/home/user/Trajectory/Datasets/animation_default.gif&#39;</span><span class="p">,</span> <span class="n">time_series_labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc_labels_numeric</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot animated atlas view visualising the growth of edgebudle and single cell embedding based on given time_series_labels.</span>

<span class="sd">    :param ax: axis to plot on</span>
<span class="sd">    :param hammer_bundle: hammerbundle object with coordinates of all the edges to draw</span>
<span class="sd">    :param layout: coords of cluster nodes and optionally also contains the numeric value associated with each cluster (such as time-stamp) layout[[&#39;x&#39;,&#39;y&#39;,&#39;numeric label&#39;]] sc/cluster/milestone level</span>
<span class="sd">    :param CSM: cosine similarity matrix. cosine similarity between the RNA velocity between neighbors and the change in gene expression between these neighbors. Only used when available</span>
<span class="sd">    :param velocity_weight: percentage weightage given to the RNA velocity based transition matrix</span>
<span class="sd">    :param time_series_labels: if not given, by default it will be set to pseudotime</span>
<span class="sd">    :param alpha_bundle: alpha when drawing lines</span>
<span class="sd">    :param linewidth_bundle: linewidth of bundled lines</span>
<span class="sd">    :param edge_color:</span>
<span class="sd">    :param frame_interval: smaller number, faster refresh and video</span>
<span class="sd">    :param facecolor: default = white</span>
<span class="sd">    :param headwidth_bundle: headwidth of arrows used in bundled edges</span>
<span class="sd">    :param arrow_frequency: min dist between arrows (bundled edges otherwise have overcrowding of arrows)</span>
<span class="sd">    :param show_direction: True will draw arrows along the lines to indicate direction</span>
<span class="sd">    :param milestone_edges: pandas DataFrame milestone_edges[[&#39;source&#39;,&#39;target&#39;]]</span>
<span class="sd">    :return: axis with bundled edges plotted</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">tqdm</span>

    <span class="k">if</span> <span class="n">hammerbundle_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">ERROR: Hammerbundle_dict needs to be provided either through via_object or by running make_edgebundle_milestone()&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hammerbundle_dict</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_milestone_dict</span>
            <span class="k">if</span> <span class="n">hammerbundle_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_milestones</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">n_milestones</span> <span class="o">=</span>  <span class="nb">min</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sc_labels_numeric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">sc_labels_numeric</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sc_labels_numeric</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>

                <span class="n">hammerbundle_dict</span> <span class="o">=</span> <span class="n">make_edgebundle_milestone</span><span class="p">(</span><span class="n">via_object</span><span class="o">=</span><span class="n">via_object</span><span class="p">,</span>
                    <span class="n">embedding</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">sc_graph</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">ig_full_graph</span><span class="p">,</span> <span class="n">n_milestones</span><span class="o">=</span><span class="n">n_milestones</span><span class="p">,</span>
                    <span class="n">sc_labels_numeric</span><span class="o">=</span><span class="n">sc_labels_numeric</span><span class="p">,</span> <span class="n">initial_bandwidth</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hammer_bundle</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;hammerbundle&#39;</span><span class="p">]</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">milestone_edges</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
            <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>
            <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="c1">#used when plotting arrows</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">hammer_bundle</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;hammerbundle&#39;</span><span class="p">]</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">milestone_edges</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
        <span class="n">milestone_numeric_values</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;numeric label&#39;</span><span class="p">]</span>
        <span class="n">milestone_pt</span> <span class="o">=</span> <span class="n">hammerbundle_dict</span><span class="p">[</span><span class="s1">&#39;milestone_embedding&#39;</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>  <span class="c1"># used when plotting arrows</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="n">facecolor</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">time_thresh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span>
    <span class="c1">#ax.set_facecolor(facecolor)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">x_</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
    <span class="n">y_</span> <span class="o">=</span>  <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
    <span class="c1">#min_x, max_x = min(x_), max(x_)</span>
    <span class="c1">#min_y, max_y = min(y_), max(y_)</span>
    <span class="n">delta_x</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>

    <span class="n">delta_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>

    <span class="n">layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
    <span class="c1"># make a knn so we can find which clustergraph nodes the segments start and end at</span>


    <span class="c1"># get each segment. these are separated by nans.</span>
    <span class="n">hbnp</span> <span class="o">=</span> <span class="n">hammer_bundle</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hbnp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#location of each nan values</span>
    <span class="n">edgelist_segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arrow_coords</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">seg_len</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#length of a segment</span>
    <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">hbnp</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="n">seg_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>

    <span class="n">min_seg_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
    <span class="n">max_seg_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
    <span class="c1">#mean_seg_length = sum(seg_len)/len(seg_len)</span>
    <span class="n">seg_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
    <span class="n">seg_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                      <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">seg_len</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># every step&#39;th segment is plotted</span>


    <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_numerical_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span>
        <span class="n">min_numerical_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span>

    <span class="n">seg_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#print(&#39;numeric vals&#39;, milestone_numeric_values)</span>
    <span class="n">loc_time_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">time_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1">#print(&#39;loc time thres&#39;, loc_time_thresh)</span>
    <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source_thresh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">loc_time_thresh</span><span class="p">)</span><span class="c1">#apply(lambda x: any([k in x for k in loc_time_thresh]))</span>

    <span class="c1">#print(milestone_edges[0:10])</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source_thresh&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1">#print(&#39;loc time thres&#39;, time_thresh, loc_time_thresh)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">source_milestone</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">target_milestone</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1">#seg_weight = max(0.3, math.log(1+seg[-1,2])) seg[-1,2] column index 2 has the weight information</span>

        <span class="n">seg_weight</span><span class="o">=</span><span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">seg_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">max_seg_length</span><span class="o">-</span><span class="n">min_seg_length</span><span class="p">)</span><span class="c1">##seg.shape[0] / (max_seg_length - min_seg_length)</span>

        <span class="c1">#cant&#39; quite decide yet if sigmoid is desirable</span>
        <span class="c1">#seg_weight=sigmoid_scalar(seg.shape[0] / (max_seg_length - min_seg_length), scale=5, shift=mean_seg_length / (max_seg_length - min_seg_length))</span>
        <span class="n">alpha_bundle</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="n">seg_weight</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span><span class="c1"># max(0.1, math.log(1 + seg[-1, 2]))</span>
        <span class="k">if</span> <span class="n">alpha_bundle</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="n">alpha_bundle</span><span class="o">=</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_milestone_numerical_value</span> <span class="o">=</span> <span class="n">milestone_numeric_values</span><span class="p">[</span><span class="n">source_milestone</span><span class="p">]</span>
            <span class="n">target_milestone_numerical_value</span> <span class="o">=</span> <span class="n">milestone_numeric_values</span><span class="p">[</span><span class="n">target_milestone</span><span class="p">]</span>
            <span class="c1">#print(&#39;source milestone&#39;, source_milestone_numerical_value)</span>
            <span class="c1">#print(&#39;target milestone&#39;, target_milestone_numerical_value)</span>
            <span class="n">rgba_milestone_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">source_milestone_numerical_value</span><span class="p">,</span> <span class="n">target_milestone_numerical_value</span><span class="p">)</span>
            <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span> <span class="p">(</span><span class="n">rgba_milestone_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">seg_weight</span><span class="p">,</span><span class="mf">0.95</span><span class="p">))</span><span class="c1">#cmap(seg.shape[0]/(max_seg_length-min_seg_length))</span>
        <span class="c1">#if seg_weight&gt;0.05: seg_weight=0.1</span>
        <span class="k">if</span> <span class="n">seg_count</span><span class="o">%</span><span class="mi">10000</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;seg weight&#39;</span><span class="p">,</span> <span class="n">seg_weight</span><span class="p">)</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">seg_p</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span><span class="o">*</span><span class="n">seg_weight</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">)</span><span class="c1">#edge_color )</span>
        <span class="n">seg_count</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">milestone_numeric_values_rgba</span><span class="o">=</span><span class="p">[]</span>

    <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">milestone_numeric_values</span><span class="p">:</span>
            <span class="n">rgba_</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="n">min_numerical_value</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">max_numerical_value</span><span class="o">-</span><span class="n">min_numerical_value</span><span class="p">))</span>
            <span class="n">milestone_numeric_values_rgba</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgba_</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">loc_time_thresh</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">loc_time_thresh</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values_rgba</span><span class="p">)[</span><span class="n">loc_time_thresh</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_scatter</span><span class="p">)</span>
        <span class="c1">#if we dont plot all the points, then the size of axis changes and the location of the graph moves/changes as more points are added</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span>
                   <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values_rgba</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_scatter</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolor</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M&quot;</span><span class="p">)</span>
    <span class="n">title_</span> <span class="o">=</span> <span class="s1">&#39;n_milestones = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span><span class="s1">&#39; time: &#39;</span><span class="o">+</span><span class="n">time</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">extra_title_text</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">title_</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Finished plotting edge bundle&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">time_series_set_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">))))</span>
        <span class="n">t_diff_mean</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_series_set_order</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_series_set_order</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]))</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="n">t_diff_mean</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number cycles&#39;</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_series_labels</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">time_series_labels</span>
            <span class="k">if</span> <span class="n">time_series_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time_series_labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">]</span>
            <span class="n">time_series_set_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">))))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;times series order set&#39;</span><span class="p">,</span> <span class="n">time_series_set_order</span><span class="p">)</span>
            <span class="n">t_diff_mean</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_series_set_order</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_series_set_order</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]))</span><span class="o">/</span><span class="mi">10</span> <span class="c1">#divide by 10 because we multiplied the single_cell_pt_markov by 10</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_diff_mean</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number cycles if no time_series labels given&#39;</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_edgebundle</span><span class="p">(</span><span class="n">frame_no</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside update&#39;</span><span class="p">,</span> <span class="n">frame_no</span><span class="p">,</span> <span class="s1">&#39;out of&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#time_series_set_order = list(sorted(list(set(time_series_labels))))</span>
            <span class="c1">#t_diff_mean = 0.25*np.mean(np.array([int(abs(y - x)) for x, y in zip(time_series_set_order[:-1], time_series_set_order[1:])]))</span>
            <span class="c1">#cycles= (max_numerical_value-min_numerical_value)/t_diff_mean</span>
            <span class="c1">#print(&#39;number cycles&#39;, cycles)</span>
            <span class="n">time_thresh</span> <span class="o">=</span> <span class="n">min_numerical_value</span> <span class="o">+</span><span class="n">frame_no</span><span class="o">%</span><span class="p">(</span><span class="n">cycles</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">t_diff_mean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span>
            <span class="n">time_thresh</span> <span class="o">=</span> <span class="n">min_numerical_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">frame_no</span> <span class="o">%</span><span class="n">n_intervals</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">max_numerical_value</span><span class="o">-</span><span class="n">min_numerical_value</span><span class="p">)</span><span class="o">/</span><span class="n">n_intervals</span>

        <span class="n">loc_time_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">time_thresh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">time_thresh</span><span class="o">-</span><span class="n">t_diff_mean</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1">#print(&#39;loc time thres&#39;, time_thresh, loc_time_thresh)</span>
        <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source_thresh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
            <span class="n">loc_time_thresh</span><span class="p">)</span>  <span class="c1"># apply(lambda x: any([k in x for k in loc_time_thresh]))</span>
        <span class="c1">#print(&#39;animate milestone edges&#39;)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source_thresh&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">source_milestone</span> <span class="o">=</span> <span class="n">milestone_edges</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># seg_weight = max(0.3, math.log(1+seg[-1,2])) seg[-1,2] column index 2 has the weight information</span>

            <span class="n">seg_weight</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">seg_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">max_seg_length</span> <span class="o">-</span> <span class="n">min_seg_length</span><span class="p">)</span>  <span class="c1">##seg.shape[0] / (max_seg_length - min_seg_length)</span>

            <span class="c1"># cant&#39; quite decide yet if sigmoid is desirable</span>
            <span class="c1"># seg_weight=sigmoid_scalar(seg.shape[0] / (max_seg_length - min_seg_length), scale=5, shift=mean_seg_length / (max_seg_length - min_seg_length))</span>
            <span class="n">alpha_bundle</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seg_weight</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># max(0.1, math.log(1 + seg[-1, 2]))</span>
            <span class="k">if</span> <span class="n">alpha_bundle</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">alpha_bundle</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">source_milestone_numerical_value</span> <span class="o">=</span> <span class="n">milestone_numeric_values</span><span class="p">[</span><span class="n">source_milestone</span><span class="p">]</span>

                <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">((</span><span class="n">source_milestone_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                            <span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">seg_weight</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">))</span>  <span class="c1"># cmap(seg.shape[0]/(max_seg_length-min_seg_length))</span>
            <span class="c1"># if seg_weight&gt;0.05: seg_weight=0.1</span>

            <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">seg_p</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span> <span class="o">*</span> <span class="n">seg_weight</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">)</span>  <span class="c1"># edge_color )</span>

        <span class="n">milestone_numeric_values_rgba</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">milestone_numeric_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">milestone_numeric_values</span><span class="p">:</span>
                <span class="n">rgba_</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_numerical_value</span> <span class="o">-</span> <span class="n">min_numerical_value</span><span class="p">))</span>
                <span class="n">milestone_numeric_values_rgba</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgba_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_thresh</span> <span class="o">&gt;</span> <span class="mf">1.1</span><span class="o">*</span><span class="n">max_numerical_value</span><span class="p">:</span>  <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>   <span class="c1">#ax.scatter(layout[loc_time_thresh, 0], layout[loc_time_thresh, 1], s=size_scatter, c=&#39;black&#39;, alpha=1)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span>
                           <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values_rgba</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">loc_time_thresh</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[</span><span class="n">loc_time_thresh</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">milestone_numeric_values_rgba</span><span class="p">)[</span><span class="n">loc_time_thresh</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_scatter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size_scatter</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_scatter</span><span class="p">)</span>
        <span class="c1">#pbar.update()</span>

    <span class="n">frame_no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
    <span class="n">animation</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update_edgebundle</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">frame_no</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">frame_interval</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#100</span>
    <span class="c1">#pbar = tqdm.tqdm(total=frame_no)</span>
    <span class="c1">#pbar.close()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;complete animate&#39;</span><span class="p">)</span>

    <span class="n">animation</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;imagemagick&#39;</span><span class="p">)</span><span class="c1">#, fps=30)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;saved animation&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="animate_streamplot"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.animate_streamplot">[docs]</a><span class="k">def</span> <span class="nf">animate_streamplot</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">embedding</span> <span class="p">,</span> <span class="n">density_grid</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">min_mass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cutoff_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">scatter_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">scatter_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">marker_edgewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">smooth_grid</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color_scheme</span> <span class="o">=</span> <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="n">other_labels</span><span class="o">=</span><span class="p">[]</span> <span class="p">,</span> <span class="n">b_bias</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">n_neighbors_velocity_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">alpha_animate</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                        <span class="n">cmap_scatter</span> <span class="o">=</span> <span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">cmap_stream</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">,</span> <span class="n">segment_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;/home/shobi/Trajectory/Datasets/animation.gif&#39;</span><span class="p">,</span><span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">facecolor_</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Draw Animated vector plots. the Saved .gif file saved at the saveto address, is the best for viewing the animation as the fig, ax output can be slow</span>

<span class="sd">    :param via_object: viaobject</span>
<span class="sd">    :param embedding: ndarray (nsamples,2) umap, tsne, via-umap, via-mds</span>
<span class="sd">    :param density_grid:</span>
<span class="sd">    :param linewidth:</span>
<span class="sd">    :param min_mass:</span>
<span class="sd">    :param cutoff_perc:</span>
<span class="sd">    :param scatter_size:</span>
<span class="sd">    :param scatter_alpha:</span>
<span class="sd">    :param marker_edgewidth:</span>
<span class="sd">    :param smooth_transition:</span>
<span class="sd">    :param smooth_grid:</span>
<span class="sd">    :param color_scheme: &#39;annotation&#39;, &#39;cluster&#39;, &#39;other&#39;</span>
<span class="sd">    :param add_outline_clusters:</span>
<span class="sd">    :param cluster_outline_edgewidth:</span>
<span class="sd">    :param gp_color:</span>
<span class="sd">    :param bg_color:</span>
<span class="sd">    :param title:</span>
<span class="sd">    :param b_bias:</span>
<span class="sd">    :param n_neighbors_velocity_grid:</span>
<span class="sd">    :param fontsize:</span>
<span class="sd">    :param alpha_animate:</span>
<span class="sd">    :param cmap_scatter:</span>
<span class="sd">    :param cmap_stream: string of a cmap for streamlines, default = &#39;Blues&#39; (for dark blue lines) . Consider &#39;Blues_r&#39; for white lines OR &#39;Greys/_r&#39; &#39;gist_yard/_r&#39;</span>
<span class="sd">    :param color_stream: string like &#39;white&#39;. will override cmap_stream</span>
<span class="sd">    :param segment_length:</span>

<span class="sd">    :return: fig, ax.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">tqdm</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span><span class="p">,</span> <span class="n">writers</span>
    <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
    <span class="kn">from</span> <span class="nn">pyVIA.windmap</span> <span class="kn">import</span> <span class="n">Streamlines</span>
    <span class="kn">import</span> <span class="nn">matplotlib.patheffects</span> <span class="k">as</span> <span class="nn">PathEffects</span>

    <span class="c1">#import cartopy.crs as ccrs</span>
    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>
        <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: please provide input parameter embedding of ndarray with shape (nsamples, 2)&#39;</span><span class="p">)</span>
    <span class="n">V_emb</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">_velocity_embedding</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b_bias</span><span class="p">,</span> <span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="n">use_sequentially_augmented</span><span class="p">)</span>

    <span class="n">V_emb</span> <span class="o">*=</span> <span class="mi">10</span> <span class="c1">#the velocity of the samples has shape (n_samples x 2).*100</span>

    <span class="c1">#interpolate the velocity along all grid points based on the velocities of the samples in V_emb</span>
    <span class="n">X_grid</span><span class="p">,</span> <span class="n">V_grid</span> <span class="o">=</span> <span class="n">compute_velocity_on_grid</span><span class="p">(</span>
        <span class="n">X_emb</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
        <span class="n">V_emb</span><span class="o">=</span><span class="n">V_emb</span><span class="p">,</span>
        <span class="n">density</span><span class="o">=</span><span class="n">density_grid</span><span class="p">,</span>
        <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_grid</span><span class="p">,</span>
        <span class="n">min_mass</span><span class="o">=</span><span class="n">min_mass</span><span class="p">,</span>
        <span class="n">autoscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">adjust_for_stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cutoff_perc</span><span class="o">=</span><span class="n">cutoff_perc</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors_velocity_grid</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Inside animated. File will be saved to location </span><span class="si">{</span><span class="n">saveto</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    #inspecting V_grid. most values are close to zero except those along data points of cells  </span>
<span class="sd">    print(&#39;U&#39;, V_grid.shape, V_grid[0].shape)</span>
<span class="sd">    print(&#39;sum is nan of each column&#39;, np.sum(np.isnan(V_grid[0]),axis=0))</span>
<span class="sd">    msk = np.isnan(V_grid[0])</span>
<span class="sd">    V_grid[0][msk]=0</span>
<span class="sd">    print(&#39;sum is nan of each column&#39;, np.sum(np.isnan(V_grid[0]), axis=0))</span>
<span class="sd">    print(&#39;max of each U column&#39;, np.max(V_grid[0], axis=0))</span>
<span class="sd">    print(&#39;max V&#39;, np.max(V_grid[1], axis=0))</span>
<span class="sd">    print(&#39;V&#39;)</span>
<span class="sd">    print( V_grid[1])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#lengths = np.sqrt((V_grid ** 2).sum(0))</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_scatter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span> <span class="n">color_labels</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>
        <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">color_labels</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
        <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="n">color_labels</span> <span class="o">=</span> <span class="n">other_labels</span>

        <span class="n">n_true</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">color_labels</span><span class="p">))</span>
        <span class="n">lin_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_true</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap_scatter</span><span class="p">)</span> <span class="c1">#&#39;twilight&#39; is nice too</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.80</span><span class="p">,</span> <span class="n">n_true</span><span class="p">))</span> <span class="c1">#.95</span>
        <span class="c1">#cmap = cmap(np.linspace(0.5, 0.95, n_true))</span>
        <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lin_col</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">color_labels</span><span class="p">))):</span>
            <span class="n">color_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cmap</span><span class="p">[</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

            <span class="n">color_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">scatter_alpha</span>

            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">color_labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                       <span class="n">c</span><span class="o">=</span><span class="n">color_</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">)</span> <span class="c1">#plt.cm.rainbow(color))</span>

            <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span><span class="s1">&#39;&#39;</span> <span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">PathEffects</span><span class="o">.</span><span class="n">withStroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span><span class="c1">#str(group)</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolor_</span><span class="p">)</span>

    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span>  <span class="o">=</span><span class="mi">0</span>
    <span class="c1">#X, Y, U, V = interpolate_static_stream(X_grid[0], X_grid[1], V_grid[0],V_grid[1])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Streamlines</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">V_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">V_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#s = Streamlines(X,Y,U,V)</span>

    <span class="k">for</span> <span class="n">streamline</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">streamlines</span><span class="p">:</span>
        <span class="n">random_seed</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">streamline</span>
        <span class="c1">#interpolate x, y data to handle nans</span>
        <span class="n">x_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">nans</span><span class="p">,</span> <span class="n">func_</span> <span class="o">=</span> <span class="n">nan_helper</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
        <span class="n">x_</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">func_</span><span class="p">(</span><span class="n">nans</span><span class="p">),</span> <span class="n">func_</span><span class="p">(</span><span class="o">~</span><span class="n">nans</span><span class="p">),</span> <span class="n">x_</span><span class="p">[</span><span class="o">~</span><span class="n">nans</span><span class="p">])</span>


        <span class="n">y_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">nans</span><span class="p">,</span> <span class="n">func_</span> <span class="o">=</span> <span class="n">nan_helper</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>
        <span class="n">y_</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">func_</span><span class="p">(</span><span class="n">nans</span><span class="p">),</span> <span class="n">func_</span><span class="p">(</span><span class="o">~</span><span class="n">nans</span><span class="p">),</span> <span class="n">y_</span><span class="p">[</span><span class="o">~</span><span class="n">nans</span><span class="p">])</span>


        <span class="c1"># test=proj.transform_points(x=np.array(x),y=np.array(y),src_crs=proj)</span>
        <span class="c1">#points = np.array([x, y]).T.reshape(-1, 1, 2)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#print(&#39;points&#39;)</span>
        <span class="c1">#print(points.shape)</span>


        <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#nx2x2</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">segment_length</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">#3</span>
        <span class="n">C</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">C</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">alpha_animate</span>

        <span class="n">lw</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="c1"># 0.1 when changing linewidths in update</span>
        <span class="c1">#line = LineCollection(segments, color=C_locationbased, linewidth=1)</span>
        <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">linewidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total number of stream lines&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([]))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="c1">#print(&#39;colors&#39;, colors)</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame_no</span><span class="p">):</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap_stream</span><span class="p">)</span>
        <span class="c1">#cmap = cmap(np.linspace(0.1, 0.2, 100)) #darker portion</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1">#lighter portion</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.05</span>
            <span class="c1"># esthetic factors here by adding 0.1 and doing some clipping, 0.1 ensures no &quot;hard blacks&quot;</span>
            <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.9</span><span class="p">)</span>
            <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_animate</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">#*1.5</span>

            <span class="c1">#temp = (lengths[i] * 1.5) % 1  # *1.5 original until Sep 7 2022</span>
            <span class="n">linewidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1">#if i==5: print(&#39;temp&#39;, linewidths[i])</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            if i%5 ==0:</span>
<span class="sd">                print(&#39;lengths&#39;,i, lengths[i])</span>
<span class="sd">                colors[i][::-1] = (lengths[i] * 1.5) % 1</span>
<span class="sd">                colors[i][:, 0] = 1</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="c1">#CMAP COLORS</span>
            <span class="c1">#cmap_colors = [cmap(j) for j in colors[i][:,0]] #when using full cmap_stream</span>
            <span class="n">cmap_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="c1">#when using truncated cmap_stream</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            cmap_colors = [cmap[int(j*100)] for j in colors[i][:, 0]]</span>
<span class="sd">            linewidths[i] = [f[0]*2 for f in cmap_colors]</span>
<span class="sd">            if i ==5: print(&#39;colors&#39;, [f[0]for f in cmap_colors])</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">row</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">cmap_colors</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="c1">#colors[i][row, 3] = (1-colors[i][row][0])*0.6#alpha_animate</span>
                <span class="c1">#linewidths[i][row] = 2-((colors[i][row][0])%2) #1-colors[i]... #until 7 sept 2022</span>

                <span class="c1">#if color_stream is not None: colors[i][row, :] =  matplotlib.colors.to_rgba_array(color_stream)[0] #monochrome is nice 1 or 0</span>
            <span class="c1">#if i == 5: print(&#39;lw&#39;, linewidths[i])</span>
            <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_animate</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">linewidths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">250</span><span class="c1">#27</span>

    <span class="n">animation</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">animation</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;imagemagick&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="c1">#animation.save(&#39;/home/shobi/Trajectory/Datasets/Toy3/wind_density_ffmpeg.mp4&#39;, writer=&#39;ffmpeg&#39;, fps=60)</span>

    <span class="c1">#fig.patch.set_visible(False)</span>
    <span class="c1">#ax.axis(&#39;off&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="via_streamplot"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.via_streamplot">[docs]</a><span class="k">def</span> <span class="nf">via_streamplot</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">density_grid</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">arrow_size</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">arrow_color</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">color_dict</span><span class="p">:</span><span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="n">arrow_style</span><span class="o">=</span><span class="s2">&quot;-|&gt;&quot;</span><span class="p">,</span>  <span class="n">max_length</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">min_mass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cutoff_perc</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="n">scatter_size</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">scatter_alpha</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">marker_edgewidth</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">density_stream</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">smooth_grid</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color_scheme</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="n">add_outline_clusters</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cluster_outline_edgewidth</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span><span class="n">gp_color</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">bg_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span> <span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span> <span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Streamplot&#39;</span><span class="p">,</span> <span class="n">b_bias</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">n_neighbors_velocity_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span><span class="n">show_text_labels</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construct vector streamplot on the embedding to show a fine-grained view of inferred directions in the trajectory</span>

<span class="sd">    :param via_object:</span>
<span class="sd">    :param embedding:  np.ndarray of shape (n_samples, 2) umap or other 2-d embedding on which to project the directionality of cells</span>
<span class="sd">    :param density_grid:</span>
<span class="sd">    :param arrow_size:</span>
<span class="sd">    :param arrow_color:</span>
<span class="sd">    :param arrow_style:</span>
<span class="sd">    :param max_length:</span>
<span class="sd">    :param linewidth:  width of  lines in streamplot, default = 1</span>
<span class="sd">    :param min_mass:</span>
<span class="sd">    :param cutoff_perc:</span>
<span class="sd">    :param scatter_size: size of scatter points default =500</span>
<span class="sd">    :param scatter_alpha: transpsarency of scatter points</span>
<span class="sd">    :param marker_edgewidth: width of outline arround each scatter point, default = 0.1</span>
<span class="sd">    :param density_stream:</span>
<span class="sd">    :param smooth_transition:</span>
<span class="sd">    :param smooth_grid:</span>
<span class="sd">    :param color_scheme: str, default = &#39;annotation&#39; corresponds to self.true_labels. Other options are &#39;time&#39; (uses single-cell pseudotime) and &#39;cluster&#39; (via cluster graph) and &#39;other&#39;. Alternatively provide labels as a list</span>
<span class="sd">    :param add_outline_clusters:</span>
<span class="sd">    :param cluster_outline_edgewidth:</span>
<span class="sd">    :param gp_color:</span>
<span class="sd">    :param bg_color:</span>
<span class="sd">    :param dpi:</span>
<span class="sd">    :param title:</span>
<span class="sd">    :param b_bias: default = 20. higher value makes the forward bias of pseudotime stronger</span>
<span class="sd">    :param n_neighbors_velocity_grid:</span>
<span class="sd">    :param labels: list (will be used for the color scheme) or if a color_dict is provided these labels should match</span>
<span class="sd">    :param use_sequentially_augmented:</span>
<span class="sd">    :param cmap:</span>
<span class="sd">    :return: fig, ax</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">   </span>
<span class="sd">  </span>
<span class="sd">   Parameters</span>
<span class="sd">   ----------</span>
<span class="sd">   X_emb:</span>

<span class="sd">   scatter_size: int, default = 500</span>

<span class="sd">   linewidth:</span>

<span class="sd">   marker_edgewidth: </span>

<span class="sd">   streamplot matplotlib.pyplot instance of fine-grained trajectories drawn on top of scatter plot</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">matplotlib.patheffects</span> <span class="k">as</span> <span class="nn">PathEffects</span>
    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>
        <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">WARNING: please assign ambedding attribute to via_object as via_object.embedding = ndarray of [n_cells x 2]&#39;</span><span class="p">)</span>

    <span class="n">V_emb</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">_velocity_embedding</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">b_bias</span><span class="p">,</span> <span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="n">use_sequentially_augmented</span><span class="p">)</span>

    <span class="n">V_emb</span> <span class="o">*=</span><span class="mi">20</span> <span class="c1">#5</span>


    <span class="n">X_grid</span><span class="p">,</span> <span class="n">V_grid</span> <span class="o">=</span> <span class="n">compute_velocity_on_grid</span><span class="p">(</span>
        <span class="n">X_emb</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
        <span class="n">V_emb</span><span class="o">=</span><span class="n">V_emb</span><span class="p">,</span>
        <span class="n">density</span><span class="o">=</span><span class="n">density_grid</span><span class="p">,</span>
        <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_grid</span><span class="p">,</span>
        <span class="n">min_mass</span><span class="o">=</span><span class="n">min_mass</span><span class="p">,</span>
        <span class="n">autoscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">adjust_for_stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cutoff_perc</span><span class="o">=</span><span class="n">cutoff_perc</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors_velocity_grid</span> <span class="p">)</span>

    <span class="c1"># adapted from : https://github.com/theislab/scvelo/blob/1805ab4a72d3f34496f0ef246500a159f619d3a2/scvelo/plotting/velocity_embedding_grid.py#L27</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">V_grid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">linewidth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">linewidth</span>
    <span class="c1">#linewidth *= 2 * lengths / np.percentile(lengths[~np.isnan(lengths)],90)</span>
    <span class="n">linewidth</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lengths</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lengths</span><span class="p">)]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1">#linewidth=0.5</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">V_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">V_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">arrow_color</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="n">arrow_size</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="n">arrow_style</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">density</span> <span class="o">=</span> <span class="n">density_stream</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="n">max_length</span><span class="p">)</span>

    <span class="c1">#num_cluster = len(set(super_cluster_labels))</span>

    <span class="k">if</span> <span class="n">add_outline_clusters</span><span class="p">:</span>
        <span class="c1"># add black outline to outer cells and a white inner rim</span>
        <span class="c1">#adapted from scanpy (scVelo utils adapts this from scanpy)</span>
        <span class="n">gp_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">scatter_size</span> <span class="o">*</span> <span class="n">cluster_outline_edgewidth</span> <span class="o">*</span><span class="mf">.1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">scatter_size</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">bg_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">scatter_size</span> <span class="o">*</span> <span class="n">cluster_outline_edgewidth</span><span class="p">)</span><span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gp_size</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">bg_size</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">bg_color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">gp_size</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">gp_color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">embedding</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>  <span class="n">zorder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis_r&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span><span class="n">color_labels</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>
            <span class="k">if</span> <span class="n">color_scheme</span> <span class="o">==</span> <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">color_labels</span><span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">labels</span>
            <span class="n">cmap_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="c1"># plt.cm.rainbow(color)</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">color_labels</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">color_labels</span><span class="p">))):</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">color_labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                           <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cmap_</span><span class="p">(</span><span class="n">color</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                           <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">show_text_labels</span><span class="p">:</span>
                    <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                            <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">PathEffects</span><span class="o">.</span><span class="n">withStroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="c1">#labels are categorical</span>
            <span class="k">if</span> <span class="n">color_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">color_dict</span><span class="p">:</span>
                    <span class="n">loc_key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">)</span>
                    <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">loc_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">show_text_labels</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#there is no color_dict but labels are categorical</span>
                <span class="n">cmap_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>

                <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))):</span>
                    <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                               <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cmap_</span><span class="p">(</span><span class="n">color</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">show_text_labels</span><span class="p">:</span>
                        <span class="n">x_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="n">y_mean</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">PathEffects</span><span class="o">.</span><span class="n">withStroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#not categorical</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="get_gene_expression"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.get_gene_expression">[docs]</a><span class="k">def</span> <span class="nf">get_gene_expression</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">gene_exp</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">marker_genes</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">linewidth</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span><span class="n">n_splines</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">spline_order</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fontsize_</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">marker_lineages</span><span class="o">=</span><span class="p">[],</span><span class="n">optional_title_text</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">cmap_dict</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Line graph of gene expression vs pseudotime along lineages.</span>

<span class="sd">    :param via_object: via object</span>
<span class="sd">    :param gene_exp: dataframe where columns are features (gene) and rows are single cells</span>
<span class="sd">    :param cmap: default: &#39;jet&#39;</span>
<span class="sd">    :param dpi: default:150</span>
<span class="sd">    :param marker_genes: Default is to use all genes in gene_exp. other provide a list of marker genes that will be used from gene_exp.</span>
<span class="sd">    :param linewidth: default:2</span>
<span class="sd">    :param n_slines: default:10 Note n_splines must be &gt; spline_order.</span>
<span class="sd">    :param spline_order: default:4 n_splines must be &gt; spline_order.</span>
<span class="sd">    :param marker_lineages: Default is to use all lineage pathways. other provide a list of lineage number (terminal cluster number).</span>
<span class="sd">    :param cmap_dict: {lineage number: &#39;color&#39;}</span>
<span class="sd">    :return: fig, axs</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sc_bp_original</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_bp</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">marker_lineages</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
        <span class="n">n_terminal_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="n">n_terminal_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marker_genes</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">gene_exp</span><span class="o">=</span><span class="n">gene_exp</span><span class="p">[</span><span class="n">marker_genes</span><span class="p">]</span>
    <span class="n">sc_pt</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>

    <span class="k">if</span> <span class="n">cmap_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">palette</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">n_terminal_states</span><span class="p">)</span>
        <span class="n">cmap_</span> <span class="o">=</span> <span class="n">palette</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_terminal_states</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">cmap_</span> <span class="o">=</span> <span class="n">cmap_dict</span>
    <span class="n">n_genes</span> <span class="o">=</span> <span class="n">gene_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">fig_nrows</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">fig_nrows</span> <span class="o">=</span> <span class="n">fig_nrows</span>
    <span class="k">if</span> <span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">fig_nrows</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">fig_ncols</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">,</span> <span class="n">fig_ncols</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">i_gene</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># counter for number of genes</span>
    <span class="n">i_terminal</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#counter for terminal cluster</span>
    <span class="c1"># for i in range(n_terminal_states): #[0]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fig_nrows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fig_ncols</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i_gene</span> <span class="o">&lt;</span> <span class="n">n_genes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">enum_i_lineage</span><span class="p">,</span> <span class="n">i_lineage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">marker_lineages</span><span class="p">):</span>
                    <span class="n">valid_scbp</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span>  <span class="n">i_lineage</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
                        <span class="n">i_terminal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="n">i_lineage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_terminal</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">sc_bp</span> <span class="o">=</span> <span class="n">sc_bp_original</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="n">valid_scbp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sc_bp</span><span class="p">[:,</span> <span class="n">i_terminal</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
                            <span class="n">i_terminal</span> <span class="o">=</span> <span class="n">i_terminal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>



                    <span class="c1">#if (via_object.terminal_clusters[i_terminal] in marker_lineages and len(np.where(sc_bp[:, i_terminal] &gt; 0.8)[ 0]) &gt; 0): # check if terminal state is in marker_lineage and in case this terminal state i cannot be reached (sc_bp is all 0)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i_lineage</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">valid_scbp</span><span class="p">):</span>
                        <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">[</span><span class="n">i_terminal</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">majority_true</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>

                        <span class="n">gene_i</span> <span class="o">=</span> <span class="n">gene_exp</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i_gene</span><span class="p">]</span>
                        <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sc_bp</span><span class="p">[:,</span> <span class="n">i_terminal</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">val_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">sc_pt</span><span class="p">[</span><span class="n">pt_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt_i</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>  <span class="c1"># TODO,  replace with array to speed up</span>

                        <span class="n">max_val_pt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val_pt</span><span class="p">)</span>

                        <span class="n">loc_i_bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sc_bp</span><span class="p">[:,</span> <span class="n">i_terminal</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.000</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0.001</span>
                        <span class="n">loc_i_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_val_pt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="n">loc_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">loc_i_bp</span><span class="p">,</span> <span class="n">loc_i_sc</span><span class="p">)</span>

                        <span class="n">gam_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_pt</span><span class="p">)[</span><span class="n">loc_</span><span class="p">]</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">gam_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gene_exp</span><span class="p">[</span><span class="n">gene_i</span><span class="p">])[</span><span class="n">loc_</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_bp</span><span class="p">[:,</span> <span class="n">i_terminal</span><span class="p">])[</span><span class="n">loc_</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">geneGAM</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">LinearGAM</span><span class="p">(</span><span class="n">n_splines</span><span class="o">=</span><span class="n">n_splines</span><span class="p">,</span> <span class="n">spline_order</span><span class="o">=</span><span class="n">spline_order</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
                            <span class="n">xval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sc_pt</span><span class="p">),</span> <span class="n">max_val_pt</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">yg</span> <span class="o">=</span> <span class="n">geneGAM</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">xval</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Lineage </span><span class="si">{</span><span class="n">i_terminal</span><span class="si">}</span><span class="s1"> cannot be reached. Exclude this lineage in trend plotting&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">cmap_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color_</span> <span class="o">=</span> <span class="n">cmap_</span><span class="p">[</span><span class="n">enum_i_lineage</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cmap dict&#39;</span><span class="p">,</span> <span class="n">cmap_</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i_lineage&#39;</span><span class="p">,</span> <span class="n">i_lineage</span><span class="p">)</span>
                            <span class="n">color_</span> <span class="o">=</span> <span class="n">cmap_</span><span class="p">[</span><span class="n">i_lineage</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xval</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Lineage:</span><span class="si">{</span><span class="n">majority_true</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">[</span><span class="n">i_terminal</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">gene_i</span><span class="o">+</span><span class="n">optional_title_text</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                            <span class="c1"># Set tick font size</span>
                            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()):</span>
                                <span class="n">label</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize_</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">i_gene</span> <span class="o">==</span> <span class="n">n_genes</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                                <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                                <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xval</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>   <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Lineage:</span><span class="si">{</span><span class="n">majority_true</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">[</span><span class="n">i_terminal</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">gene_i</span><span class="o">+</span><span class="n">optional_title_text</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                            <span class="c1"># Set tick font size</span>
                            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()):</span>
                                <span class="n">label</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize_</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">i_gene</span> <span class="o">==</span> <span class="n">n_genes</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                                <span class="n">axs</span><span class="p">[</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                                <span class="n">axs</span><span class="p">[</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize_</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">i_gene</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fig_nrows</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>

<div class="viewcode-block" id="plot_trajectory_curves"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_trajectory_curves">[docs]</a><span class="k">def</span> <span class="nf">plot_trajectory_curves</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">title_str</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span> <span class="s2">&quot;Pseudotime&quot;</span><span class="p">,</span> <span class="n">draw_all_curves</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">arrow_width_scale_factor</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span>
                         <span class="n">scatter_size</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">scatter_alpha</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                         <span class="n">linewidth</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">marker_edgewidth</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap_pseudotime</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;viridis_r&#39;</span><span class="p">,</span><span class="n">dpi</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">highlight_terminal_states</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_maxout_edgelist</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Projects the graph based coarse trajectory onto a umap/tsne embedding</span>

<span class="sd">    :param via_object: via object</span>

<span class="sd">    :param embedding: 2d array [n_samples x 2] with x and y coordinates of all n_samples. Umap, tsne, pca OR use the via computed embedding via_object.embedding</span>
<span class="sd">    :param idx: default: None. Or List. if you had previously computed a umap/tsne (embedding) only on a subset of the total n_samples (subsampled as per idx), then the via objects and results will be indexed according to idx too</span>
<span class="sd">    :param title_str: title of figure</span>
<span class="sd">    :param draw_all_curves: if the clustergraph has too many edges to project in a visually interpretable way, set this to False to get a simplified view of the graph pathways</span>
<span class="sd">    :param arrow_width_scale_factor:</span>
<span class="sd">    :param scatter_size:</span>
<span class="sd">    :param scatter_alpha:</span>
<span class="sd">    :param linewidth:</span>
<span class="sd">    :param marker_edgewidth:</span>
<span class="sd">    :param cmap_pseudotime:</span>
<span class="sd">    :param dpi: int default = 150. Use 300 for paper figures</span>
<span class="sd">    :param highlight_terminal_states: whether or not to highlight/distinguish the clusters which are detected as the terminal states by via</span>
<span class="sd">    :return: f, ax1, ax2</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">embedding</span>
        <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1"> ERROR please provide an embedding or compute using via_mds() or via_umap()&#39;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="n">cluster_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">super_cluster_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">super_edgelist</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">edgelist</span>
    <span class="k">if</span> <span class="n">use_maxout_edgelist</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">super_edgelist</span> <span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">edgelist_maxout</span>
    <span class="n">true_label</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">knn</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">ncomp</span>
    <span class="n">final_super_terminal</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>

    <span class="n">sub_terminal_clusters</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
    <span class="n">sc_pt_markov</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">)[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">super_root</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">sc_supercluster_nn</span> <span class="o">=</span> <span class="n">sc_loc_ofsuperCluster_PCAspace</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)))</span>
    <span class="c1"># draw_all_curves. True draws all the curves in the piegraph, False simplifies the number of edges</span>
    <span class="c1"># arrow_width_scale_factor: size of the arrow head</span>
    <span class="n">X_dimred</span> <span class="o">=</span> <span class="n">embedding</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
    <span class="n">noise0</span> <span class="o">=</span> <span class="n">max_x</span> <span class="o">/</span> <span class="mi">1000</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="s1">&#39;super_cluster&#39;</span><span class="p">:</span> <span class="n">super_cluster_labels</span><span class="p">,</span>
                       <span class="s1">&#39;projected_sc_pt&#39;</span><span class="p">:</span> <span class="n">sc_pt_markov</span><span class="p">},</span>
                      <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;super_cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;projected_sc_pt&#39;</span><span class="p">])</span>
    <span class="n">df_mean</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">sub_cluster_isin_supercluster</span> <span class="o">=</span> <span class="n">df_mean</span><span class="p">[[</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;super_cluster&#39;</span><span class="p">]]</span>

    <span class="n">sub_cluster_isin_supercluster</span> <span class="o">=</span> <span class="n">sub_cluster_isin_supercluster</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">)</span>
    <span class="n">sub_cluster_isin_supercluster</span><span class="p">[</span><span class="s1">&#39;int_supercluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_cluster_isin_supercluster</span><span class="p">[</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="nb">int</span><span class="p">)</span>

    <span class="n">df_super_mean</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">df_super_mean</span><span class="p">[</span><span class="s1">&#39;projected_sc_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="n">num_true_group</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">true_label</span><span class="p">))</span>
    <span class="n">num_cluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">super_cluster_labels</span><span class="p">))</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_true_group</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">true_label</span><span class="p">))):</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">true_label</span><span class="p">)</span> <span class="o">==</span> <span class="n">group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_dimred</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">color</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="o">*</span><span class="mf">.1</span><span class="p">)</span>  <span class="c1"># 10 # 0.5 and 4</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">frameon</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;True Labels: ncomps:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. knn:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">knn</span><span class="p">))</span>

    <span class="n">G_orange</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">num_cluster</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">super_edgelist</span><span class="p">)</span>
    <span class="n">ll_</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># this can be activated if you intend to simplify the curves</span>
    <span class="k">for</span> <span class="n">fst_i</span> <span class="ow">in</span> <span class="n">final_super_terminal</span><span class="p">:</span>

        <span class="n">path_orange</span> <span class="o">=</span> <span class="n">G_orange</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">super_root</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="n">fst_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">len_path_orange</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_orange</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">enum_edge</span><span class="p">,</span> <span class="n">edge_fst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path_orange</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">enum_edge</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len_path_orange</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ll_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge_fst</span><span class="p">,</span> <span class="n">path_orange</span><span class="p">[</span><span class="n">enum_edge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="n">edges_to_draw</span> <span class="o">=</span> <span class="n">super_edgelist</span> <span class="k">if</span> <span class="n">draw_all_curves</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ll_</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">e_i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges_to_draw</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pt</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pt</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>

        <span class="n">x_i_start</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_i_start</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">x_i_end</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_i_end</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;super_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>


        <span class="n">super_start_x</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">sc_supercluster_nn</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">super_end_x</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">sc_supercluster_nn</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">super_start_y</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">sc_supercluster_nn</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">super_end_y</span> <span class="o">=</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">sc_supercluster_nn</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">direction_arrow</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">super_start_x</span> <span class="o">&gt;</span> <span class="n">super_end_x</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">super_start_x</span><span class="p">,</span> <span class="n">super_end_x</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">super_start_x</span><span class="p">,</span> <span class="n">super_end_x</span><span class="p">)</span>

        <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">super_start_y</span><span class="p">,</span> <span class="n">super_end_y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">super_start_y</span><span class="p">,</span> <span class="n">super_end_y</span><span class="p">)</span>

        <span class="n">x_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_i_start</span><span class="p">,</span> <span class="n">x_i_end</span><span class="p">])</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_i_start</span><span class="p">,</span> <span class="n">y_i_end</span><span class="p">])</span>

        <span class="n">idx_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x_val</span> <span class="o">&lt;=</span> <span class="n">maxx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x_val</span> <span class="o">&gt;=</span> <span class="n">minx</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idy_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y_val</span> <span class="o">&lt;=</span> <span class="n">maxy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_val</span> <span class="o">&gt;=</span> <span class="n">miny</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">idx_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idy_keep</span><span class="p">,</span> <span class="n">idx_keep</span><span class="p">)</span>

        <span class="n">x_val</span> <span class="o">=</span> <span class="n">x_val</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">]</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">y_val</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">]</span>

        <span class="n">super_mid_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">super_start_x</span> <span class="o">+</span> <span class="n">super_end_x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">super_mid_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">super_start_y</span> <span class="o">+</span> <span class="n">super_end_y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>

        <span class="n">very_straight</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">straight_level</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">noise0</span>
        <span class="n">x_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">super_start_x</span><span class="p">,</span> <span class="n">super_end_x</span><span class="p">,</span> <span class="n">super_start_x</span><span class="p">,</span> <span class="n">super_end_x</span><span class="p">,</span> <span class="n">super_start_x</span><span class="p">,</span> <span class="n">super_end_x</span><span class="p">,</span> <span class="n">super_start_x</span><span class="p">,</span>
             <span class="n">super_end_x</span><span class="p">,</span> <span class="n">super_start_x</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">super_end_x</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span>
             <span class="n">super_start_x</span> <span class="o">-</span> <span class="n">noise</span><span class="p">,</span> <span class="n">super_end_x</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>
        <span class="n">y_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">super_start_y</span><span class="p">,</span> <span class="n">super_end_y</span><span class="p">,</span> <span class="n">super_start_y</span><span class="p">,</span> <span class="n">super_end_y</span><span class="p">,</span> <span class="n">super_start_y</span><span class="p">,</span> <span class="n">super_end_y</span><span class="p">,</span> <span class="n">super_start_y</span><span class="p">,</span>
             <span class="n">super_end_y</span><span class="p">,</span> <span class="n">super_start_y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">super_end_y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span>
             <span class="n">super_start_y</span> <span class="o">-</span> <span class="n">noise</span><span class="p">,</span> <span class="n">super_end_y</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">minx</span> <span class="o">-</span> <span class="n">maxx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">very_straight</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">straight_level</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">x_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_super</span><span class="p">,</span> <span class="n">super_mid_x</span><span class="p">)</span>
            <span class="n">y_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_super</span><span class="p">,</span> <span class="n">super_mid_y</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">straight_level</span><span class="p">):</span>  <span class="c1"># DO THE SAME FOR A MIDPOINT TOO</span>
            <span class="n">y_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_super</span><span class="p">,</span> <span class="n">y_super</span><span class="p">])</span>
            <span class="n">x_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_super</span><span class="p">,</span> <span class="n">x_super</span><span class="p">])</span>

        <span class="n">list_selected_clus</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_selected_clus</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="n">very_straight</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([(</span><span class="n">super_mid_x</span><span class="p">,</span> <span class="n">super_mid_y</span><span class="p">)],</span> <span class="n">list_selected_clus</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_selected_clus</span><span class="p">))</span>
            <span class="n">midpoint_loc</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="n">k</span><span class="p">]</span>

            <span class="n">midpoint_xy</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">midpoint_xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_selected_clus</span><span class="p">[</span><span class="n">midpoint_loc</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="n">noise</span> <span class="o">=</span> <span class="n">noise0</span> <span class="o">*</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">midpoint_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mid_x</span><span class="p">,</span> <span class="n">mid_x</span><span class="p">])</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mid_y</span><span class="p">,</span> <span class="n">mid_y</span><span class="p">])</span>

            <span class="n">x_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_super</span><span class="p">,</span> <span class="n">mid_x</span><span class="p">])</span>
            <span class="n">y_super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_super</span><span class="p">,</span> <span class="n">mid_y</span><span class="p">])</span>
        <span class="n">x_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_val</span><span class="p">,</span> <span class="n">x_super</span><span class="p">])</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_super</span><span class="p">])</span>

        <span class="n">x_val</span> <span class="o">=</span> <span class="n">x_val</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">y_val</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_val</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

        <span class="n">gam50</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">LinearGAM</span><span class="p">(</span><span class="n">n_splines</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">spline_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">gridsearch</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="n">gam50</span><span class="o">.</span><span class="n">generate_X_grid</span><span class="p">(</span><span class="n">term</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">gam50</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">XX</span><span class="p">)</span>

        <span class="n">idx_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">maxx</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xp</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">minx</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;#323538&#39;</span><span class="p">)</span>  <span class="c1"># 3.5#1.5</span>


        <span class="n">mean_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">])</span>
        <span class="n">closest_val</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">closest_loc</span> <span class="o">=</span> <span class="n">idx_keep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xp_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xp_val</span> <span class="o">-</span> <span class="n">mean_temp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">closest_val</span> <span class="o">-</span> <span class="n">mean_temp</span><span class="p">):</span>
                <span class="n">closest_val</span> <span class="o">=</span> <span class="n">xp_val</span>
                <span class="n">closest_loc</span> <span class="o">=</span> <span class="n">idx_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">head_width</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">arrow_width_scale_factor</span>  <span class="c1"># arrow_width needs to be adjusted sometimes # 40#30  ##0.2 #0.05 for mESC #0.00001 (#for 2MORGAN and others) # 0.5#1</span>
        <span class="k">if</span> <span class="n">direction_arrow</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span>
                      <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">-</span> <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">head_width</span><span class="o">=</span><span class="n">head_width</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#323538&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span> <span class="o">-</span> <span class="n">step</span><span class="p">]</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span>
                      <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span> <span class="o">-</span> <span class="n">step</span><span class="p">]</span> <span class="o">-</span> <span class="n">preds</span><span class="p">[</span><span class="n">closest_loc</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">head_width</span><span class="o">=</span><span class="n">head_width</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#323538&#39;</span><span class="p">)</span>

    <span class="n">c_edge</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">width_edge</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pen_color</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">super_cluster_label</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">terminal_count_</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dot_size</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_supercluster_nn</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">final_super_terminal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Super cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> is a super terminal with sub_terminal cluster&#39;</span><span class="p">,</span>
                  <span class="n">sub_terminal_clusters</span><span class="p">[</span><span class="n">terminal_count_</span><span class="p">])</span>
            <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;yellow&#39;</span><span class="p">)</span>  <span class="c1"># (&#39;yellow&#39;)</span>
            <span class="k">if</span> <span class="n">highlight_terminal_states</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">width_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">super_cluster_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;TS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sub_terminal_clusters</span><span class="p">[</span><span class="n">terminal_count_</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">super_cluster_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">pen_color</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
            <span class="c1"># super_cluster_label.append(&#39;TS&#39; + str(i))  # +&#39;(&#39;+str(i)+&#39;)&#39;)</span>
             <span class="c1"># +&#39;(&#39;+str(i)+&#39;)&#39;)</span>
            <span class="n">dot_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># 60</span>
            <span class="n">terminal_count_</span> <span class="o">=</span> <span class="n">terminal_count_</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">width_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
            <span class="n">pen_color</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">super_cluster_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span>  <span class="c1"># i or &#39; &#39;</span>
            <span class="n">dot_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span>  <span class="c1"># 20</span>

    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title_str</span><span class="p">)</span>

    <span class="n">im2</span> <span class="o">=</span><span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">sc_pt_markov</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_pseudotime</span><span class="p">,</span>  <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
    <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">)</span> <span class="c1">#to avoid lines drawn on the colorbar we need an image instance without alpha variable</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_dimred</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">sc_pt_markov</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_pseudotime</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">marker_edgewidth</span><span class="o">*</span><span class="mf">.1</span><span class="p">)</span>
    <span class="n">count_</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loci</span> <span class="o">=</span> <span class="p">[</span><span class="n">sc_supercluster_nn</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sc_supercluster_nn</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">dsz</span><span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">loci</span><span class="p">,</span> <span class="n">c_edge</span><span class="p">,</span> <span class="n">width_edge</span><span class="p">,</span> <span class="n">pen_color</span><span class="p">,</span> <span class="n">dot_size</span><span class="p">,</span>
                                     <span class="n">super_cluster_label</span><span class="p">):</span>  <span class="c1"># sc_supercluster_nn</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_dimred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">dsz</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">X_dimred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_dimred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">count_</span> <span class="o">=</span> <span class="n">count_</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span></div>


<div class="viewcode-block" id="plot_viagraph_"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_viagraph_">[docs]</a><span class="k">def</span> <span class="nf">plot_viagraph_</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hammer_bundle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">CSM</span><span class="p">:</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity_weight</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pt</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_bundle</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidth_bundle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;darkblue&#39;</span><span class="p">,</span><span class="n">headwidth_bundle</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">arrow_frequency</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">show_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ax_text</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">plot_clusters</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">via_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">dpi</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots the edgebundles on the via clustergraph level and also adds the relevant arrow directions based on the TI directionality</span>

<span class="sd">    :param ax: axis to plot on</span>
<span class="sd">    :param hammer_bundle: hammerbundle object with coordinates of all the edges to draw. self.hammer</span>
<span class="sd">    :param layout: coords of cluster nodes</span>
<span class="sd">    :param CSM: cosine similarity matrix. cosine similarity between the RNA velocity between neighbors and the change in gene expression between these neighbors. Only used when available</span>
<span class="sd">    :param velocity_weight: percentage weightage given to the RNA velocity based transition matrix</span>
<span class="sd">    :param pt: cluster-level pseudotime (or other intensity level of features at average-cluster level)</span>
<span class="sd">    :param alpha_bundle: alpha when drawing lines</span>
<span class="sd">    :param linewidth_bundle: linewidth of bundled lines</span>
<span class="sd">    :param edge_color:</span>
<span class="sd">    :param headwidth_bundle: headwidth of arrows used in bundled edges</span>
<span class="sd">    :param arrow_frequency: min dist between arrows (bundled edges otherwise have overcrowding of arrows)</span>
<span class="sd">    :param show_direction: bool default True. will draw arrows along the lines to indicate direction</span>
<span class="sd">    :param plot_clusters: bool default False. When this function is called on its own (and not from within draw_piechart_graph() then via_object must be provided</span>
<span class="sd">    :param ax_text: bool default True. Show labels of the clusters with the cluster population and PARC cluster label</span>
<span class="sd">    :param fontsize: float default 9 Font size of labels</span>
<span class="sd">    :return: fig, ax with bundled edges plotted</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">return_fig_ax</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#return only the ax</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">return_fig_ax</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">plot_clusters</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">via_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: please provide a via object in order to plot the clusters on the graph&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hammer_bundle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">hammer_bundle</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_cluster</span>
        <span class="k">if</span> <span class="n">layout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span>
        <span class="k">if</span> <span class="n">CSM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">CSM</span><span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">CSM</span>
        <span class="k">if</span> <span class="n">velocity_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">velocity_weight</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">velo_weight</span>
        <span class="k">if</span> <span class="n">pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">scaled_hitting_times</span>

    <span class="n">x_</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
    <span class="n">y_</span> <span class="o">=</span>  <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layout</span> <span class="p">]</span>
    <span class="c1">#min_x, max_x = min(x_), max(x_)</span>
    <span class="c1">#min_y, max_y = min(y_), max(y_)</span>
    <span class="n">delta_x</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>

    <span class="n">delta_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span><span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>

    <span class="n">layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
    <span class="c1"># make a knn so we can find which clustergraph nodes the segments start and end at</span>

    <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
    <span class="c1"># get each segment. these are separated by nans.</span>
    <span class="n">hbnp</span> <span class="o">=</span> <span class="n">hammer_bundle</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hbnp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#location of each nan values</span>
    <span class="n">edgelist_segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arrow_coords</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">hbnp</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># every nth segment is plotted</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[::</span><span class="n">n</span><span class="p">]:</span>
        <span class="n">do_arrow</span><span class="o">=</span><span class="kc">True</span>

        <span class="c1">#seg_weight = max(0.3, math.log(1+seg[-1,2]))</span>
        <span class="n">seg_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>

        <span class="c1">#print(&#39;seg weight&#39;, seg_weight)</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">seg_p</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">start</span><span class="o">=</span><span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;start,end&#39;,[start, end])</span>

        <span class="k">if</span> <span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edgelist_segments</span><span class="p">)</span><span class="o">|</span><span class="p">([</span><span class="n">end</span><span class="p">,</span><span class="n">start</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edgelist_segments</span><span class="p">):</span>
            <span class="n">do_arrow</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">edgelist_segments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">])</span>

        <span class="n">direction_</span> <span class="o">=</span> <span class="n">infer_direction_piegraph</span><span class="p">(</span><span class="n">start_node</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end_node</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">CSM</span><span class="o">=</span><span class="n">CSM</span><span class="p">,</span> <span class="n">velocity_weight</span><span class="o">=</span><span class="n">velocity_weight</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">pt</span><span class="p">)</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">direction_</span> <span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>


        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth_bundle</span><span class="o">*</span><span class="n">seg_weight</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">edge_color</span> <span class="p">)</span>
        <span class="n">mid_point</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">seg_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrow_coords</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#dont draw arrows in overlapping segments</span>
            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">arrow_coords</span><span class="p">:</span>
                <span class="n">dist_</span> <span class="o">=</span> <span class="n">dist_points</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="o">=</span><span class="p">[</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
                <span class="c1">#print(&#39;dist between points&#39;, dist_)</span>
                <span class="k">if</span> <span class="n">dist_</span><span class="o">&lt;</span> <span class="n">arrow_frequency</span><span class="o">*</span><span class="n">delta_x</span><span class="p">:</span> <span class="n">do_arrow</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="n">dist_</span><span class="o">&lt;</span> <span class="n">arrow_frequency</span><span class="o">*</span><span class="n">delta_y</span><span class="p">:</span> <span class="n">do_arrow</span><span class="o">=</span><span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">do_arrow</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">step</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="n">headwidth_bundle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">arrow_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_p</span><span class="p">[</span><span class="n">mid_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">plot_clusters</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">group_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">group_i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
                    <span class="c1">#n_groups = len(set(via_object.labels))</span>
                    <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">group_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">group_pop</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>
            <span class="n">gp_scaling</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">group_pop</span><span class="p">)</span>  <span class="c1"># 500 / max(group_pop)</span>
            <span class="n">group_pop_scale</span> <span class="o">=</span> <span class="n">group_pop</span> <span class="o">*</span> <span class="n">gp_scaling</span> <span class="o">*</span> <span class="mf">0.5</span>


            <span class="n">c_edge</span><span class="p">,</span> <span class="n">l_width</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">via_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">terminal_clusters_placeholder</span> <span class="o">=</span>  <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">terminal_clusters_placeholder</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">pti</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">terminal_clusters_placeholder</span><span class="p">:</span>
                    <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                    <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                    <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">group_pop_scale</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                               <span class="n">edgecolors</span><span class="o">=</span><span class="n">c_edge</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">l_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ax_text</span><span class="p">:</span>
                <span class="n">x_max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>
                <span class="n">y_max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">layout</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">layout</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_max_range</span><span class="p">,</span> <span class="n">y_max_range</span><span class="p">),</span>
                              <span class="n">layout</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max_range</span><span class="p">,</span> <span class="n">y_max_range</span><span class="p">),</span>
                              <span class="s1">&#39;C&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;pop&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">group_pop</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">])),</span>
                              <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_fig_ax</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span></div>

<span class="k">def</span> <span class="nf">_slow_sklearn_mds</span><span class="p">(</span><span class="n">via_graph</span><span class="p">:</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">X_pca</span><span class="p">:</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_diff_op</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param via_graph: via_graph =via_object.csr_full_graph #single cell knn graph representation based on hnsw</span>
<span class="sd">    :param t_diff_op:</span>
<span class="sd">    :param X_pca ndarray adata_counts.obsm[&#39;X_pca&#39;][:, 0:ncomps]</span>
<span class="sd">    :return: ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>

    <span class="n">via_graph</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">via_graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">via_graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">via_graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
    <span class="n">row_stoch</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">via_graph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># note that the edge weights are affinities in via_graph</span>

    <span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">manifold</span>
    <span class="n">mds</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">MDS</span><span class="p">(</span>
        <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">dissimilarity</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">row_stoch</span> <span class="o">=</span> <span class="n">row_stoch</span> <span class="o">**</span> <span class="n">t_diff_op</span> <span class="c1">#level of diffusion</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>

    <span class="n">X_mds</span> <span class="o">=</span> <span class="n">row_stoch</span> <span class="o">*</span> <span class="n">temp</span>  <span class="c1"># matrix multiplication</span>

    <span class="n">X_mds</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">X_mds</span><span class="o">.</span><span class="n">todense</span><span class="p">()))</span>
    <span class="n">X_mds</span> <span class="o">=</span> <span class="n">mds</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_mds</span><span class="p">)</span><span class="o">.</span><span class="n">embedding_</span>
    <span class="c1"># X_mds = squareform(pdist(adata_counts.obsm[&#39;X_pca&#39;][:, 0:ncomps+20])) #no diffusion makes is less streamlined and compact. more fuzzy</span>
    <span class="k">return</span> <span class="n">X_mds</span>

<div class="viewcode-block" id="plot_piechart_viagraph"><a class="viewcode-back" href="../../api/index.html#VIA.plotting_via.plot_piechart_viagraph">[docs]</a><span class="k">def</span> <span class="nf">plot_piechart_viagraph</span><span class="p">(</span><span class="n">via_object</span><span class="p">,</span> <span class="n">type_data</span><span class="o">=</span><span class="s1">&#39;pt&#39;</span><span class="p">,</span> <span class="n">gene_exp</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">cmap_piechart</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax_text</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">headwidth_arrow</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha_edge</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">linewidth_edge</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;darkblue&#39;</span><span class="p">,</span><span class="n">reference_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_legend</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pie_size_scale</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pt_visual_threshold</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span><span class="mi">99</span><span class="p">,</span><span class="n">highlight_terminal_clusters</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">size_node_notpiechart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot two subplots with a clustergraph level representation of the viagraph showing true-label composition (lhs) and pseudotime/gene expression (rhs)</span>

<span class="sd">    Returns matplotlib figure with two axes that plot the clustergraph using edge bundling</span>
<span class="sd">    left axis shows the clustergraph with each node colored by annotated ground truth membership.</span>
<span class="sd">    right axis shows the same clustergraph with each node colored by the pseudotime or gene expression</span>

<span class="sd">    :param via_object: is class VIA (the same function also exists as a method of the class and an external plotting function</span>
<span class="sd">    :param type_data: string  default &#39;pt&#39; for pseudotime colored nodes. or &#39;gene&#39;</span>
<span class="sd">    :param gene_exp: list of values (or column of dataframe) corresponding to feature or gene expression to be used to color nodes at CLUSTER level</span>
<span class="sd">    :param cmap_piechart: str cmap for piechart categories</span>
<span class="sd">    :param title: string</span>
<span class="sd">    :param cmap: default None. automatically chooses coolwarm for gene expression or viridis_r for pseudotime</span>
<span class="sd">    :param ax_text: Bool default= True. Annotates each node with cluster number and population of membership</span>
<span class="sd">    :param dpi: int default = 150</span>
<span class="sd">    :param headwidth_arrow: default = 0.1. width of arrowhead used to directed edges</span>
<span class="sd">    :param reference_labels: None or list. list of categorical (str) labels for cluster composition of the piecharts (LHS subplot) length = n_samples.</span>
<span class="sd">    :param pie_size_scale: float default=0.8 scaling factor of the piechart nodes</span>
<span class="sd">    :param pt_visual_threshold: int (percentage) default = 95 corresponding to rescaling the visual color scale by clipping outlier cluster pseudotimes</span>
<span class="sd">    :param highlight_terminal_clusters:bool = True (red border around terminal clusters)</span>
<span class="sd">    :param size_node_notpiechart: scaling factor for node size of the viagraph (not the piechart part)</span>
<span class="sd">    :return: f, ax, ax1</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
    <span class="n">f</span><span class="p">,</span> <span class="p">((</span><span class="n">ax</span><span class="p">,</span> <span class="n">ax1</span><span class="p">))</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>

    <span class="n">node_pos</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span>

    <span class="n">node_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">node_pos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;coolwarm&#39;</span> <span class="k">if</span> <span class="n">type_data</span> <span class="o">==</span> <span class="s1">&#39;gene&#39;</span> <span class="k">else</span> <span class="s1">&#39;viridis_r&#39;</span>

    <span class="k">if</span> <span class="n">type_data</span> <span class="o">==</span> <span class="s1">&#39;pt&#39;</span><span class="p">:</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">markov_hitting_times</span> <span class="c1">#via_object.scaled_hitting_times</span>
        <span class="n">threshold_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">pt_visual_threshold</span><span class="p">)</span>

        <span class="n">pt_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pt</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">threshold_high</span> <span class="p">]</span> <span class="c1">#remove high outliers</span>
        <span class="n">new_upper_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pt_subset</span><span class="p">,</span> <span class="n">pt_visual_threshold</span><span class="p">)</span> <span class="c1">#&#39;true&#39; upper percentile after removing outliers</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">new_upper_pt</span> <span class="k">else</span> <span class="n">new_upper_pt</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pt</span><span class="p">]</span>
        <span class="n">title_ax1</span> <span class="o">=</span> <span class="s2">&quot;Pseudotime &quot;</span> <span class="o">+</span> <span class="n">title</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type_data</span> <span class="o">==</span> <span class="s1">&#39;gene&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gene_exp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">gene_exp</span>
        <span class="n">title_ax1</span> <span class="o">=</span> <span class="n">title</span>
    <span class="k">if</span> <span class="n">reference_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">reference_labels</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">true_label</span>

    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">n_truegroups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">))</span>
    <span class="n">group_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">sorted_col_</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">)))</span>

        <span class="n">group_frac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_groups</span><span class="p">,</span> <span class="n">n_truegroups</span><span class="p">]),</span> <span class="n">columns</span><span class="o">=</span><span class="n">sorted_col_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sorted_col_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">))</span>
        <span class="n">sorted_col_</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">group_frac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_groups</span><span class="p">,</span> <span class="n">n_truegroups</span><span class="p">]),</span> <span class="n">columns</span><span class="o">=</span><span class="n">sorted_col_</span><span class="p">)</span><span class="c1">#list(set(reference_labels))</span>

    <span class="n">via_object</span><span class="o">.</span><span class="n">cluster_population_dict</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="n">set_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">set_labels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">group_i</span> <span class="ow">in</span> <span class="n">set_labels</span><span class="p">:</span>
        <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">group_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">group_pop</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>  <span class="c1"># np.sum(loc_i) / 1000 + 1</span>
        <span class="n">via_object</span><span class="o">.</span><span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>
        <span class="n">true_label_in_group_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">)[</span><span class="n">loc_i</span><span class="p">])</span>
        <span class="n">ll_temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">true_label_in_group_i</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ll_temp</span><span class="p">:</span>
            <span class="n">group_frac</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_label_in_group_i</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>

    <span class="n">line_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_truegroups</span><span class="p">)</span>
    <span class="n">cmap_piechart_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap_piechart</span><span class="p">)</span>
    <span class="n">color_true_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">cmap_piechart_</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">line_true</span><span class="p">]</span><span class="c1"># plt.cm.rainbow(color)</span>


    <span class="n">sct</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                     <span class="n">c</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">group_pop</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_piechart</span><span class="p">)</span>

    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">getbb</span><span class="p">(</span><span class="n">sct</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_viagraph_</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_cluster</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span><span class="p">,</span> <span class="n">CSM</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">CSM</span><span class="p">,</span>
                            <span class="n">velocity_weight</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">headwidth_bundle</span><span class="o">=</span><span class="n">headwidth_arrow</span><span class="p">,</span>
                            <span class="n">alpha_bundle</span><span class="o">=</span><span class="n">alpha_edge</span><span class="p">,</span><span class="n">linewidth_bundle</span><span class="o">=</span><span class="n">linewidth_edge</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">)</span>

    <span class="n">trans</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
    <span class="n">ax_x_min</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ax_x_max</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ax_y_min</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ax_y_max</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ax_len_x</span> <span class="o">=</span> <span class="n">ax_x_max</span> <span class="o">-</span> <span class="n">ax_x_min</span>
    <span class="n">ax_len_y</span> <span class="o">=</span> <span class="n">ax_y_max</span> <span class="o">-</span> <span class="n">ax_y_min</span>
    <span class="n">trans2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">pie_axs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pie_size_ar</span> <span class="o">=</span> <span class="p">((</span><span class="n">group_pop</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">group_pop</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">group_pop</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">group_pop</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>  <span class="c1"># 10</span>

    <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_groups</span><span class="p">):</span>

        <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">majority_true</span> <span class="o">=</span> <span class="n">via_object</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">)[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>
        <span class="n">pie_size</span> <span class="o">=</span> <span class="n">pie_size_ar</span><span class="p">[</span><span class="n">node_i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span><span class="n">pie_size_scale</span>

        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="n">node_i</span><span class="p">])</span>  <span class="c1"># data coordinates</span>
        <span class="n">xa</span><span class="p">,</span> <span class="n">ya</span> <span class="o">=</span> <span class="n">trans2</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>  <span class="c1"># axis coordinates</span>

        <span class="n">xa</span> <span class="o">=</span> <span class="n">ax_x_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">xa</span> <span class="o">-</span> <span class="n">pie_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ax_len_x</span>
        <span class="n">ya</span> <span class="o">=</span> <span class="n">ax_y_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">ya</span> <span class="o">-</span> <span class="n">pie_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ax_len_y</span>
        <span class="c1"># clip, the fruchterman layout sometimes places below figure</span>
        <span class="k">if</span> <span class="n">ya</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ya</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">xa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">xa</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="p">[</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">pie_size</span> <span class="o">*</span> <span class="n">ax_len_x</span><span class="p">,</span> <span class="n">pie_size</span> <span class="o">*</span> <span class="n">ax_len_y</span><span class="p">]</span>
        <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">ff</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">group_frac</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>

        <span class="n">pie_axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">wedgeprops</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span> <span class="n">colors</span><span class="o">=</span><span class="n">color_true_list</span><span class="p">)</span>
        <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="c1"># pie_axs[node_i].text(0.5, 0.5, graph_node_label[node_i])</span>
        <span class="k">if</span> <span class="n">ax_text</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span> <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">majority_true</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="n">fontsize</span> <span class="p">)</span>

    <span class="n">patches</span><span class="p">,</span> <span class="n">texts</span> <span class="o">=</span> <span class="n">pie_axs</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">wedgeprops</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span> <span class="n">colors</span><span class="o">=</span><span class="n">color_true_list</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reference_labels</span><span class="p">))</span>
    <span class="n">labels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">show_legend</span> <span class="o">==</span><span class="kc">True</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">via_object</span><span class="o">.</span><span class="n">time_series</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="s1">&#39;Cluster Composition. K=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. ncomp = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span>  <span class="o">+</span><span class="s1">&#39;knnseq_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">knn_sequential</span><span class="p">)</span><span class="c1"># &quot;+ is_sub</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="s1">&#39;Cluster Composition. K=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. ncomp = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">via_object</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

    <span class="n">title_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">title_ax1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">ax1</span><span class="p">]):</span>
        <span class="c1">#pt = via_object.markov_hitting_times if type_data == &#39;pt&#39; else gene_exp</span>

        <span class="n">c_edge</span><span class="p">,</span> <span class="n">l_width</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">pti</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">via_object</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
                <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">highlight_terminal_clusters</span><span class="p">:</span> <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="n">l_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">gp_scaling</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">group_pop</span><span class="p">)</span>

        <span class="n">group_pop_scale</span> <span class="o">=</span> <span class="n">group_pop</span> <span class="o">*</span> <span class="n">gp_scaling</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">ax_i</span><span class="o">=</span><span class="n">plot_viagraph_</span><span class="p">(</span><span class="n">ax_i</span><span class="p">,</span> <span class="n">via_object</span><span class="o">.</span><span class="n">hammerbundle_cluster</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">graph_node_pos</span><span class="p">,</span><span class="n">CSM</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">CSM</span><span class="p">,</span> <span class="n">velocity_weight</span><span class="o">=</span><span class="n">via_object</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span><span class="n">headwidth_bundle</span><span class="o">=</span><span class="n">headwidth_arrow</span><span class="p">,</span> <span class="n">alpha_bundle</span><span class="o">=</span><span class="n">alpha_edge</span><span class="p">,</span> <span class="n">linewidth_bundle</span><span class="o">=</span><span class="n">linewidth_edge</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">)</span>

        <span class="n">im1</span> <span class="o">=</span> <span class="n">ax_i</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">group_pop_scale</span><span class="o">*</span><span class="n">size_node_notpiechart</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                           <span class="n">edgecolors</span><span class="o">=</span><span class="n">c_edge</span><span class="p">,</span>
                           <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">l_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax_text</span><span class="p">:</span>
            <span class="n">x_max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="n">y_max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>

            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax_i</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_max_range</span><span class="p">,</span> <span class="n">y_max_range</span><span class="p">),</span>
                          <span class="n">node_pos</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max_range</span><span class="p">,</span> <span class="n">y_max_range</span><span class="p">),</span>
                          <span class="s1">&#39;C&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;pop&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">group_pop</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">])),</span>
                          <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax_i</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
    <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">type_data</span> <span class="o">==</span> <span class="s1">&#39;pt&#39;</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pseudotime&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Gene expression&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ax1</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, shobana stassen
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>