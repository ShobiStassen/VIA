<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 5.1.1 and Furo 2023.03.27 -->
        <title>VIA.core - pyvia documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">pyvia  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">pyvia  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">General</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pyVia-home.html">StaVia - Multi-Omic Single-Cell Cartography for Spatial and Temporal Atlases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Release%20History.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorial%20Video.html">VIA Tutorial Videos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Parameters%20and%20Attributes.html">Parameters and Attributes</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api/index.html">API</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/pyVIA%20Core.html">pyVIA core</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Plotting.html">Plotting</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.animate_atlas.html">pyVIA.plotting_via.animate_atlas</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.animate_streamplot.html">pyVIA.plotting_via.animate_streamplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.get_gene_expression.html">pyVIA.plotting_via.get_gene_expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_atlas_view.html">pyVIA.plotting_via.plot_atlas_view</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_differentiation_flow.html">pyVIA.plotting_via.plot_differentiation_flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_gene_trend_heatmaps.html">pyVIA.plotting_via.plot_gene_trend_heatmaps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_piechart_viagraph.html">pyVIA.plotting_via.plot_piechart_viagraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_population_composition.html">pyVIA.plotting_via.plot_population_composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_sc_lineage_probability.html">pyVIA.plotting_via.plot_sc_lineage_probability</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_scatter.html">pyVIA.plotting_via.plot_scatter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_trajectory_curves.html">pyVIA.plotting_via.plot_trajectory_curves</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.plot_viagraph.html">pyVIA.plotting_via.plot_viagraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_streamplot.html">pyVIA.plotting_via.via_streamplot</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Utils.html">Util Functions for plotting</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.make_edgebundle_milestone.html">pyVIA.plotting_via.make_edgebundle_milestone</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_atlas_emb.html">pyVIA.plotting_via.via_atlas_emb</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_forcelayout.html">pyVIA.plotting_via.via_forcelayout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.plotting_via/pyVIA.plotting_via.via_mds.html">pyVIA.plotting_via.via_mds</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/Datasets.html">Datasets</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.cell_cycle_cyto_data.html">datasets_via.cell_cycle_cyto_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.embryoid_body.html">datasets_via.embryoid_body</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.scATAC_hematopoiesis.html">datasets_via.scATAC_hematopoiesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.scRNA_hematopoiesis.html">datasets_via.scRNA_hematopoiesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.toy_disconnected.html">datasets_via.toy_disconnected</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/_autosummary/VIA.datasets_via/datasets_via.toy_multifurcating.html">datasets_via.toy_multifurcating</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Basic%20Example%20Code.html">Examples for installation checking</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Via 2.0 Atlas View Gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Atlas%20view%20examples.html">Via2.0 Atlas views</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Mouse_to_pup_atlas.html">Large Mouse Embryo to Pup Developmental Atlas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Via2%20Atlas%20Animation.html">Via 2.0 Atlas Animations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Via%20Atlas%20View%20for%20Spatial%20omics.html">Via2.0 Atlas views for Spatial Omics data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Via 2.0 Cartography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Via2.0%20Cartographic%20Mouse%20Gastrualation.html">1. Via 2.0 Cartography on Mouse Gastrulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Zebrahub%20TI%20tutorial.html">2. Via 2.0 Cartography on Zebrahub (Trajectory Inference)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Zebrahub_tutorial_visualization.html">3. Via 2.0 Cartography on Zebrahub (Visualization)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials Via</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Toy_Multifurcating.html">1. Basic workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Toy_Disconnected.html">2. Disconnected Trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_scRNA_Hematopoiesis.html">3. Via Human Hematopoiesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Imaging%20Cytometry%20%28cell%20cycle%29.html">4. Imaging cytometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/mESC_timeseries.html">5. Using time-series metadata (mESC Cytof)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_Pancreas_RNAvelocity.html">6. Using RNA-velocity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ViaJupyter_scRNAVelocity_hematopoiesis.html">7. Bone marrow with RNA-velocity</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for VIA.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">csgraph</span><span class="p">,</span> <span class="n">find</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">minimum_spanning_tree</span><span class="p">,</span> <span class="n">connected_components</span>
<span class="kn">import</span> <span class="nn">igraph</span> <span class="k">as</span> <span class="nn">ig</span>
<span class="kn">import</span> <span class="nn">leidenalg</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">hnswlib</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="kn">import</span> <span class="n">get_path_collection_extents</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">pyVIA.plotting_via</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyVIA.utils_via</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyVIA.utils_via</span> <span class="kn">import</span> <span class="n">_construct_knn</span><span class="p">,</span> <span class="n">sequential_knn</span>

<span class="c1">#from plotting_via import *</span>
<span class="c1">#from utils_via import *</span>
<span class="c1">#from utils_via import _construct_knn, sequential_knn</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">pecanpy</span> <span class="kn">import</span> <span class="n">pecanpy</span> <span class="k">as</span> <span class="n">node2vec</span>

<span class="c1">### to upload to pip core via2 file</span>


<span class="k">def</span> <span class="nf">_composite_jacAffinity_distanceAffinity</span><span class="p">(</span><span class="n">sc_csr_graph</span><span class="p">:</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">projected_distances</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    make a composite score for distance based affinity and  jaccard score</span>
<span class="sd">    :param sc_csr_graph: distances based affinities (.data is affinity)</span>
<span class="sd">    :param projected_distances: if using projected distances adjusted based on velocity then provide them</span>
<span class="sd">    :return: igraph of affinities based on Jaccard and distance-based affinities</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">edges_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sc_csr_graph</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()))</span>  <span class="c1"># in the case of time-series, this is the augmented graph</span>
    <span class="c1"># Jaccard computation in igraph does not consider weights. However, doing the global pruning on distance based weights seems less effective than pruning on Jaccard similarities</span>
    <span class="n">jac_edgeweights_list</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges_</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">sc_csr_graph</span><span class="o">.</span><span class="n">data</span><span class="p">})</span><span class="o">.</span><span class="n">similarity_jaccard</span><span class="p">(</span>
        <span class="n">pairs</span><span class="o">=</span><span class="n">edges_</span><span class="p">)</span>

    <span class="c1"># the graph has self loops, so we need to clip these values as they have a jacc of 1, and much higher than other neighbors</span>
    <span class="n">jac_edgeweights_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jac_edgeweights_list</span><span class="p">),</span> <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jac_edgeweights_list</span><span class="p">),</span>
                                                                                       <span class="mi">95</span><span class="p">),</span> <span class="n">a_min</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">projected_distances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">composite_edgeweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">sc_csr_graph</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">jac_edgeweights_list</span><span class="p">))</span>  <span class="c1"># 0&lt;J&lt;1 #combining distance-based affinities and jac-based affinities</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">composite_edgeweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">projected_distances</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">jac_edgeweights_list</span><span class="p">))</span>

    <span class="n">composite_igraph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges_</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">composite_edgeweights</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>  <span class="c1"># used for clustergraph #in the case of time-series, this is the augmented graph</span>

    <span class="k">return</span> <span class="n">composite_igraph</span>


<span class="k">def</span> <span class="nf">_get_loc_terminal_states</span><span class="p">(</span><span class="n">via0</span><span class="p">,</span> <span class="n">X_input</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    we need the location of terminal states from first iteration (Via0) to pass onto the second iterations of Via (Via1)</span>
<span class="sd">    this will allow identification of the terminal-cluster in fine-grained Via1 that best captures the terminal state from coarse Via0</span>

<span class="sd">    :param via0: coarse grained iteration of object class VIA</span>
<span class="sd">    :param X_input: via0.data. the data matrix (PCs) on which the TI is inferred</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">tsi_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># find the single-cell which is nearest to the average-location of a terminal cluster in PCA space</span>
    <span class="k">for</span> <span class="n">tsi</span> <span class="ow">in</span> <span class="n">via0</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
        <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">via0</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">val_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">via0</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>
        <span class="n">th_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">val_pt</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># 50</span>
        <span class="n">loc_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_pt</span><span class="p">))</span> <span class="k">if</span> <span class="n">val_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_pt</span><span class="p">]</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_input</span><span class="p">[</span><span class="n">loc_i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">labelsq</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">via0</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tsi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelsq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tsi_list</span>

<span class="k">def</span> <span class="nf">_prob_reaching_terminal_state</span><span class="p">(</span><span class="n">terminal_state</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                 <span class="n">cumstateChangeHist</span><span class="p">,</span> <span class="n">cumstateChangeHist_all</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="c1"># this function is defined outside the VIA class to enable smooth parallel processing in Windows</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">A</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># ensure probabilities sum to 1 along the rows</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">n_steps</span><span class="p">,</span> <span class="n">count_reach_terminal_state</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">):</span>
        <span class="n">cur_state</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">change_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">change_hist</span><span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">terminal_state_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n_steps</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">terminal_state_found</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="n">P</span><span class="p">[</span><span class="n">cur_state</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">next_state</span> <span class="o">==</span> <span class="n">terminal_state</span><span class="p">:</span>
                <span class="n">terminal_state_found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">change_hist</span><span class="p">[</span><span class="n">cur_state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cur_state</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">terminal_state_found</span><span class="p">:</span>
            <span class="n">cumstateChangeHist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">change_hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">count_reach_terminal_state</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">cumstateChangeHist_all</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">change_hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">cumstateChangeHist_all</span><span class="p">[</span><span class="n">cumstateChangeHist_all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cumstateChangeHist</span><span class="p">,</span> <span class="n">cumstateChangeHist_all</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_rw2_walks</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memory</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">weighted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">implicit_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">num_walks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">p_memory</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
              <span class="n">alpha_teleport</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param A: cluster level transition matrix (forward biased)</span>
<span class="sd">    :param root: root cluster index</span>
<span class="sd">    :param memory: 1/q * edge weight to a next-node that is not a neighbor of previous node. larger number means more memory and more introspective walk. small number &lt;1 means more exploration</span>
<span class="sd">    :param p_memory: 1/p * edge weight to next node = previous node</span>
<span class="sd">    :param weighted: default True edge weights are provided as part of the array A</span>
<span class="sd">    :param walk_length: default None (walk_length = num_nodes *2)</span>
<span class="sd">    :return: implicit_ids</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">pecanpy.graph</span> <span class="kn">import</span> <span class="n">AdjlstGraph</span>
    <span class="c1"># initialize SparseGraph object</span>
    <span class="c1"># g = AdjlstGraph()</span>
    <span class="c1"># setting up the lazy-teleporting behaviour</span>
    <span class="n">n_states</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># print(&#39;row normed P&#39;,P.shape, P, P.sum(axis=1))</span>

    <span class="c1"># bias_P is the transition probability matrix</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">x_lazy</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_lazy</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
    <span class="c1"># print(P, P.sum(axis=1))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">alpha_teleport</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))))</span>

    <span class="kn">from</span> <span class="nn">numba_progress</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
    <span class="n">A_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># csr_matrix(P) #use P if you want to add in the Lazy-teleporting. I find using A directly works a bit better.</span>
    <span class="c1"># print(f&#39;A_csr {A_csr}&#39;)</span>
    <span class="c1"># print(f&#39;A dense {A}&#39;)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">node2vec</span><span class="o">.</span><span class="n">SparseOTF</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p_memory</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">memory</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">extend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># larger q, more memory and introverted search #</span>
    <span class="c1"># using the extend=True which is the node2vec+ implementation from Jan 2023 Renming Liu Bioinformatics paper that differentiates between weakly connected (prev, next) and strongly connected (prev, next)</span>
    <span class="c1"># https://pecanpy.readthedocs.io/en/latest/pecanpy.html</span>
    <span class="n">g</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">A_csr</span><span class="o">.</span><span class="n">indptr</span>  <span class="c1"># [&quot;indptr&quot;].astype(np.uint32)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">A_csr</span><span class="o">.</span><span class="n">indices</span>  <span class="c1"># [&quot;indices&quot;].astype(np.uint32)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">A_csr</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># [&quot;data&quot;].astype(np.float32)</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjacency matrix data not found.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no weights so assign 1 to all edges&#39;</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># overwrite edge weights with constant</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">size</span>
    <span class="n">walk_length</span> <span class="o">=</span> <span class="n">num_nodes</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;g.indptr.size, </span><span class="si">{</span><span class="n">num_nodes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># look deeper at how the node id mapping is done: https://pecanpy.readthedocs.io/en/latest/_modules/pecanpy/graph.html#DenseGraph.read_edg</span>
    <span class="n">g</span><span class="o">.</span><span class="n">set_node_ids</span><span class="p">(</span><span class="n">node_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">implicit_ids</span><span class="o">=</span><span class="n">implicit_ids</span><span class="p">,</span>
                   <span class="n">num_nodes</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># generate random walks, which could then be used to train w2v</span>
    <span class="c1"># walks = g.simulate_walks(num_walks=2, walk_length=3)</span>
    <span class="c1"># https://pecanpy.readthedocs.io/en/latest/_modules/pecanpy/pecanpy.html#Base.simulate_walks</span>
    <span class="n">g</span><span class="o">.</span><span class="n">_preprocess_transition_probs</span><span class="p">()</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">root</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>  <span class="c1"># range(g.num_nodes</span>
    <span class="c1"># print(f&#39;nodes {range(g.num_nodes)} and nodes {nodes}&#39;)</span>
    <span class="n">start_node_idx_ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">nodes</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_walks</span><span class="p">)</span>  <span class="c1"># root&lt;=&gt; nodes</span>
    <span class="c1"># print(f&#39;start_node_array {start_node_idx_ary}&#39;)</span>
    <span class="n">tot_num_jobs</span> <span class="o">=</span> <span class="n">start_node_idx_ary</span><span class="o">.</span><span class="n">size</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_state</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">start_node_idx_ary</span><span class="p">)</span>  <span class="c1"># for balanced work load</span>

    <span class="n">move_forward</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_move_forward</span><span class="p">()</span>
    <span class="n">has_nbrs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_has_nbrs</span><span class="p">()</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">verbose</span>

    <span class="c1"># Acquire numba progress proxy for displaying the progress bar</span>
    <span class="k">with</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">tot_num_jobs</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">walk_idx_mat</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_random_walks</span><span class="p">(</span>
            <span class="n">tot_num_jobs</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="p">,</span>
            <span class="n">random_state</span><span class="p">,</span>
            <span class="n">start_node_idx_ary</span><span class="p">,</span>
            <span class="n">has_nbrs</span><span class="p">,</span>
            <span class="n">move_forward</span><span class="p">,</span>
            <span class="n">progress</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># print(f&#39;walk mat {walk_idx_mat}&#39;)</span>
    <span class="c1"># Map node index back to node ID</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">_map_walk</span><span class="p">(</span><span class="n">walk_idx_ary</span><span class="p">)</span> <span class="k">for</span> <span class="n">walk_idx_ary</span> <span class="ow">in</span> <span class="n">walk_idx_mat</span><span class="p">]</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">walks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># print(f&#39;via walks and shape of n_walks x n_steps {walks.shape}&#39;) #ndarray n_walks x n_steps</span>

    <span class="c1"># emd = g.embed(num_walks=5, walk_length=num_nodes*2)</span>
    <span class="c1"># print(f&#39;emd {emd.shape} {emd}&#39;)</span>
    <span class="k">return</span> <span class="n">walks</span>


<span class="k">def</span> <span class="nf">_compute_rw2_lineageprobability</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memory</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">p_memory</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                                   <span class="n">num_walks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">terminal_states</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
                                   <span class="n">alpha_teleport</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;testing rw2 lineage probability at memory </span><span class="si">{</span><span class="n">memory</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">n_states</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_terminal_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">terminal_states</span><span class="p">)</span>
    <span class="n">ts_index_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prob_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_terminal_states</span><span class="p">))</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="n">_rw2_walks</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">p_memory</span><span class="o">=</span><span class="n">p_memory</span><span class="p">,</span> <span class="n">x_lazy</span><span class="o">=</span><span class="n">x_lazy</span><span class="p">,</span>
                      <span class="n">alpha_teleport</span><span class="o">=</span><span class="n">alpha_teleport</span><span class="p">)</span>

    <span class="c1"># if n_steps is None: n_steps = 2 * n_states</span>
    <span class="n">n_steps</span> <span class="o">=</span> <span class="n">walks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">terminal_state</span> <span class="ow">in</span> <span class="n">terminal_states</span><span class="p">:</span>

        <span class="n">cumstateChangeHist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="n">cumstateChangeHist_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="n">terminal_state_found_inAllWalks</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">count_reached_bool</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count_reach_terminal_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">walks</span><span class="p">:</span>
            <span class="n">change_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
            <span class="n">change_hist</span><span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># print(f&#39;walk {row}&#39;)</span>
            <span class="n">terminal_state_found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n_steps</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">terminal_state_found</span><span class="p">:</span>
                <span class="n">cur_state</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="n">next_state</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">next_state</span> <span class="o">==</span> <span class="n">terminal_state</span><span class="p">:</span>
                    <span class="n">terminal_state_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">count_reached_bool</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">change_hist</span><span class="p">[</span><span class="n">cur_state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">terminal_state_found</span><span class="p">:</span>
                <span class="n">cumstateChangeHist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">change_hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">count_reach_terminal_state</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cumstateChangeHist_all</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">change_hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print(f&#39;count reached bool {count_reached_bool}&#39;)</span>
        <span class="n">cumstateChangeHist_all</span><span class="p">[</span>
            <span class="n">cumstateChangeHist_all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># to avoid division by zero we say that the state has been visited once</span>
        <span class="n">count_reached</span> <span class="o">=</span> <span class="n">cumstateChangeHist_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">]</span>
        <span class="c1"># print(f&#39;terminal state HistAll {terminal_state} is reached {count_reached} times&#39;)</span>
        <span class="n">count_reached</span> <span class="o">=</span> <span class="n">cumstateChangeHist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">]</span>
        <span class="c1"># print(f&#39;terminal state {terminal_state} is reached {count_reached} times&#39;)</span>
        <span class="c1"># print( f&quot;{datetime.now()}\tFrom root {root},  TS {terminal_state} is reached {int(count_reached)} times.&quot;)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">prob_</span> <span class="o">=</span> <span class="n">cumstateChangeHist</span> <span class="o">/</span> <span class="n">cumstateChangeHist_all</span>
        <span class="c1"># print(f&#39;cumstatechangeHist {cumstateChangeHist}&#39;)</span>
        <span class="c1"># print(f&#39;cumstatechangeHist_all {cumstateChangeHist_all}&#39;)</span>
        <span class="c1"># print(f&#39;prob_ pre scaling {prob_}&#39;)</span>
        <span class="c1"># given a cluster is traversed (cumhistory_vec_all), how many of these traversals led to a successful path to Terminal State X</span>
        <span class="c1"># i.e. with what probability does traversal of a cluster lead to the desired terminal state (number of times traversed along a sucessful path)  #cumhistory_vec: number of times cluster is traversed on a successful path</span>

        <span class="k">if</span> <span class="n">count_reached</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prob_</span><span class="p">[:,</span> <span class="n">terminal_state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">terminal_state</span><span class="si">}</span><span class="s1"> cluster/state is never reached. try increase number of KNN (which will increase number of edges) or try to increase the value of jac_std_global and cluster_graph_pruning which will lower edge pruning&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">prob_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">loc_1</span> <span class="o">=</span> <span class="n">loc_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">prob_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc_1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># print(&#39;zerod out prob&#39;, prob_)</span>
            <span class="n">temp_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">prob_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">temp_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">temp_</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">prob_</span> <span class="o">=</span> <span class="n">prob_</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                                <span class="mf">1.1</span> <span class="o">*</span> <span class="n">temp_</span><span class="p">)</span>  <span class="c1"># do some scaling to amplify the probabiltiies of those clusters that are not 1 to make the range of values more compact</span>
            <span class="n">prob_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc_1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># put back probability =1</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1"> Cluster or terminal cell fate </span><span class="si">{</span><span class="n">terminal_state</span><span class="si">}</span><span class="s1"> is reached </span><span class="si">{</span><span class="n">count_reached</span><span class="si">}</span><span class="s1"> times&#39;</span><span class="p">)</span>  <span class="c1"># {prob_}</span>
        <span class="n">prob_mat</span><span class="p">[:,</span> <span class="n">ts_index_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_</span>
        <span class="n">ts_index_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">prob_mat</span>


<span class="k">def</span> <span class="nf">_compute_rw2_hittingtimes</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memory</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1300</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
                             <span class="n">alpha_teleport</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param walks: ndarray walks of shape n_walks x n_steps</span>
<span class="sd">    :param A: ndarray of clustergraph (values are edge weights, higher means stronger edge)</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># from scipy.sparse import csc_matrix</span>
    <span class="c1"># A_csr = csr_matrix(A)</span>
    <span class="c1"># print(f&#39;cluster graph A&#39;, A)</span>
    <span class="c1"># generate ndarray of walks (n_walks x n_steps+1)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;start computing walks with rw2 method&#39;</span><span class="p">)</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="n">_rw2_walks</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">x_lazy</span><span class="o">=</span><span class="n">x_lazy</span><span class="p">,</span> <span class="n">alpha_teleport</span><span class="o">=</span><span class="n">alpha_teleport</span><span class="p">)</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_walks</span> <span class="o">=</span> <span class="n">walks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">walk_length</span> <span class="o">=</span> <span class="n">walks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                      <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># (the first element in the walk is the root, so the walks array has n_steps + 1 element</span>
    <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">))</span>

    <span class="n">walk_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">walk_i</span> <span class="ow">in</span> <span class="n">walks</span><span class="p">:</span>
        <span class="n">walk_i_dist_cumulative</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(f&#39;walk_i {walk_i}&#39;)</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">walk_length</span><span class="p">):</span>
            <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">walk_i</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">walk_i</span><span class="p">[</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># print(f&#39;edge weight {edge_weight}&#39;)</span>
            <span class="n">edge_distance</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">edge_weight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># convert to distance</span>
            <span class="n">walk_i_dist_cumulative</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walk_i_dist_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge_distance</span><span class="p">)</span>
            <span class="c1"># print(f&#39;edge distance&#39;,edge_distance)</span>
            <span class="c1"># print(f&#39;cumulative walk {walk_i_dist_cumulative}&#39;)</span>
        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
            <span class="c1"># print(f&#39;node {node_i}&#39;)</span>
            <span class="n">first_time_at_statei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">walk_i</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_time_at_statei</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">hitting_array</span><span class="p">[</span><span class="n">node_i</span><span class="p">,</span> <span class="n">walk_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">walk_length</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print(f&#39;first time hitting node {node_i} is {first_time_at_statei[0]}&#39;)</span>
                <span class="n">hitting_array</span><span class="p">[</span><span class="n">node_i</span><span class="p">,</span> <span class="n">walk_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">walk_i_dist_cumulative</span><span class="p">[</span><span class="n">first_time_at_statei</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">walk_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># print(f&#39;hitting_array {hitting_array}&#39;)</span>

    <span class="c1"># extract relevant hitting times</span>
    <span class="n">hitting_array_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">))</span>
    <span class="n">no_times_state_reached_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="n">rowtemp</span> <span class="o">=</span> <span class="n">hitting_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">no_times_state_reached_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">walk_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="n">rowtemp</span> <span class="o">=</span> <span class="n">hitting_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">no_times_state_reached</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">walk_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">no_times_state_reached</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">rowtemp</span><span class="p">[</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="n">walk_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.001</span>  <span class="c1"># 15 for Human and Toy</span>
            <span class="c1"># print(&#39;state &#39;, i,&#39; has perc&#39; ,perc)</span>
            <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rowtemp</span><span class="p">[</span><span class="n">rowtemp</span> <span class="o">&lt;=</span> <span class="n">perc</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">walk_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_simulate_markov_sub</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">num_sim</span><span class="p">,</span> <span class="n">hitting_array</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="c1"># sub process that actually does the mcmcs</span>
    <span class="n">n_states</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">hitting_array_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">n_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="n">currentState</span> <span class="o">=</span> <span class="n">root</span>

    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">currentState</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">state_root</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sim</span><span class="p">):</span>
        <span class="n">dist_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state_root</span>
        <span class="n">currentState</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">stateHist</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">nextState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="n">P</span><span class="p">[</span><span class="n">currentState</span><span class="p">])</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">currentState</span><span class="p">,</span> <span class="n">nextState</span><span class="p">]</span>
            <span class="n">dist_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
            <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nextState</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">currentState</span> <span class="o">=</span> <span class="n">nextState</span>
            <span class="c1"># Keep track of state history</span>
            <span class="n">stateHist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stateHist</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">first_time_at_statei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stateHist</span><span class="p">[:,</span> <span class="n">state_i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_time_at_statei</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">hitting_array_temp</span><span class="p">[</span><span class="n">state_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total_dist</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_time_at_statei</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist_list</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">+</span> <span class="n">total_dist</span>

                <span class="n">hitting_array_temp</span><span class="p">[</span><span class="n">state_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_dist</span>  <span class="c1"># first_time_at_statei[0]</span>
        <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hitting_array</span><span class="p">,</span> <span class="n">hitting_array_temp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">hitting_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hitting_array</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_biased_weights</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># small nu means less forward biasing (0.5 is quite mild)</span>
    <span class="c1"># larger nu (in our case 1/nu) means more aggressive forwards biasing https://en.wikipedia.org/wiki/Generalised_logistic_function</span>

    <span class="c1"># using the pseudotime calculated from lazy-jumping walk. Otherwise using the refined MCMC Psuedotimes before</span>
    <span class="c1"># calculating lineage likelihood paths</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">round</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">20</span>

    <span class="n">weights_thr</span><span class="p">,</span> <span class="n">pct_thr</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">loc_high_pt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pt</span> <span class="o">&gt;</span> <span class="n">pct_thr</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weights</span> <span class="o">&gt;</span> <span class="n">weights_thr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">loc_high_pt</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">loc_high_pt</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">weights</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">weights</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>

    <span class="n">bias_weight</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">nu</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">t_ab</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">bias_weight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_ab</span> <span class="o">+</span> <span class="n">c</span><span class="p">)))</span> <span class="o">**</span> <span class="n">nu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bias_weight</span>


<span class="k">def</span> <span class="nf">expected_num_steps</span><span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="n">start_i</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">absorption_probability</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">absorption_state_j</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">[:,</span> <span class="n">absorption_state_j</span><span class="p">]</span>


<div class="viewcode-block" id="VIA"><a class="viewcode-back" href="../../api/pyVIA%20Core.html#VIA.core.VIA">[docs]</a><span class="k">class</span> <span class="nc">VIA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    A class to represent the VIA analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data: ndarray</span>
<span class="sd">        input matrix of size n_cells x n_dims. Expects the PCs or features that will be used in the TI computation. Can be e.g. adata.obsm[&#39;X_pca][:,0:20]</span>
<span class="sd">    true_label:list</span>
<span class="sd">        list of str/int that correspond to the ground truth or reference annotations. Can also be None when no labels are available</span>
<span class="sd">    labels: ndarray (nsamples, )</span>
<span class="sd">        default is None. and PARC clusters are used for the viagraph. alternatively provide a list of clustermemberships that are integer values (not strings) to construct the viagraph using another clustering method or available annotations</span>
<span class="sd">    edgepruning_clustering_resolution_local:float</span>
<span class="sd">        default = 2</span>
<span class="sd">        local level of pruning for PARC graph clustering stage. Range (0.1,3) higher numbers mean more edge retention. For large datasets can stick to just tuning edgepruning_clustering_resolution</span>
<span class="sd">    edgepruning_clustering_resolution: float</span>
<span class="sd">        (optional, default = 0.15, can also set as &#39;median&#39;) graph pruning for PARC clustering stage. Higher value keeps more edges, results in fewer clusters. Smaller value removes more edges and results in more clusters. Number of standard deviations below the networks mean-jaccard-weighted edges. 0.1-1 provide reasonable pruning.</span>
<span class="sd">        higher value means less pruning (more edges retained). e.g. a value of 0.15 means all edges that are above mean(edgeweight)-0.15*std(edge-weights) are retained.</span>
<span class="sd">        We find both 0.15 and median to yield good results/starting point and resulting in pruning away ~ 50-60% edges</span>
<span class="sd">    keep_all_local_dist: bool, str</span>
<span class="sd">        default value of &#39;auto&#39; means that for smaller datasets local-pruning is done prior to clustering, but for large datasets local pruning is set to False for speed.</span>
<span class="sd">        can also set to be bool of True or False</span>
<span class="sd">    too_big_factor: float</span>
<span class="sd">        (optional, default=0.4). Forces clusters &gt; 0.4*n_cells to be re-clustered</span>
<span class="sd">    resolution_parameter: float</span>
<span class="sd">        (default =1) larger value means more and smaller clusters</span>
<span class="sd">    partition_type:str</span>
<span class="sd">        (default &quot;ModularityVP&quot;) Options</span>
<span class="sd">    small_pop: int</span>
<span class="sd">         (default 10) Via attempts to merge Clusters with a population &lt; 10 cells with larger clusters. If you have a very small dataset (e.g. few hundred cells), then consider lowering to e.g. 5</span>
<span class="sd">    jac_weighted_edges:bool</span>
<span class="sd">        (default = True) Use weighted edges in the PARC clustering step</span>
<span class="sd">    knn: int</span>
<span class="sd">        (optional, default = 30) number of K-Nearest Neighbors for HNSWlib KNN graph. Larger knn means more graph connectivity. Lower knn means more loosely connected clusters/cells</span>
<span class="sd">    n_iter_leiden:int</span>
<span class="sd">    random_seed: int</span>
<span class="sd">        Random seed to pass to clustering</span>
<span class="sd">    num_threads:</span>
<span class="sd">    distance:str</span>
<span class="sd">        (default &#39;l2&#39;) Euclidean distance &#39;l2&#39; by default; other options &#39;ip&#39; and &#39;cosine&#39; for graph construction and similarity</span>
<span class="sd">    visual_cluster_graph_pruning: float</span>
<span class="sd">        (optional, default = 0.15) This only comes into play if the user deliberately chooses not to use the default edge-bundling method of visualizating edges (draw_piechart_graph()) and instead calls draw_piechart_graph_nobundle().</span>
<span class="sd">        It is often set to the same value as the PARC clustering level of edgepruning_clustering_resolution. This does not impact computation of terminal states, pseudotime or lineage likelihoods.</span>
<span class="sd">        It controls the number of edges plotted for visual effect</span>
<span class="sd">    cluster_graph_pruning: float</span>
<span class="sd">        (optional, default =0.15) Pruning level of the cluster graph (does not impact number of clusters). Only impacts the connectivity of the clustergraph. Often set to the same value as the PARC clustering level of edgepruning_clustering_resolution.Reasonable range [0.1,1]</span>
<span class="sd">        To retain more connectivity in the clustergraph underlying the trajectory computations, increase the value</span>
<span class="sd">    time_smallpop: max time to be allowed handling singletons</span>

<span class="sd">    x_lazy:float</span>
<span class="sd">        (default =0.95) 1-x = probability of staying in same node (lazy). Values between 0.9-0.99 are reasonable</span>
<span class="sd">    alpha_teleport: float</span>
<span class="sd">        (default = 0.99) 1-alpha is probability of jumping. Values between 0.95-0.99 are reasonable unless prior knowledge of teleportation</span>
<span class="sd">    root_user: list, None</span>
<span class="sd">        can be a list of strings, a list of int or None</span>
<span class="sd">        (default is None) When the root_user is set as None and an RNA velocity matrix is available, a root will be automatically computed</span>
<span class="sd">        if the root_user is None and not velocity matrix is provided, then an arbitrary root is selected</span>
<span class="sd">        if the root_user is [&#39;celltype_earlystage&#39;] where the str corresponds to an item in true_label, then a suitable starting point will be selected corresponding to this group</span>
<span class="sd">        if the root_user is [678], where 678 is the index of the cell chosen as a start cell, then this will be the designated starting cell.</span>
<span class="sd">        It is possible to give a list of root indices and groups. [120, 699] or [&#39;traj1_earlystage&#39;, &#39;traj2_earlystage&#39;] when there are more than one trajectories</span>
<span class="sd">    preserve_disconnected: bool</span>
<span class="sd">        (default = True) If you believe there may be disconnected trajectories then set this to False</span>
<span class="sd">    dataset: str</span>
<span class="sd">        Can be set to &#39;group&#39; or &#39;&#39; (default). this refers to the type of root label (group level root or single cell index) you are going to provide.</span>
<span class="sd">        if your true_label has a sensible group of cells for a root then you can set dataset to &#39;group&#39; and make the root parameter [&#39;labelname_root_cell_type&#39;]</span>
<span class="sd">        if your root corresponds to one particular cell then set dataset = &#39;&#39; (default)</span>
<span class="sd">    embedding: ndarray</span>
<span class="sd">        (optional, default = None) embedding (e.g. precomputed tsne, umap, phate, via-umap) for plotting data. Size n_cells x 2</span>
<span class="sd">        If an embedding is provided when running VIA, then a scatterplot colored by pseudotime, highlighting terminal fates</span>
<span class="sd">    velo_weight: float</span>
<span class="sd">        (optional, default = 0.5) #float between [0,1]. the weight assigned to directionality and connectivity derived from scRNA-velocity</span>
<span class="sd">    neighboring_terminal_states_threshold:int</span>
<span class="sd">        (default = 3). Candidates for terminal states that are neighbors of each other may be removed from the list if they have this number of more of terminal states as neighbors</span>
<span class="sd">    knn_sequential:int</span>
<span class="sd">        (default =10) number of knn in the adjacent time-point for time-series data (t_i and t_i+1)</span>
<span class="sd">    knn_sequential_reverse: int</span>
<span class="sd">        (default = 0) number of knn enforced from current to previous time point</span>
<span class="sd">    t_diff_step: int</span>
<span class="sd">        (default =1) Number of permitted temporal intervals between connected nodes. If time data is labeled as [0,25,50,75,100,..]</span>
<span class="sd">        then t_diff_step=1 corresponds to &#39;25&#39; and only edges within t_diff_steps are retained</span>
<span class="sd">    is_coarse:bool</span>
<span class="sd">        (default = True) If running VIA in two iterations where you wish to link the second fine-grained iteration with the initial iteration, then you set to False</span>
<span class="sd">    via_coarse: VIA</span>
<span class="sd">        (default = None) If instantiating a second iteration of VIA that needs to be linked to a previous iteration (e.g. via0), then set via_coarse to the previous via0 object</span>
<span class="sd">    df_annot: DataFrame</span>
<span class="sd">        (default None) used for the Mouse Organ data</span>
<span class="sd">    preserve_disconnected_after_pruning:bool</span>
<span class="sd">        (default = False) If you believe there are disconnected trajectories then set this to True and test your hypothesis</span>
<span class="sd">    A_velo: ndarray</span>
<span class="sd">        Cluster Graph Transition matrix based on rna velocity [n_clus x n_clus]</span>
<span class="sd">    velocity_matrix: matrix</span>
<span class="sd">            (default None) matrix of size [n_samples x n_genes]. this is the velocity matrix computed by scVelo (or similar package) and stored in adata.layers[&#39;velocity&#39;]. The genes used for computing velocity should correspond to those useing in gene_matrix</span>
<span class="sd">            Requires gene_matrix to be provided too.</span>
<span class="sd">    gene_matrix: matrix</span>
<span class="sd">            (default None) Only used if Velocity_matrix is available. matrix of size [n_samples x n_genes]. We recommend using a subset like HVGs rather than full set of genes. (need to densify input if taking from adata = adata.X.todense())</span>
<span class="sd">    time_series:bool</span>
<span class="sd">        (default False) if the data has time-series labels then set to True</span>
<span class="sd">    time_series_labels:list</span>
<span class="sd">        (default None) list of integer values of temporal annoataions corresponding to e.g. hours (post fert), days, or sequential ordering</span>
<span class="sd">    pca_loadings: array</span>
<span class="sd">        (default None) the loadings of the pcs used to project the cells (to projected euclidean location based on velocity). n_cells x n_pcs</span>
<span class="sd">    secondary_annotations: None</span>
<span class="sd">        (default None)</span>
<span class="sd">    edgebundle_pruning:float</span>
<span class="sd">        (default=None) will by default be set to the same as the cluster_graph_pruning and influences the visualized level of pruning of edges.</span>
<span class="sd">        Typical values can be between [0,1] with higher numbers retaining more edges</span>
<span class="sd">    edgebundle_pruning_twice:bool</span>
<span class="sd">        default: False. When True, the edgebundling is applied to a further visually pruned (visual_cluster_graph_pruning) and can sometimes simplify the visualization. it does not impact the pseudotime and lineage computations</span>
<span class="sd">     piegraph_arrow_head_width: float</span>
<span class="sd">        (default = 0.1) size of arrow heads in via cluster graph</span>
<span class="sd">    piegraph_edgeweight_scalingfactor:</span>
<span class="sd">        (defaulf = 1.5) scaling factor for edge thickness in via cluster graph</span>
<span class="sd">    max_visual_outgoing_edges: int</span>
<span class="sd">        (default =2) Only allows max_visual_outgoing_edges to come out of any given node. Used in differentiation_flow()</span>

<span class="sd">    edgebundle_pruning:float</span>
<span class="sd">        (default=None) will by default be set to the same as the cluster_graph_pruning and influences the visualized level of pruning of edges.</span>
<span class="sd">        Typical values can be between [0,1] with higher numbers retaining more edges</span>

<span class="sd">    edgebundle_pruning_twice:bool</span>
<span class="sd">        default: False. When True, the edgebundling is applied to a further visually pruned (visual_cluster_graph_pruning) and can sometimes simplify the visualization for very cluttered graphs. it does not impact the pseudotime and lineage computations</span>
<span class="sd">    pseudotime_threshold_TS: int</span>
<span class="sd">        (default = 30) corresponds to the criteria for a state to be considered a candidate terminal cell fate to be 30% or later of the computed psuedotime range</span>
<span class="sd">    num_mcmc_simulations:int</span>
<span class="sd">        (default = 1300) number of random walk simulations conducted</span>
<span class="sd">    embedding_type: str</span>
<span class="sd">        (default = &#39;via-mds&#39;, other options are &#39;via-atlas&#39; and &#39;via-force&#39;</span>
<span class="sd">    do_compute_embedding: bool</span>
<span class="sd">        (default = False) If you want an embedding (n_samples x2) to be computed on the basis of the via sc graph then set this to True</span>
<span class="sd">    do_gaussian_kernel_edgeweights: bool</span>
<span class="sd">        (default = False) Type of edgeweighting on the graph edges</span>
<span class="sd">    memory: float</span>
<span class="sd">        (default = 2) higher q means more memory, more retrospective/inwards randomwalk. memory = 2 means run using the non-memory Via 1.0 mode</span>
<span class="sd">    viagraph_decay: float</span>
<span class="sd">        (default = 0.9) increasing decay causes more edges to merge</span>
<span class="sd">    memory: 1/q * edge weight to a next-node that is not a neighbor of previous node. larger number means more memory and more introspective walk. small number &lt;1 means more exploration</span>
<span class="sd">    p_memory: 1/p * edge weight to next node = previous node. large value means more exploration</span>

<span class="sd">    Attributes</span>
<span class="sd">    ------------</span>
<span class="sd">    labels: array</span>
<span class="sd">        length (n_samples, ) of cluster labels ndarray pre determined cluster labels user defined. #np.asarray(pre_labels).flatten()</span>
<span class="sd">    single_cell_pt_markov: list</span>
<span class="sd">        length n_samples of pseudotime</span>
<span class="sd">    single_cell_bp: ndarray</span>
<span class="sd">        [n_lineages x n_samples] array of single cell branching probabilities towards each lineage (lineage normalized).</span>
<span class="sd">        Each column corresponds to a terminal state, in the order presented by the terminal_clusters attribute</span>
<span class="sd">    single_cell_bp_rownormed: ndarray</span>
<span class="sd">        [n_lineages x n_samples] array of single cell branching probabilities towards each lineage (cell normalized).</span>
<span class="sd">        Each column corresponds to a terminal state, in the order presented by the terminal_clusters attribute</span>
<span class="sd">    terminal_clusters: list</span>
<span class="sd">        list of clusters that are cell fates/ unique lineages</span>
<span class="sd">    cluster_bp: ndarray</span>
<span class="sd">        [n_clusters x n_terminal_states]. Lineage probability of cluster towards a particular terminal cluster state</span>
<span class="sd">    CSM: ndarray</span>
<span class="sd">        [n_cluster x n_clusters] array of cosine similarity used to weight the cluster graph transition matrix by velocity</span>
<span class="sd">    single_cell_transition_matrix: ndarray</span>
<span class="sd">        [n_samples x n_samples]</span>
<span class="sd">    terminal_clusters:list</span>
<span class="sd">        (default None) list of terminal clusters</span>
<span class="sd">    csr_full_graph: csr matrix of single-cell graph (augmented with sequential data when providing time_series information)</span>
<span class="sd">    csr_array_locally_pruned: csr matrix</span>
<span class="sd">    ig_full_graph:</span>
<span class="sd">    full_neighbor_array:</span>
<span class="sd">    user_defined_terminal_cell:list=[]</span>
<span class="sd">    user_defined_terminal_group:list=[]</span>
<span class="sd">    n_milestones: int = None Number of milestones in the via-mds computation (anything more than 10,000 can be computationally heavy and time consuming) Typically auto-determined within the via-mds function</span>
<span class="sd">    embedding: ndarray</span>
<span class="sd">        [n_cells x 2] provided by user or autocomputed with via-mds or via-umap</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">true_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgepruning_clustering_resolution_local</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">edgepruning_clustering_resolution</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>
                 <span class="n">labels</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">keep_all_local_dist</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">too_big_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">resolution_parameter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">partition_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ModularityVP&quot;</span><span class="p">,</span> <span class="n">small_pop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">jac_weighted_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">knn</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">n_iter_leiden</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
                 <span class="n">num_threads</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">time_smallpop</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                 <span class="n">super_cluster_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">super_node_degree_list</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">super_terminal_cells</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span> <span class="n">alpha_teleport</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
                 <span class="n">root_user</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preserve_disconnected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="n">super_terminal_clusters</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
                 <span class="n">is_coarse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">csr_full_graph</span><span class="p">:</span> <span class="n">csr_matrix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">csr_array_locally_pruned</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ig_full_graph</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="n">full_neighbor_array</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">full_distance_array</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">df_annot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">preserve_disconnected_after_pruning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">secondary_annotations</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pseudotime_threshold_TS</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
                 <span class="n">cluster_graph_pruning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
                 <span class="n">visual_cluster_graph_pruning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span> <span class="n">neighboring_terminal_states_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">num_mcmc_simulations</span><span class="o">=</span><span class="mi">1300</span><span class="p">,</span>
                 <span class="n">piegraph_arrow_head_width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">piegraph_edgeweight_scalingfactor</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">max_visual_outgoing_edges</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">via_coarse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">velocity_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gene_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velo_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">edgebundle_pruning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A_velo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">CSM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">edgebundle_pruning_twice</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pca_loadings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_series</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">time_series_labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">knn_sequential</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">knn_sequential_reverse</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">t_diff_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">single_cell_transition_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">embedding_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;via-mds&#39;</span><span class="p">,</span> <span class="n">do_compute_embedding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">color_dict</span><span class="p">:</span> <span class="p">{}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">user_defined_terminal_cell</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">user_defined_terminal_group</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
                 <span class="n">do_gaussian_kernel_edgeweights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">RW2_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">working_dir_fp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/home/&#39;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">viagraph_decay</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">p_memory</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">true_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span> <span class="o">=</span> <span class="n">true_label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
        <span class="k">if</span> <span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">velo_weight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span> <span class="o">=</span> <span class="n">velo_weight</span>  <span class="c1"># float between 0,1. the weight assigned to directionality and connectivity derived from scRNA-velocity</span>
        <span class="k">if</span> <span class="n">edgebundle_pruning</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">edgebundle_pruning</span> <span class="o">=</span> <span class="n">cluster_graph_pruning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning</span> <span class="o">=</span> <span class="n">edgebundle_pruning</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root_user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">root_user</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_user</span> <span class="o">=</span> <span class="n">root_user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>  <span class="c1"># np.asarray(pre_labels).flatten() where pre_labels is a list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_comp_labels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgelist_unique</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># higher edgepruning_clustering_resolution_local means more edges are kept</span>
        <span class="c1"># higher edgepruning_clustering_resolution means more edges are kept</span>
        <span class="k">if</span> <span class="n">keep_all_local_dist</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># If large dataset skip local pruning to increase speed</span>
            <span class="n">keep_all_local_dist</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">50000</span>

        <span class="k">if</span> <span class="n">resolution_parameter</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">partition_type</span> <span class="o">=</span> <span class="s2">&quot;RBVP&quot;</span>  <span class="c1"># Reichardt and Bornholdts Potts model. Note that this is the same as ModularityVertexPartition when setting  = 1 and normalising by 2m</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution_local</span> <span class="o">=</span> <span class="n">edgepruning_clustering_resolution_local</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span> <span class="o">=</span> <span class="n">edgepruning_clustering_resolution</span>  <span class="c1">##0.15 is also a recommended value performing empirically similar to &#39;median&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_all_local_dist</span> <span class="o">=</span> <span class="n">keep_all_local_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">too_big_factor</span> <span class="o">=</span> <span class="n">too_big_factor</span>  <span class="c1">##if a cluster exceeds this share of the entire cell population, then the PARC will be run on the large cluster. at 0.4 it does not come into play</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution_parameter</span> <span class="o">=</span> <span class="n">resolution_parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partition_type</span> <span class="o">=</span> <span class="n">partition_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">small_pop</span> <span class="o">=</span> <span class="n">small_pop</span>  <span class="c1"># smallest cluster population to be considered a community</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jac_weighted_edges</span> <span class="o">=</span> <span class="n">jac_weighted_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">=</span> <span class="n">knn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential</span> <span class="o">=</span> <span class="n">knn_sequential</span>  <span class="c1"># number of knn in the adjacent time-point for time-series data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential_reverse</span> <span class="o">=</span> <span class="n">knn_sequential_reverse</span>  <span class="c1"># number of knn made between timepoint and previous time point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span> <span class="o">=</span> <span class="n">n_iter_leiden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>  <span class="c1"># enable reproducible Leiden clustering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>  <span class="c1"># number of threads used in KNN search/construction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>  <span class="c1"># Euclidean distance &#39;l2&#39; by default; other options &#39;ip&#39; and &#39;cosine&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_smallpop</span> <span class="o">=</span> <span class="n">time_smallpop</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">super_cluster_labels</span> <span class="o">=</span> <span class="n">super_cluster_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_node_degree_list</span> <span class="o">=</span> <span class="n">super_node_degree_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_terminal_clusters</span> <span class="o">=</span> <span class="n">super_terminal_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_neighbor_array</span> <span class="o">=</span> <span class="n">full_neighbor_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_array</span> <span class="o">=</span> <span class="n">full_distance_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ig_full_graph</span> <span class="o">=</span> <span class="n">ig_full_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned</span> <span class="o">=</span> <span class="n">csr_array_locally_pruned</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span> <span class="o">=</span> <span class="n">csr_full_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_terminal_cells</span> <span class="o">=</span> <span class="n">super_terminal_cells</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">x_lazy</span> <span class="o">=</span> <span class="n">x_lazy</span>  <span class="c1"># 1-x = probability of staying in same node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_teleport</span> <span class="o">=</span> <span class="n">alpha_teleport</span>  <span class="c1"># 1-alpha is probability of jumping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected</span> <span class="o">=</span> <span class="n">preserve_disconnected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_coarse</span> <span class="o">=</span> <span class="n">is_coarse</span>  <span class="c1"># set to True for first round of VIA. if one chooses to run a second iteration of VIA that uses the terminal states from the first round, then set this to False for second iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_annot</span> <span class="o">=</span> <span class="n">df_annot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected_after_pruning</span> <span class="o">=</span> <span class="n">preserve_disconnected_after_pruning</span>  <span class="c1"># pruning can cause some fragmentation of small clusters, these should be reattached to the relevant component (so typically this is False as we dont want to preserve these small extra components resulting from pruning)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_annotations</span> <span class="o">=</span> <span class="n">secondary_annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_threshold_TS</span> <span class="o">=</span> <span class="n">pseudotime_threshold_TS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_graph_pruning</span> <span class="o">=</span> <span class="n">cluster_graph_pruning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visual_cluster_graph_pruning</span> <span class="o">=</span> <span class="n">visual_cluster_graph_pruning</span>  <span class="c1"># higher value means more edges retained. This is applied to the clustergraph before visulizing only if two rounds of edgbebundlng is done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighboring_terminal_states_threshold</span> <span class="o">=</span> <span class="n">neighboring_terminal_states_threshold</span>  <span class="c1"># number of neighbors of a terminal state has before it is eliminated as a TS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_mcmc_simulations</span> <span class="o">=</span> <span class="n">num_mcmc_simulations</span>  <span class="c1"># number of mcmc simulations in second state of pseudotime computation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">piegraph_arrow_head_width</span> <span class="o">=</span> <span class="n">piegraph_arrow_head_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">piegraph_edgeweight_scalingfactor</span> <span class="o">=</span> <span class="n">piegraph_edgeweight_scalingfactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_visual_outgoing_edges</span> <span class="o">=</span> <span class="n">max_visual_outgoing_edges</span>  <span class="c1"># higher value means more edges retained. This is applied to the clustergraph and is a strong threshold for number of edges shown</span>
        <span class="k">if</span> <span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">velocity_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">velocity_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span> <span class="o">=</span> <span class="n">velocity_matrix</span>  <span class="c1"># matrix from scVelo with velocities</span>
        <span class="k">if</span> <span class="n">gene_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">gene_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">gene_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span> <span class="o">=</span> <span class="n">gene_matrix</span>  <span class="c1"># matrix (not numpy array) with gene expression #such as adata.X.todense() or adata.layers[&quot;Mu&quot;] from scVelo (first moments of spliced gene counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span> <span class="o">=</span> <span class="n">A_velo</span>  <span class="c1"># the transition matrix weighted by the rna velocity [n_clus x n_clus]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CSM</span> <span class="o">=</span> <span class="n">CSM</span>  <span class="c1"># the cosine similarity matrix using velocity [n_clusters x n_clusters]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning_twice</span> <span class="o">=</span> <span class="n">edgebundle_pruning_twice</span>  <span class="c1"># default: False. When True, the edgebundling is applied to a further visually pruned (visual_cluster_graph_pruning) and can sometimes simplify the visualization. it does not impact the pseudotime and lineage computations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pca_loadings</span> <span class="o">=</span> <span class="n">pca_loadings</span>  <span class="c1"># the loadings of the pcs used to project the cells (to projected euclidean location based on velocity)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_series</span> <span class="o">=</span> <span class="n">time_series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="o">=</span> <span class="n">time_series_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_diff_step</span> <span class="o">=</span> <span class="n">t_diff_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_transition_matrix</span> <span class="o">=</span> <span class="n">single_cell_transition_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">=</span> <span class="n">embedding_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_compute_embedding</span> <span class="o">=</span> <span class="n">do_compute_embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span> <span class="o">=</span> <span class="n">color_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_cell</span> <span class="o">=</span> <span class="n">user_defined_terminal_cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_group</span> <span class="o">=</span> <span class="n">user_defined_terminal_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_gaussian_kernel_edgeweights</span> <span class="o">=</span> <span class="n">do_gaussian_kernel_edgeweights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RW2_mode</span> <span class="o">=</span> <span class="n">RW2_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">working_dir_fp</span> <span class="o">=</span> <span class="n">working_dir_fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_memory</span> <span class="o">=</span> <span class="n">p_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viagraph_decay</span> <span class="o">=</span> <span class="n">viagraph_decay</span>

    <span class="k">def</span> <span class="nf">_make_pt_augmented_adjacency_igraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">k_reverse</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                                           <span class="n">k_seq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If you dont have time-series labels to adjust the construction of the single-cell graph, you can try using the</span>
<span class="sd">        pseudotime (single-cell level) to achieve the same sequencing effect. However, since the pseudo-times are derived from</span>
<span class="sd">        the original unguided structure, there may not neccessarily be a large visible impact on the graph structure</span>

<span class="sd">        :param neighbors: ndarray (n_cells x n_neighbors) original unguided knn graph structure</span>
<span class="sd">        :param distances: ndarray (n_cell x n_neighbors)</span>
<span class="sd">        :param k_reverse: (int) default = 10</span>
<span class="sd">        :param k_seq: this is zero because terminal states that have lower pseudotimes should not be forced to look for neighbors in later pseudotimes</span>
<span class="sd">        :param knn:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n_pt_augmented</span><span class="p">,</span> <span class="n">d_pt_augmented</span> <span class="o">=</span> <span class="n">sequential_knn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">],</span>
                                                        <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span>
                                                        <span class="n">k_seq</span><span class="o">=</span><span class="n">k_seq</span><span class="p">,</span> <span class="n">k_reverse</span><span class="o">=</span><span class="n">k_reverse</span><span class="p">,</span>
                                                        <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>

        <span class="n">adjacency_pt_augmented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">n_pt_augmented</span><span class="p">,</span> <span class="n">d_pt_augmented</span><span class="p">,</span> <span class="n">time_series</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">time_series_labels</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">],</span>
                                                                 <span class="n">t_diff_step</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># this function has local pruning which removes neighbors that are more than t_dif apart. Since the same type of local pruning wrt t_dif is applied pre-clustergraph, we only need to call this function once in the case of time_series data</span>
        <span class="n">ig_full_graph_pt_guided</span> <span class="o">=</span> <span class="n">_composite_jacAffinity_distanceAffinity</span><span class="p">(</span><span class="n">sc_csr_graph</span><span class="o">=</span><span class="n">adjacency_pt_augmented</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ig_full_graph_pt_guided</span><span class="p">,</span> <span class="n">adjacency_pt_augmented</span>

    <span class="k">def</span> <span class="nf">_get_terminal_clusters_user_defined_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_defined_terminal_cell</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
                                            <span class="n">user_defined_terminal_group</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Allow the user to optionally select group or cell index level terminal fates that override the automated cell fate detection</span>

<span class="sd">        :param user_defined_terminal_cell: list of cell indices corresponding to terminal fate cells</span>
<span class="sd">        :param user_defined_terminal_cell_group: list of group level labels corresponding to labels found in true_label, that represent cell fates</span>
<span class="sd">        :return: list of clusters to represent the cell fate clusters in the via-clustergraph</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dict_user_defined_terminal_clusters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">terminal_cluster_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_defined_terminal_cell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">user_defined_terminal_cell</span><span class="p">:</span>
                <span class="n">clus_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clus_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terminal_cluster_list</span><span class="p">:</span>
                    <span class="n">terminal_cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clus_</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> is a repeated terminal cluster&#39;</span><span class="p">)</span>
                    <span class="n">terminal_cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clus_</span><span class="p">)</span>
                    <span class="n">dict_user_defined_terminal_clusters</span><span class="p">[</span><span class="n">user_defined_terminal_cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">clus_</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">user_terminal_group</span> <span class="ow">in</span> <span class="n">user_defined_terminal_group</span><span class="p">:</span>

                <span class="c1"># location in indices of which cells belong to this user_terminal_group</span>
                <span class="n">index_terminal_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)</span> <span class="o">==</span> <span class="n">user_terminal_group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">potential_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">index_terminal_group</span><span class="p">]</span>
                <span class="n">clus_</span> <span class="o">=</span> <span class="n">func_mode</span><span class="p">(</span><span class="n">potential_clusters</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">clus_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terminal_cluster_list</span><span class="p">:</span>
                    <span class="n">terminal_cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clus_</span><span class="p">)</span>
                    <span class="n">dict_user_defined_terminal_clusters</span><span class="p">[</span><span class="n">user_terminal_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">clus_</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Terminal cluster list based on user defined cells/groups:&#39;</span><span class="p">,</span>
              <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">dict_user_defined_terminal_clusters</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_user_defined_terminal_clusters</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">terminal_cluster_list</span>

    <span class="k">def</span> <span class="nf">_get_terminal_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">markov_pt</span><span class="p">,</span> <span class="n">root_ai</span><span class="p">):</span>
        <span class="n">n_</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of states in the graph component</span>

        <span class="k">if</span> <span class="n">n_</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span> <span class="n">n_outlier_std</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n_</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">):</span> <span class="n">n_outlier_std</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">n_</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">:</span> <span class="n">n_outlier_std</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># 1</span>

        <span class="n">pop_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># print(&#39;get terminal&#39;, set(self.labels), np.where(self.labels == 0))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)):</span>
            <span class="n">pop_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># we weight the out-degree based on the population of clusters to avoid allowing small clusters to become the terminals based on population alone</span>
        <span class="n">A_new</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">A_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pop_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">pop_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># make an igraph graph to compute the closeness</span>
        <span class="n">g_dis</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">Adjacency</span><span class="p">(</span>
            <span class="p">(</span><span class="n">A_new</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>  <span class="c1"># need to manually add the weights as igraph treates A&gt;0 as boolean</span>
        <span class="n">g_dis</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">A_new</span><span class="p">[</span><span class="n">A_new</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span>  <span class="c1"># we want &quot;distances&quot; not weights for closeness and betweeness</span>

        <span class="n">betweenness_score</span> <span class="o">=</span> <span class="n">g_dis</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="n">betweenness_score_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">betweenness_score</span><span class="p">)</span>
        <span class="n">betweenness_score_takeout_outlier</span> <span class="o">=</span> <span class="n">betweenness_score_array</span><span class="p">[</span><span class="n">betweenness_score_array</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">betweenness_score_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_outlier_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">betweenness_score_array</span><span class="p">))]</span>
        <span class="n">betweenness_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betweenness_score</span><span class="p">)</span> <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">betweenness_score_takeout_outlier</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">betweenness_score_takeout_outlier</span><span class="p">))]</span>

        <span class="n">closeness_score</span> <span class="o">=</span> <span class="n">g_dis</span><span class="o">.</span><span class="n">closeness</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">closeness_score_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">closeness_score</span><span class="p">)</span>
        <span class="n">closeness_score_takeout_outlier</span> <span class="o">=</span> <span class="n">closeness_score_array</span><span class="p">[</span>
            <span class="n">closeness_score_array</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">closeness_score_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_outlier_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">closeness_score_array</span><span class="p">))]</span>
        <span class="n">closeness_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">closeness_score</span><span class="p">)</span> <span class="k">if</span>
                          <span class="n">score</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">closeness_score_takeout_outlier</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
                              <span class="n">closeness_score_takeout_outlier</span><span class="p">))]</span>

        <span class="n">out_deg</span> <span class="o">=</span> <span class="n">A_new</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out_deg</span><span class="p">)</span>

        <span class="n">outdegree_score_takeout_outlier</span> <span class="o">=</span> <span class="n">out_deg</span><span class="p">[</span><span class="n">out_deg</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">out_deg</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_outlier_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">out_deg</span><span class="p">))]</span>
        <span class="n">loc_deg</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_deg</span><span class="p">)</span> <span class="k">if</span>
                   <span class="n">score</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">outdegree_score_takeout_outlier</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">outdegree_score_takeout_outlier</span><span class="p">))]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Identifying terminal clusters corresponding to unique lineages...&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Closeness:</span><span class="si">{</span><span class="n">closeness_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Betweenness:</span><span class="si">{</span><span class="n">betweenness_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Out Degree:</span><span class="si">{</span><span class="n">loc_deg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">markov_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">markov_pt</span><span class="p">)</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">n_</span> <span class="o">&lt;=</span> <span class="mi">40</span> <span class="k">else</span> <span class="mi">30</span>
        <span class="n">loc_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">markov_pt</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">markov_pt</span><span class="p">,</span> <span class="n">pct</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">terminal_clusters_1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">closeness_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">betweenness_list</span><span class="p">))</span>
        <span class="n">terminal_clusters_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">closeness_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">loc_deg</span><span class="p">))</span>
        <span class="n">terminal_clusters_3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">betweenness_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">loc_deg</span><span class="p">))</span>
        <span class="n">terminal_clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">terminal_clusters_1</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">terminal_clusters_2</span><span class="p">))</span>
        <span class="n">terminal_clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">terminal_clusters</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">terminal_clusters_3</span><span class="p">))</span>
        <span class="n">terminal_clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">terminal_clusters</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">loc_pt</span><span class="p">))</span>

        <span class="n">terminal_org</span> <span class="o">=</span> <span class="n">terminal_clusters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">terminal_i</span> <span class="ow">in</span> <span class="n">terminal_org</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">terminal_i</span> <span class="ow">in</span> <span class="n">terminal_clusters</span><span class="p">:</span>
                <span class="n">removed_terminal_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed_terminal_i</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># print(&#39;terminal state&#39;, terminal_i)</span>
            <span class="n">count_nn</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ts_neigh</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">neigh_terminal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="n">terminal_i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">neigh_terminal</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">neigh_terminal</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">terminal_clusters</span><span class="p">:</span>
                        <span class="n">ts_neigh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                        <span class="n">count_nn</span> <span class="o">=</span> <span class="n">count_nn</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">n_</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">root_ai</span><span class="p">:</span>  <span class="c1"># if the terminal state is a neighbor of</span>
                            <span class="k">if</span> <span class="n">terminal_i</span> <span class="ow">in</span> <span class="n">terminal_clusters</span><span class="p">:</span>
                                <span class="n">terminal_clusters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">terminal_i</span><span class="p">)</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">We removed cluster </span><span class="si">{</span><span class="n">terminal_i</span><span class="si">}</span><span class="s2"> from the shortlist of terminal states&quot;</span><span class="p">)</span>
                                <span class="n">removed_terminal_i</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">count_nn</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighboring_terminal_states_threshold</span><span class="p">:</span>  <span class="c1"># 2</span>
                    <span class="k">if</span> <span class="n">removed_terminal_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">temp_remove</span> <span class="o">=</span> <span class="n">terminal_i</span>
                        <span class="n">temp_time</span> <span class="o">=</span> <span class="n">markov_pt</span><span class="p">[</span><span class="n">terminal_i</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">to_remove_i</span> <span class="ow">in</span> <span class="n">ts_neigh</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">markov_pt</span><span class="p">[</span><span class="n">to_remove_i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">temp_time</span><span class="p">:</span>
                                <span class="n">temp_remove</span> <span class="o">=</span> <span class="n">to_remove_i</span>
                                <span class="n">temp_time</span> <span class="o">=</span> <span class="n">markov_pt</span><span class="p">[</span><span class="n">to_remove_i</span><span class="p">]</span>
                        <span class="n">terminal_clusters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_remove</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Cluster </span><span class="si">{</span><span class="n">terminal_i</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">neighboring_terminal_states_threshold</span><span class="si">}</span><span class="s2"> or more neighboring terminal states </span><span class="si">{</span><span class="n">ts_neigh</span><span class="si">}</span><span class="s2"> and so we removed cluster </span><span class="si">{</span><span class="n">temp_remove</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terminal_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">terminal_clusters</span> <span class="o">=</span> <span class="n">loc_deg</span>
        <span class="c1"># print(&#39;terminal_clusters&#39;, terminal_clusters)</span>
        <span class="k">return</span> <span class="n">terminal_clusters</span>

    <span class="k">def</span> <span class="nf">compute_hitting_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse_graph</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">,</span> <span class="n">alpha_teleport</span><span class="p">,</span> <span class="n">number_eig</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># 1- alpha is the probability of teleporting</span>
        <span class="c1"># 1- x_lazy is the probability of staying in current state (be lazy)</span>
        <span class="c1"># Computing lazy-teleporting expected hitting time</span>
        <span class="n">beta_teleport</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">sparse_graph</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">Lsym</span> <span class="o">=</span> <span class="n">csgraph</span><span class="o">.</span><span class="n">laplacian</span><span class="p">(</span><span class="n">sparse_graph</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">Lsym</span><span class="p">,</span> <span class="n">number_eig</span> <span class="ow">or</span> <span class="n">Lsym</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">Greens</span><span class="p">,</span> <span class="n">beta_norm_lap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">Xu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">Xu</span><span class="p">[:,</span> <span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Xv_Xu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">Xu</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">alpha_teleport</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigval</span><span class="p">)):</span>
            <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">eigvec</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">eigvec</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">beta_teleport</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eigval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_lazy</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta_teleport</span><span class="p">)</span>

            <span class="n">Greens</span> <span class="o">+=</span> <span class="n">vv</span> <span class="o">/</span> <span class="n">factor</span>
            <span class="n">beta_norm_lap</span> <span class="o">+=</span> <span class="n">vv</span> <span class="o">*</span> <span class="n">factor</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparse_graph</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="n">Greens</span> <span class="o">@</span> <span class="n">D</span> <span class="o">*</span> <span class="n">beta_teleport</span>

        <span class="n">hitting_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">t</span>
        <span class="c1"># Calculate only diagonal elements of Xv_Xu @ t</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">Xv_Xu</span> <span class="o">*</span> <span class="n">t</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="n">hitting_matrix</span> <span class="o">+</span> <span class="n">hitting_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="n">root</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">simulate_branch_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_sim</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>

        <span class="n">n_states</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ncpu</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ncpu</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ncpu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="c1"># print(&#39;njobs&#39;, n_jobs)</span>
        <span class="n">num_sim_pp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_sim</span> <span class="o">/</span> <span class="n">n_jobs</span><span class="p">)</span>  <span class="c1"># num of simulations per process</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="n">seed_list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">))</span>
        <span class="n">seed_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seed_list_</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">):</span>
            <span class="n">cumstateChangeHist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
            <span class="n">cumstateChangeHist_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">_prob_reaching_terminal_state</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span>
                <span class="n">terminal_state</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_sim_pp</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">cumstateChangeHist</span><span class="p">,</span>
                <span class="n">cumstateChangeHist_all</span><span class="p">,</span>
                <span class="n">seed_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">j</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">j</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="n">cumhistory_vec</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cumhistory_vec_all</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">count_reached</span> <span class="o">=</span> <span class="n">cumhistory_vec_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
            <span class="n">cumhistory_vec</span> <span class="o">=</span> <span class="n">cumhistory_vec</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cumhistory_vec_all</span> <span class="o">=</span> <span class="n">cumhistory_vec_all</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">count_reached</span> <span class="o">=</span> <span class="n">count_reached</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">From root </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2">,  the Terminal state </span><span class="si">{</span><span class="n">terminal_state</span><span class="si">}</span><span class="s2"> is reached </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">count_reached</span><span class="p">)</span><span class="si">}</span><span class="s2"> times.&quot;</span><span class="p">)</span>
        <span class="c1"># print(&#39;cumhistory_vec_all&#39;, cumhistory_vec_all)</span>
        <span class="n">cumhistory_vec_all</span><span class="p">[</span>
            <span class="n">cumhistory_vec_all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># to avoid division by zero we say that the state has been visited once</span>
        <span class="c1"># print(&#39;cumhistory_vec_all&#39;, cumhistory_vec_all)</span>
        <span class="c1"># print(&#39;cumhistory_vec&#39;, cumhistory_vec)</span>
        <span class="n">prob_</span> <span class="o">=</span> <span class="n">cumhistory_vec</span> <span class="o">/</span> <span class="n">cumhistory_vec_all</span>
        <span class="c1"># given a cluster is traversed (cumhistory_vec_all), how many of these traversals led to a successful path to Terminal State X</span>
        <span class="c1"># i.e. with what probability does traversal of a cluster lead to the desired terminal state (number of times traversed along a sucessful path)  #cumhistory_vec: number of times cluster is traversed on a successful path</span>

        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">count_reached</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prob_</span><span class="p">[:,</span> <span class="n">terminal_state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;never reached state&#39;</span><span class="p">,</span> <span class="n">terminal_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">prob_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">loc_1</span> <span class="o">=</span> <span class="n">loc_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">prob_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc_1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># print(&#39;zerod out prob&#39;, prob_)</span>
            <span class="n">temp_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">prob_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">temp_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">temp_</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">prob_</span> <span class="o">=</span> <span class="n">prob_</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                                <span class="mf">1.1</span> <span class="o">*</span> <span class="n">temp_</span><span class="p">)</span>  <span class="c1"># do some scaling to amplify the probabiltiies of those clusters that are not 1 to make the range of values more compact</span>
        <span class="n">prob_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc_1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># put back probability =1</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">prob_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_simulate_markov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Computes the MCMC based hitting times on the forward biased graph</span>
<span class="sd">        :param A: cluster graph adjacency matrix (forward biased)</span>
<span class="sd">        :param root:</span>
<span class="sd">        :return: mcmc hitting times</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># print(&#39;row normed P&#39;,P.shape, P, P.sum(axis=1))</span>
        <span class="n">x_lazy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_lazy</span>  <span class="c1"># 1-x is prob lazy</span>
        <span class="n">alpha_teleport</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_teleport</span>
        <span class="c1"># bias_P is the transition probability matrix</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">x_lazy</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_lazy</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="c1"># print(P, P.sum(axis=1))</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">alpha_teleport</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))))</span>
        <span class="c1"># print(&#39;check prob of each row sum to one&#39;, P.sum(axis=1))</span>

        <span class="n">currentState</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">currentState</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">num_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mcmc_simulations</span>

        <span class="n">ncpu</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ncpu</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">ncpu</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># min(ncpu - 2, 5)</span>
        <span class="c1"># print(&#39;njobs&#39;, n_jobs)</span>
        <span class="n">num_sim_pp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_sim</span> <span class="o">/</span> <span class="n">n_jobs</span><span class="p">)</span>  <span class="c1"># num of simulations per process</span>

        <span class="n">n_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_states</span><span class="p">)</span>

        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span>
        <span class="n">dummy_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">):</span>
            <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span>
            <span class="n">dummy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hitting_array</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># range(n_jobs):</span>
                <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">_simulate_markov_sub</span><span class="p">,</span>
                                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">num_sim_pp</span><span class="p">,</span> <span class="n">hitting_array</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">seed</span><span class="p">))</span>
                <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
                <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="c1"># for j in jobs:</span>
            <span class="c1"># j.start()</span>

            <span class="c1"># for j in jobs:</span>
            <span class="c1"># j.join()</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2"> ended all multiprocesses, will retrieve and reshape&quot;</span><span class="p">)</span>
            <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">hitting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hitting_array</span><span class="p">,</span> <span class="n">qi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># .get(), axis=1)</span>
            <span class="c1"># print(&#39;finished getting from queue&#39;, hitting_array.shape)</span>
        <span class="n">hitting_array_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="n">no_times_state_reached_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">rowtemp</span> <span class="o">=</span> <span class="n">hitting_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">no_times_state_reached_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">rowtemp</span> <span class="o">=</span> <span class="n">hitting_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">no_times_state_reached</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">no_times_state_reached</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">rowtemp</span><span class="p">[</span><span class="n">rowtemp</span> <span class="o">!=</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">15</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.001</span>  <span class="c1"># 15 for Human and Toy</span>
                <span class="c1"># print(&#39;state &#39;, i,&#39; has perc&#39; ,perc)</span>
                <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rowtemp</span><span class="p">[</span><span class="n">rowtemp</span> <span class="o">&lt;=</span> <span class="n">perc</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hitting_array_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_hitting_time_onbias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laplacian</span><span class="p">,</span> <span class="n">inv_sqr_deg</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">x_lazy</span><span class="p">,</span> <span class="n">alpha_teleport</span><span class="p">,</span> <span class="n">number_eig</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># 1- alpha is the probabilty of teleporting</span>
        <span class="c1"># 1- x_lazy is the probability of staying in current state (be lazy)</span>
        <span class="n">beta_teleport</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">alpha_teleport</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">laplacian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;is laplacian of biased symmetric&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">laplacian</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">==</span> <span class="n">laplacian</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># norm_lap = scipy.sparse.csr_matrix.todense(laplacian)</span>

        <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span>
            <span class="n">laplacian</span><span class="p">)</span>  <span class="c1"># eig_vec[:,i] is eigenvector for eigenvalue eig_val[i] not eigh as this is only for symmetric. the eig vecs are not in decsending order</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eig val&#39;</span><span class="p">,</span> <span class="n">eig_val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_eig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">number_eig</span> <span class="o">=</span> <span class="n">eig_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of eig vec&#39;</span><span class="p">,</span> <span class="n">number_eig</span><span class="p">)</span>
        <span class="n">Greens_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">beta_norm_lap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">Xu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">Xu</span><span class="p">[:,</span> <span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Id_Xv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">Id_Xv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Xv_Xu</span> <span class="o">=</span> <span class="n">Id_Xv</span> <span class="o">-</span> <span class="n">Xu</span>
        <span class="n">start_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">alpha_teleport</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">start_</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if there are no jumps (alph_teleport ==1), then the first term in beta-normalized Green&#39;s function will have 0 in denominator (first eigenvalue==0)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_</span><span class="p">,</span> <span class="n">number_eig</span><span class="p">):</span>  <span class="c1"># 0 instead of 1st eg</span>
            <span class="c1"># print(i, &#39;th eigenvalue is&#39;, eig_val[i])</span>
            <span class="n">vec_i</span> <span class="o">=</span> <span class="n">eig_vec</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">beta_teleport</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eig_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_lazy</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta_teleport</span><span class="p">)</span>

            <span class="n">vec_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">eigen_vec_mult</span> <span class="o">=</span> <span class="n">vec_i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">Greens_matrix</span> <span class="o">=</span> <span class="n">Greens_matrix</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">eigen_vec_mult</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>  <span class="c1"># Greens function is the inverse of the beta-normalized laplacian</span>
            <span class="n">beta_norm_lap</span> <span class="o">=</span> <span class="n">beta_norm_lap</span> <span class="o">+</span> <span class="p">(</span><span class="n">eigen_vec_mult</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>  <span class="c1"># beta-normalized laplacian</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">Greens_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_sqr_deg</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">inv_sqr_deg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta_teleport</span>
        <span class="n">hitting_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">diag_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">hitting_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">diag_row</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">roundtrip_commute_matrix</span> <span class="o">=</span> <span class="n">hitting_matrix</span> <span class="o">+</span> <span class="n">hitting_matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">Xv_Xu</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">final_hitting_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span>
            <span class="n">temp</span><span class="p">)</span>  <span class="c1">## number_eig x 1 vector of hitting times from root (u) to number_eig of other nodes</span>
        <span class="n">roundtrip_times</span> <span class="o">=</span> <span class="n">roundtrip_commute_matrix</span><span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final_hitting_times</span><span class="p">),</span> <span class="n">roundtrip_times</span>

    <span class="k">def</span> <span class="nf">_project_branch_probability_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bp_array_clus</span><span class="p">,</span> <span class="n">pt</span><span class="p">):</span>
        <span class="c1"># print(&#39;sum of branch probabilities at cluster level&#39;, np.sum(bp_array_clus, axis=1))</span>
        <span class="n">n_clus</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)))</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">knn_sc</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="k">else</span> <span class="mi">10</span>
        <span class="n">neighbors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">knn_sc</span><span class="p">)</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
            <span class="n">neighboring_clus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">neighboring_clus</span><span class="p">)):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neighboring_clus</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">knn_sc</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_clus</span><span class="p">))</span>

        <span class="n">bp_array_sc</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bp_array_clus</span><span class="p">)</span>
        <span class="n">bp_array_sc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bp_array_sc</span><span class="p">,</span>
                              <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># divide cell probability by max value in that column so that rare lineages dont have distortedly low lineage probabilities</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label_ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">):</span>  <span class="c1"># list(set(self.terminal_clusters))</span>

            <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label_ts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">loc_noti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">!=</span> <span class="n">label_ts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bp_array_sc</span><span class="p">[</span><span class="n">loc_noti</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.8</span><span class="p">:</span> <span class="n">bp_array_sc</span><span class="p">[</span><span class="n">loc_i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">(</span><span class="n">n_clus</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">pt_sc</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">pt_sc</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pt_sc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bp_array_sc</span><span class="p">,</span> <span class="n">pt_sc</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<div class="viewcode-block" id="VIA.sc_transition_matrix"><a class="viewcode-back" href="../../api/pyVIA%20Core.html#VIA.core.VIA.sc_transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">sc_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        #computes the single cell level transition directions that are later used to calculate velocity of embedding</span>
<span class="sd">        #based on changes at single cell level in genes and single cell level velocity</span>

<span class="sd">        :param smooth_transition:</span>
<span class="sd">        :param b: slope of logistic function</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># n_clus = len(list(set(self.labels)))</span>
        <span class="c1"># n_cells = self.data.shape[0]</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">)</span>  <span class="c1"># some scaling so that the input to the logistic function covers a range of sensible inputs</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="k">if</span> <span class="n">use_sequentially_augmented</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned_augmented</span>  <span class="c1"># single cell edges are weighted as inverse of distance</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned</span>
        <span class="c1"># T = self.csr_full_graph #single cell</span>

        <span class="n">thr_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># 2*</span>
        <span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">thr_global</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">T</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

        <span class="n">size_T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span>

        <span class="n">T</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
        <span class="n">find_T</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">bias_weight</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">nu</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">bias_weight_pt</span><span class="p">,</span> <span class="n">bias_weight_velo</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1"># print(&#39;transition before biasing&#39;)</span>
        <span class="c1"># print(T)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CSM</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if rna velocity is available, then combine the single-cell directions inferred by sc-pt and scRNA velocity to get the sc directions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size_T</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">find_T</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">find_T</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">find_T</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">t_dif</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">find_T</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="n">find_T</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>

                <span class="n">delta_gene</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span><span class="p">[</span><span class="n">end</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span><span class="p">[</span><span class="n">start</span><span class="p">,</span>
                                                                 <span class="p">:])</span>  <span class="c1"># change in gene expression when going from start cell to end cells</span>

                <span class="c1"># print(&#39;shape delta_gene&#39;, delta_gene.shape, delta_gene)</span>

                <span class="c1"># csm_ = 1- distance.cosine(delta_gene[0,:], self.velocity_matrix[start, :])</span>
                <span class="c1"># print(csm_)</span>
                <span class="n">csm_</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">csm_</span> <span class="o">=</span> <span class="n">cosine_sim</span><span class="p">(</span><span class="n">delta_gene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span><span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>  <span class="c1"># based on sc level CSM</span>

                <span class="c1"># csm_ = self.CSM[labels[find_T[0][i]],labels[find_T[1][i]]] #based on cluster level CSM</span>
                <span class="c1"># if (csm_&lt;0)&amp;(t_dif&lt;0): csm_ *=10</span>
                <span class="c1"># if (csm_ &gt;0) &amp; (t_dif &gt; 0): csm_ *= 10</span>
                <span class="c1"># if i%100000==0:  print(i,&#39;out of&#39;, size_T, &#39;start&#39;, labels[start], &#39;end&#39;, labels[end], &#39;csm_&#39;, round(csm_,3), &#39;t_diff&#39;, round(t_dif,3))</span>
                <span class="c1"># print(&#39;shape gene_matrix&#39;, self.gene_matrix.shape)</span>
                <span class="c1"># print(&#39;start-end, csm&#39;, start, end, csm_)</span>
                <span class="c1"># bias_weight_pt.append(t_dif)</span>
                <span class="c1"># bias_weight_velo.append(csm_)</span>
                <span class="n">bias_weight_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">K</span> <span class="o">/</span> <span class="p">((</span><span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">t_dif</span> <span class="o">+</span> <span class="n">c</span><span class="p">)))</span> <span class="o">**</span> <span class="n">nu</span><span class="p">))</span>
                <span class="c1"># bias_weight_velo.append(csm_)</span>
                <span class="n">bias_weight_velo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">K</span> <span class="o">/</span> <span class="p">((</span><span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span> <span class="n">csm_</span> <span class="o">+</span> <span class="n">c</span><span class="p">)))</span> <span class="o">**</span> <span class="n">nu</span><span class="p">))</span>
            <span class="c1"># scale both the pt and velocity weights</span>
            <span class="n">bias_weight_pt</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bias_weight_pt</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bias_weight_pt</span><span class="p">))</span>  <span class="c1"># need to normalize the pt and velo weights</span>
            <span class="c1"># print(&#39;list shape&#39;,bias_weight_pt.shape)</span>
            <span class="c1"># print(&#39;argwhere is nan&#39;)</span>
            <span class="c1"># argwhere=np.argwhere(np.isnan(bias_weight_velo))</span>
            <span class="c1"># print(argwhere.shape)</span>
            <span class="c1"># print(&#39;bias weight velo is anywhere nan&#39;, np.isnan(bias_weight_velo).any(), np.mean(np.array(bias_weight_velo)))</span>
            <span class="n">bias_weight_velo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">bias_weight_velo</span><span class="p">)</span>
            <span class="n">bias_weight_velo</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bias_weight_velo</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bias_weight_velo</span><span class="p">))</span>  <span class="c1"># USE THIS</span>
            <span class="c1"># bias_weight_velo = np.asarray(bias_weight_velo)#</span>
            <span class="c1"># bias_weight_velo = np.clip(bias_weight_velo, 0, 1) #this approach zeros out negative edges</span>
            <span class="c1"># print(&#39;pt weight &#39;, bias_weight_pt)</span>
            <span class="n">bias_weight_velo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span>
                                           <span class="n">bias_weight_velo</span><span class="p">)</span>  <span class="c1">## consider changing this weight to the weight based on projected &quot;i&quot; -to- current &quot;neighbor&quot;</span>
            <span class="n">bias_weight_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">bias_weight_pt</span><span class="p">)</span>
            <span class="c1"># print(&#39;velo weight * weigt&#39;, bias_weight_velo)</span>
            <span class="c1"># print(&#39;pt weight *weight&#39;, bias_weight_pt)</span>
            <span class="n">bias_weight</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">bias_weight_pt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span> <span class="o">*</span> <span class="n">bias_weight_velo</span>
            <span class="c1"># print(&#39;bias_weight size&#39;, bias_weight.shape)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">bias_weight</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bias_weight</span><span class="p">)),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_T</span><span class="p">[</span><span class="mi">1</span><span class="p">]))),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># print(&#39;sc transition weights T&#39;,np.isnan(T.data).any())</span>
            <span class="n">T</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># print(&#39;sc transition weights T&#39;, np.isnan(T.data).any())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case where you dont have rna velocity, then the single-cell directions are only inferred using the single-cell pt</span>
            <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size_T</span><span class="p">):</span>
                <span class="c1"># start = find_T[0][i]</span>
                <span class="c1"># end = find_T[1][i]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">find_T</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">t_dif</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">find_T</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="n">find_T</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">bias_weight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">K</span> <span class="o">/</span> <span class="p">((</span><span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">t_dif</span> <span class="o">+</span> <span class="n">c</span><span class="p">)))</span> <span class="o">**</span> <span class="n">nu</span><span class="p">))</span>  <span class="c1"># b * (-t_dif</span>

            <span class="n">T</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">bias_weight</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bias_weight</span><span class="p">)),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_T</span><span class="p">[</span><span class="mi">1</span><span class="p">]))),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">T</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">T</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">smooth_transition</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>  <span class="c1"># rows sum to one</span>
        <span class="k">return</span> <span class="n">T</span></div>

    <span class="k">def</span> <span class="nf">_velocity_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_emb</span><span class="p">,</span> <span class="n">smooth_transition</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        :param X_emb:</span>
<span class="sd">        :param smooth_transition:</span>
<span class="sd">        :return: V_emb</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># T transition matrix at single cell level</span>
        <span class="n">n_obs</span> <span class="o">=</span> <span class="n">X_emb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">V_emb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X_emb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_transition_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_transition_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_transition_matrix</span><span class="p">(</span><span class="n">smooth_transition</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
                                                                           <span class="n">use_sequentially_augmented</span><span class="o">=</span><span class="n">use_sequentially_augmented</span><span class="p">)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_transition_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_transition_matrix</span>

        <span class="c1"># the change in embedding distance when moving from cell i to its neighbors is given by dx</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">X_emb</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_emb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># shape (n_neighbors, 2)</span>
            <span class="n">dX</span> <span class="o">/=</span> <span class="n">l2_norm</span><span class="p">(</span><span class="n">dX</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># dX /= np.sqrt(dX.multiply(dX).sum(axis=1).A1)[:, None]</span>
            <span class="n">dX</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dX</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># zero diff in a steady-state</span>
            <span class="c1"># neighbor edge weights are used to weight the overall dX or velocity from cell i.</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># if probs.size ==0: print(&#39;velocity embedding probs=0 length&#39;, probs, i, self.true_label[i])</span>
            <span class="n">V_emb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dX</span><span class="p">)</span> <span class="o">-</span> <span class="n">probs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">dX</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">V_emb</span> <span class="o">/=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">quiver_autoscale</span><span class="p">(</span><span class="n">X_emb</span><span class="p">,</span> <span class="n">V_emb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">V_emb</span>

    <span class="k">def</span> <span class="nf">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                   <span class="n">auto_</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">distance_factor</span><span class="o">=</span><span class="mf">.01</span><span class="p">,</span> <span class="n">weights_as_inv_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">min_max_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_series</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_series_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">t_diff_step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create sparse matrix from weighted knn graph. Default does local pruning and returns an affinity graph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        neighbors: np.ndarray of shape (n_samples, n_neighbors)</span>
<span class="sd">            Indicating neighbors of each sample. neighbors[i,j] means that sample j is a neighbor of sample i</span>

<span class="sd">        distances: np.ndarray of shape (n_samples, n_neighbors)</span>
<span class="sd">            Distances between neighboring samples corresponding `neighbors`</span>

<span class="sd">        auto_: bool, default=True</span>
<span class="sd">            If `False` and `self.keep_all_local_dist = False` perform local pruning (according to self.edgepruning_clustering_resolution_local)</span>
<span class="sd">            and remove self-loops</span>

<span class="sd">        distance_factor: float, default=0.01</span>
<span class="sd">            Factor used in calculation of edge weights. mean(sqrt(distances))^2 / (sqrt(distances) + distance_factor)</span>
<span class="sd">        weights_as_inv_dist: bool, default = True</span>
<span class="sd">            Whether to convert the distances into weights that are proportional to inverse of the distance</span>
<span class="sd">        min_max_scale: bool, default = False</span>
<span class="sd">            This is called with True for constructing the sc-knn used for vertexclustergraph.</span>
<span class="sd">            we use the inverse of the distance but scaled from 0.5-2 such that we can combine the distance derived weights with the</span>
<span class="sd">            Jaccard similarity (0-1). The jaccard similiarity in igraph does not consider weights, so we re-introduce the impact of the</span>
<span class="sd">            distances which then play a role in the transition matrix for trajectories as well as the visualization of edge-weights</span>
<span class="sd">            In the case of the sc-KNN used for clustering, we do not re-introduce the distance based weights but leave it at the</span>
<span class="sd">            jaccard similarity as this empirically seems to work well</span>
<span class="sd">        time_series: bool, default = False. Whether or not this is a time course data set. will require time_series_labels in order to be actioned on</span>
<span class="sd">        time_series_labels: list, default = None. a list of numerical values reflecting the sampling time of each cell</span>
<span class="sd">        t_diff_step=int, default =2, number of sequential time steps permissible between edges. (e.g. edges allowed to be 2 or fewer time steps apart)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            sparse matrix representing the locally pruned weighted knn affinity graph. edge weight represents level of similarity. higher values mean stronger edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="c1"># distances =distances.astype(np.float32)</span>

        <span class="c1"># print(neighbors[0,:])</span>
        <span class="c1"># print(distances[0,:])</span>
        <span class="n">neigh01</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print(&#39;norm2&#39;, np.linalg.norm(self.data[0,:]-self.data[neigh01,:]))</span>
        <span class="k">if</span> <span class="n">time_series</span><span class="p">:</span>
            <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="c1"># print(&#39;all edges&#39;, np.sum(msk))</span>
            <span class="c1"># Remove self-loops</span>
            <span class="n">msk</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">neighbors</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="c1"># print(&#39;non-self edges&#39;, np.sum(msk))</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            #doing local pruning and then adding back the augmented edges does not work so well because when the edge weights are scaled and inverted,</span>
<span class="sd">            # the sequentially added edges appear very weak and noisy compared to the fairly strong edges that remain after the local pruning from the inital round of knngraph. If you retain all edges from initial graph construction,</span>
<span class="sd">            # then the average weight of edges is exaggeratedly higher than those edge weights from the sequentially added edges, and creates a better gradient of edge weights</span>
<span class="sd">            # Local pruning based on neighbor being too far. msk where we want to keep neighbors</span>
<span class="sd">            msk = distances &lt;= (np.mean(distances, axis=1) + self.edgepruning_clustering_resolution_local * np.std(distances, axis=1))[:,</span>
<span class="sd">                               np.newaxis]</span>
<span class="sd">            # Remove self-loops</span>
<span class="sd">            msk &amp;= (neighbors != np.arange(neighbors.shape[0])[:, np.newaxis])</span>
<span class="sd">            last_n_columns = self.knn_sequential+1</span>
<span class="sd">            msk[:,-last_n_columns:] = True # add back the edges belonging to knn-sequentially built part of the graph</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="c1"># remove edges between nodes that &gt;t_diff_step far apart in time_series_labels</span>

            <span class="k">if</span> <span class="n">t_diff_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time_series_set_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">))))</span>
                <span class="n">t_diff_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_series_set_order</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_series_set_order</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]))</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Actual average allowable time difference between nodes is </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">t_diff_mean</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t_diff_step</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">time_series_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">)</span>
            <span class="c1"># print(colored(f&quot;inside time_series msk&quot;))</span>

            <span class="n">rr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="c1"># if rr%20000==0: print(row, type(row), row[0])</span>
                <span class="n">rr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">t_row</span> <span class="o">=</span> <span class="n">time_series_labels</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># first neighbor is itself</span>

                <span class="k">if</span> <span class="n">t_diff_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e_i</span><span class="p">,</span> <span class="n">n_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">time_series_labels</span><span class="p">[</span><span class="n">n_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">t_diff_mean</span> <span class="o">*</span> <span class="n">t_diff_step</span><span class="p">:</span>
                            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">msk</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span> <span class="n">msk</span><span class="p">[</span>
                                <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e_i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># we want to ensure that each cell has at least 5 nn</span>
            <span class="c1"># print(&#39;links within tdiff&#39;,np.sum(msk))</span>

        <span class="k">elif</span> <span class="n">auto_</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_all_local_dist</span><span class="p">:</span>
            <span class="c1"># print(&#39;elif condition&#39;)</span>
            <span class="c1"># Local pruning based on neighbor being too far. msk where we want to keep neighbors</span>
            <span class="n">msk</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution_local</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="c1"># Remove self-loops</span>
            <span class="n">msk</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">neighbors</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="c1"># print(&#39;msk shape&#39;, msk.shape)</span>
            <span class="c1"># Remove self-loops</span>
            <span class="n">msk</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">neighbors</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

            <span class="c1"># print(&#39;msk shape&#39;, msk.shape)</span>
        <span class="c1"># Inverting the distances outputs values in range [0-1]. This also causes many ``good&#39;&#39; neighbors ending up</span>
        <span class="c1"># having a weight near zero (misleading as non-neighbors have a weight of zero). Therefore we scale by the</span>
        <span class="c1"># mean distance. The inversed weights without min_max_scaling are used for the community detection graph</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])[</span><span class="n">msk</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># CHECK THIS</span>
            <span class="c1"># weights = logistic_function(weights)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">weights_as_inv_dist</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">min_max_scale</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>

            <span class="c1"># weights = (np.mean(distances[msk]) ** 2) / (distances[msk] + distance_factor) #larger weight is a stronger edge</span>

            <span class="c1"># weights = 1 / (distances[msk] + distance_factor)</span>
            <span class="c1"># do_exp_weight= True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_gaussian_kernel_edgeweights</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;do_exp edge weights true in core_working&#39;</span><span class="p">)</span>
                <span class="n">stdd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
                <span class="kn">import</span> <span class="nn">umap.umap_</span> <span class="k">as</span> <span class="nn">u</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">distances</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

                <span class="n">minn</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># np.min(distances,axis=1) min of nonzero entries per row</span>
                <span class="n">new_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">distances</span> <span class="o">-</span> <span class="n">minn</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">stdd</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">new_distances</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
                <span class="n">sigmas</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">smooth_knn_dist</span><span class="p">(</span>
                    <span class="n">distances</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">,</span> <span class="n">local_connectivity</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>

                <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">dist_weights</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_membership_strengths</span><span class="p">(</span>
                    <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">,</span> <span class="n">rhos</span><span class="p">)</span>

                <span class="c1"># print(&#39;local connectivity&#39;, float(distances.shape[1]))</span>
                <span class="c1"># print(&#39;k&#39;, self.knn)</span>
                <span class="c1"># print(&#39;sigmas&#39;, len(sigmas), sigmas)</span>
                <span class="c1"># print(&#39;rhos&#39;, len(rhos), rhos)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

                <span class="c1"># print(&#39;applying symmetry in umap_&#39;)</span>
                <span class="n">transpose</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="c1"># print(&#39;size of symmetry only&#39;, (transpose + result).size)</span>
                <span class="n">prod_matrix</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>

                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">transpose</span> <span class="o">-</span> <span class="n">prod_matrix</span><span class="p">)</span>
                <span class="c1"># print(&#39;after fuzzy symm result.data.size, max, mean&#39;, result.data.size, max(result.data), np.mean(result.data))</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">msk</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">distances</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span> <span class="o">+</span> <span class="n">distance_factor</span><span class="p">)</span>  <span class="c1"># larger weight is a stronger edge</span>
            <span class="c1"># weights = np.exp(-distances[msk]/stdd[:,None])</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])[</span><span class="n">msk</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">min_max_scale</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># the jaccard similarity does not consider edge weights, we will use these min-max scaled weights to make a composite weight together with Jaccard to retain the distance based info</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>  <span class="c1"># larger weight is a stronger edge</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                              <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># the first neighbor is usually itself and hence has distance 0</span>
            <span class="c1"># print(&#39;min clip&#39;,np.percentile(weights,10))</span>
            <span class="c1"># print(&#39;clipped weights for current pc-dist&#39;, weights)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="p">(</span><span class="n">weights</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weights</span>  <span class="c1"># all weights between 0.5 and 2. these will later be multiplied by the Jac similarity which are between 0-1 to create a composite weight</span>

            <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])[</span><span class="n">msk</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>

        <span class="c1"># result = scipy.sparse.coo_matrix( (weights, (rows, cols)), shape=(len(neighbors), len(neighbors)) )</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># result.eliminate_zeros()</span>
        <span class="c1"># transpose = result.transpose()</span>

        <span class="c1"># prod_matrix = result.multiply(transpose)</span>
        <span class="c1"># result = result + transpose# - prod_matrix</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">func_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll</span><span class="p">):</span>
        <span class="c1"># return MODE of list</span>
        <span class="c1"># If multiple items are maximal, the function returns the first one encountered.</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ll</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">ll</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_JSON</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folderpath</span><span class="o">=</span><span class="s1">&#39;/home/user/JavaCode/basicgraph/&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;VIA_JSON.js&#39;</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="kn">from</span> <span class="nn">networkx.readwrite</span> <span class="kn">import</span> <span class="n">json_graph</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgelist_maxout</span>

        <span class="n">weightlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeweights_maxout</span>
        <span class="n">min_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">weightlist</span><span class="p">)</span>
        <span class="n">max_w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">weightlist</span><span class="p">)</span>
        <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">min_w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_w</span> <span class="o">-</span> <span class="n">min_w</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">]</span>
        <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
        <span class="n">group_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">cluster_population_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">group_i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">group_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">group_pop</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>  <span class="c1"># np.sum(loc_i) / 1000 + 1</span>
            <span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">group_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_i</span><span class="p">)</span>

        <span class="n">pop_max</span> <span class="o">=</span> <span class="n">cluster_population_dict</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">cluster_population_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cluster_population_dict</span><span class="o">.</span><span class="n">get</span><span class="p">)]</span>
        <span class="n">pop_min</span> <span class="o">=</span> <span class="n">cluster_population_dict</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">cluster_population_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cluster_population_dict</span><span class="o">.</span><span class="n">get</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cluster_population_dict</span><span class="p">,</span> <span class="n">pop_min</span><span class="p">,</span> <span class="n">pop_max</span><span class="p">)</span>
        <span class="n">pt_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_hitting_times</span><span class="p">)</span>
        <span class="n">pt_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_hitting_times</span><span class="p">)</span>
        <span class="n">scaled_hitting_times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pt_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pt_max</span> <span class="o">-</span> <span class="n">pt_min</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_hitting_times</span><span class="p">]</span>
        <span class="n">node_majority_truth_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)))):</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">majority_truth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>
            <span class="n">node_majority_truth_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span>

        <span class="n">majority_truth_labels_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">node_majority_truth_labels</span><span class="p">))</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>

        <span class="n">df_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">])</span>
        <span class="n">df_edges</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weightlist</span>
        <span class="n">df_edges</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">150</span> <span class="o">/</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>  <span class="c1"># directed graph</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">majority_truth_labels_dict</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">majority_truth_labels_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">round</span><span class="p">(</span><span class="n">scaled_hitting_times</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                  <span class="n">temp</span><span class="p">[</span><span class="n">majority_truth_labels_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]])</span>
            <span class="c1"># val denotes size in d3 by default</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">majority_truth_labels_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pseudotime</span><span class="o">=</span><span class="n">scaled_hitting_times</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                       <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">pop_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pop_max</span> <span class="o">-</span> <span class="n">pop_min</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">group_num</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">majority_truth_labels_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">enum_i</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">weightlist</span><span class="p">[</span><span class="n">enum_i</span><span class="p">],</span> <span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">150</span> <span class="o">/</span> <span class="n">weightlist</span><span class="p">[</span><span class="n">enum_i</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">scaled_hitting_times</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">scaled_hitting_times</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="n">source_node</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">target_node</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source_node</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">target_node</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># val edge controls number of emitted particles</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u_of_edge</span><span class="o">=</span><span class="n">source_node</span><span class="p">,</span> <span class="n">v_of_edge</span><span class="o">=</span><span class="n">target_node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weightlist</span><span class="p">[</span><span class="n">enum_i</span><span class="p">],</span>
                       <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">cluster_population_dict</span><span class="p">[</span><span class="n">source_node</span><span class="p">]</span> <span class="o">-</span> <span class="n">pop_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pop_max</span> <span class="o">-</span> <span class="n">pop_min</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">distance</span><span class="o">=</span><span class="mi">150</span> <span class="o">/</span> <span class="n">weightlist</span><span class="p">[</span><span class="n">enum_i</span><span class="p">])</span>

        <span class="c1"># Visualize the network:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">json</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">json_graph</span><span class="o">.</span><span class="n">node_link_data</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="n">js</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="s1">&#39;var gData=&#39;</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">folderpath</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">js</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">run_toobig_subPARC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_data</span><span class="p">,</span> <span class="n">jac_std_toobig</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">jac_weighted_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">n_elements</span> <span class="o">=</span> <span class="n">X_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hnsw</span> <span class="o">=</span> <span class="n">_construct_knn</span><span class="p">(</span><span class="n">X_data</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">too_big</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">&gt;=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">n_elements</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">n_elements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn</span>
        <span class="n">neighbor_array</span><span class="p">,</span> <span class="n">distance_array</span> <span class="o">=</span> <span class="n">hnsw</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">X_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">csr_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">neighbor_array</span><span class="p">,</span> <span class="n">distance_array</span><span class="p">)</span>
        <span class="n">sources</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">csr_array</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">csr_array</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">csr_array</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">csr_array</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># smaller distance means stronger edge</span>
        <span class="n">csr_array</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">csr_array</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="n">sources</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">csr_array</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="n">edgelist_copy</span> <span class="o">=</span> <span class="n">edgelist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">csr_array</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>
        <span class="n">sim_list</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">similarity_jaccard</span><span class="p">(</span><span class="n">pairs</span><span class="o">=</span><span class="n">edgelist_copy</span><span class="p">)</span>  <span class="c1"># list of jaccard weights</span>
        <span class="n">new_edgelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sim_list_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sim_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jac_std_toobig</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sim_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">jac_std_toobig</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_list</span><span class="p">)</span>
        <span class="n">strong_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_list_array</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">strong_locs</span><span class="p">:</span> <span class="n">new_edgelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edgelist_copy</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="n">sim_list_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sim_list_array</span><span class="p">[</span><span class="n">strong_locs</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">jac_weighted_edges</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">G_sim</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_edgelist</span><span class="p">),</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">sim_list_new</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_sim</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_edgelist</span><span class="p">))</span>
        <span class="n">G_sim</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jac_weighted_edges</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_type</span> <span class="o">==</span> <span class="s1">&#39;ModularityVP&#39;</span><span class="p">:</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">G_sim</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
                <span class="c1"># print(&#39;partition type MVP&#39;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">G_sim</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">,</span>
                                                     <span class="n">resolution_parameter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_parameter</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_type</span> <span class="o">==</span> <span class="s1">&#39;ModularityVP&#39;</span><span class="p">:</span>
                <span class="c1"># print(&#39;partition type MVP&#39;)</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">G_sim</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;partition type RBC&#39;</span><span class="p">)</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">G_sim</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">,</span>
                                                     <span class="n">resolution_parameter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_parameter</span><span class="p">)</span>
        <span class="n">PARC_labels_leiden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span>
        <span class="n">PARC_labels_leiden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">,</span> <span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">small_pop_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">small_cluster_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">small_pop_exist</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">dummy</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">):</span>
            <span class="n">population</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PARC_labels_leiden</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">population</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">small_pop_exist</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">small_pop_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PARC_labels_leiden</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">small_cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">small_cluster</span> <span class="ow">in</span> <span class="n">small_pop_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">single_cell</span> <span class="ow">in</span> <span class="n">small_cluster</span><span class="p">:</span>
                <span class="n">old_neighbors</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="p">[</span><span class="n">single_cell</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">group_of_old_neighbors</span> <span class="o">=</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">old_neighbors</span><span class="p">]</span>
                <span class="n">group_of_old_neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group_of_old_neighbors</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="n">available_neighbours</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">group_of_old_neighbors</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">small_cluster_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_neighbours</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">available_neighbours_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">group_of_old_neighbors</span> <span class="k">if</span>
                                                 <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">available_neighbours</span><span class="p">)]</span>
                    <span class="n">best_group</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">available_neighbours_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">available_neighbours_list</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
                    <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">single_cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_group</span>

        <span class="n">do_while_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">small_pop_exist</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">do_while_time</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">small_pop_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">small_pop_exist</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="o">.</span><span class="n">flatten</span><span class="p">())):</span>
                <span class="n">population</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PARC_labels_leiden</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">population</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="n">small_pop_exist</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">small_pop_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PARC_labels_leiden</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">small_cluster</span> <span class="ow">in</span> <span class="n">small_pop_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">single_cell</span> <span class="ow">in</span> <span class="n">small_cluster</span><span class="p">:</span>
                    <span class="n">old_neighbors</span> <span class="o">=</span> <span class="n">neighbor_array</span><span class="p">[</span><span class="n">single_cell</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">group_of_old_neighbors</span> <span class="o">=</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">old_neighbors</span><span class="p">]</span>
                    <span class="n">group_of_old_neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group_of_old_neighbors</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">best_group</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">group_of_old_neighbors</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">group_of_old_neighbors</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
                    <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">single_cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_group</span>

        <span class="n">dummy</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">PARC_labels_leiden</span>
        <span class="k">return</span> <span class="n">PARC_labels_leiden</span>

    <span class="k">def</span> <span class="nf">find_root_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_dense</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span><span class="p">,</span> <span class="n">root_user</span><span class="p">,</span> <span class="n">true_labels</span><span class="p">,</span> <span class="n">super_cluster_labels_sub</span><span class="p">,</span>
                        <span class="n">super_node_degree_list</span><span class="p">):</span>
        <span class="c1"># PARC_labels_leiden is the subset belonging to the component of the graph being considered. graph_dense is a component of the full graph</span>
        <span class="c1"># returns the cluster most likely corresponding to the root (initial) state on the cluster the graph</span>
        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">graph_node_label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_deg</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">super_min_deg</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">found_super_and_sub_root</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">found_any_root</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>

        <span class="n">deg_list</span> <span class="o">=</span> <span class="n">graph_dense</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)))):</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">majority_truth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_cluster_labels</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">super_majority_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">super_cluster_labels_sub</span><span class="p">)[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>
                <span class="n">super_majority_cluster_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">super_cluster_labels_sub</span><span class="p">)</span> <span class="o">==</span> <span class="n">super_majority_cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">super_majority_truth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">super_majority_cluster_loc</span><span class="p">]))</span>
                <span class="n">super_node_degree</span> <span class="o">=</span> <span class="n">super_node_degree_list</span><span class="p">[</span><span class="n">super_majority_cluster</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root_user</span><span class="p">)</span> <span class="ow">in</span> <span class="n">majority_truth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root_user</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">super_majority_truth</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">super_node_degree</span> <span class="o">&lt;</span> <span class="n">super_min_deg</span><span class="p">:</span>
                        <span class="n">found_super_and_sub_root</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">cluster_i</span>
                        <span class="n">found_any_root</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">min_deg</span> <span class="o">=</span> <span class="n">deg_list</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span>
                        <span class="n">super_min_deg</span> <span class="o">=</span> <span class="n">super_node_degree</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">New root is </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">majority_truth_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">)</span>

            <span class="n">graph_node_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_cluster_labels</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">found_super_and_sub_root</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># print(&#39;self.super_cluster_labels&#39;, super_cluster_labels_sub, &#39; foundsuper_cluster_sub and super root&#39;,found_super_and_sub_root)</span>
            <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)))):</span>
                <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># print(&#39;cluster&#39;, cluster_i, &#39;set true labels&#39;, set(true_labels))</span>
                <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>

                <span class="n">majority_truth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">cluster_i</span><span class="p">,</span> <span class="s1">&#39;has majority&#39;</span><span class="p">,</span> <span class="n">majority_truth</span><span class="p">)</span>  <span class="c1"># , &#39;with degree list&#39;, deg_list)</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root_user</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)):</span>  <span class="c1"># &#39;in&#39; not ==</span>
                    <span class="k">if</span> <span class="n">deg_list</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_deg</span><span class="p">:</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">cluster_i</span>
                        <span class="n">found_any_root</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">min_deg</span> <span class="o">=</span> <span class="n">deg_list</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">New root is </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2"> and majority </span><span class="si">{</span><span class="n">majority_truth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># print(&#39;len graph node label&#39;, graph_node_label)</span>
        <span class="k">if</span> <span class="n">found_any_root</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Setting arbitrary root </span><span class="si">{</span><span class="n">cluster_i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">cluster_i</span>
        <span class="k">return</span> <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">deg_list</span><span class="p">,</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">make_majority_truth_cluster_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span><span class="p">,</span> <span class="n">true_labels</span><span class="p">,</span> <span class="n">graph_dense</span><span class="p">):</span>
        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">graph_node_label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>
        <span class="n">deg_list</span> <span class="o">=</span> <span class="n">graph_dense</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)))):</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">majority_truth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>

            <span class="n">majority_truth_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">)</span>

            <span class="n">graph_node_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">))</span>
            <span class="n">deg_list</span> <span class="o">=</span> <span class="n">graph_dense</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">deg_list</span>

    <span class="k">def</span> <span class="nf">find_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_dense</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span><span class="p">,</span> <span class="n">root_user</span><span class="p">,</span> <span class="n">true_labels</span><span class="p">):</span>
        <span class="c1"># root-user is the singlecell index given by the user when running VIA</span>
        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">graph_node_label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>

        <span class="n">deg_list</span> <span class="o">=</span> <span class="n">graph_dense</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)))):</span>
            <span class="c1"># print(&#39;cluster i&#39;, cluster_i)</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">majority_truth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>

            <span class="n">majority_truth_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">)</span>

            <span class="n">graph_node_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">))</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">root_user</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">deg_list</span><span class="p">,</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">find_root_2Morgan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_dense</span><span class="p">,</span> <span class="n">PARC_labels_leiden</span><span class="p">,</span> <span class="n">root_idx</span><span class="p">,</span> <span class="n">true_labels</span><span class="p">):</span>
        <span class="c1"># single cell index given corresponding to user defined root cell</span>
        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">graph_node_label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>

        <span class="n">deg_list</span> <span class="o">=</span> <span class="n">graph_dense</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">secondary_annotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">secondary_annotations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)))):</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">majority_truth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>
            <span class="n">majority_truth_secondary</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">secondary_annotations</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>
            <span class="n">majority_truth_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">)</span>

            <span class="c1"># graph_node_label.append(str(majority_truth)[0:5] + &#39;C&#39; + str(cluster_i))</span>
            <span class="n">graph_node_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">majority_truth</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;C&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">majority_truth_secondary</span><span class="p">))</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">deg_list</span><span class="p">,</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">full_graph_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_components_original</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># make igraph object of very low-K KNN using the knn_struct PCA-dimension space made in PARC.</span>
        <span class="c1"># This is later used by find_shortest_path for sc_bp visual</span>
        <span class="c1"># neighbor array is not listed in in any order of proximity</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">The number of components in the original full graph is </span><span class="si">{</span><span class="n">n_components_original</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">For downstream visualization purposes we are also constructing a low knn-graph &quot;</span><span class="p">)</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">n_comp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_components_original</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n_components_original</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">n_components_original</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k0</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">n_comp</span> <span class="o">&gt;</span> <span class="n">n_components_original</span><span class="p">):</span>
            <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k0</span><span class="p">)</span>
            <span class="n">csr_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">auto_</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">n_comp</span><span class="p">,</span> <span class="n">comp_labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">csr_array</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k0</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># print(f&quot;{datetime.now()}\t the size of neighbor array in low-KNN in pca-space for visualization is {neighbors.shape}&quot;)</span>
        <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span> <span class="o">*</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">csr_full_graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">distances</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">csr_full_graph</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())))</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">do_impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_gene</span><span class="p">,</span> <span class="n">magic_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">gene_list</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># ad_gene is an ann data object from scanpy</span>
        <span class="c1"># normalize across columns to get Transition matrix.</span>
        <span class="n">transition_full_graph</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">magic_steps</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of transition matrix raised to power&#39;</span><span class="p">,</span> <span class="n">magic_steps</span><span class="p">,</span> <span class="n">transition_full_graph</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">df_gene</span><span class="p">[</span><span class="n">gene_list</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">transition_full_graph</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">subset</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">df_gene</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">gene_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_subPARC</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Construct graph or obtain from previous run</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coarse</span><span class="p">:</span>

            <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                             <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span>  <span class="c1"># these n, d will be used as a basis for both the clustergraph and graph which we apply community detection. These two graphs are constructed differently because in the community detection we want to emphasize dissimiliarities,</span>
            <span class="c1"># but the in the clustergraph we want to enhance connectivity</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># refine the graph for clustering (leiden) using time_series labels if available</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Using time series information to guide knn graph construction &quot;</span><span class="p">)</span>

                <span class="n">n_augmented</span><span class="p">,</span> <span class="n">d_augmented</span> <span class="o">=</span> <span class="n">sequential_knn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span>
                                                          <span class="n">k_seq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential</span><span class="p">,</span>
                                                          <span class="n">k_reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential_reverse</span><span class="p">,</span>
                                                          <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>

                <span class="n">adjacency_augmented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">n_augmented</span><span class="p">,</span> <span class="n">d_augmented</span><span class="p">,</span>
                                                                      <span class="n">time_series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series</span><span class="p">,</span>
                                                                      <span class="n">time_series_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">,</span>
                                                                      <span class="n">t_diff_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_diff_step</span><span class="p">)</span>  <span class="c1"># this function has local pruning which removes neighbors that are more than t_dif apart. Since the same type of local pruning wrt t_dif is applied pre-clustergraph, we only need to call this function once in the case of time_series data</span>

                <span class="c1"># adjacency_augmented.data.fill(1)</span>

<span class="w">                </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                embedding = via_atlas_emb(self.data, adjacency_augmented, n_epochs=100, min_dist=0.5, spread=1, distance_metric = &#39;euclidean&#39;)</span>
<span class="sd">                plt.scatter(embedding[:, 0], embedding[:, 1], c=self.time_series_labels, cmap=&#39;viridis&#39;, s=2, alpha=0.3)</span>
<span class="sd">                title = &#39;euc&#39; + &#39;k_kseq_pc&#39; + str(self.knn) + &#39;_&#39; + str(</span>
<span class="sd">                    self.knn_sequential) + &#39;_&#39; + str(self.data.shape[1])</span>
<span class="sd">                plt.title(title)</span>
<span class="sd">                plt.show()</span>
<span class="sd">                &#39;&#39;&#39;</span>

                <span class="c1"># adjacency_augmented_clus = self._make_csrmatrix_noselfloop(neighbors, distances,   time_series=self.time_series,  time_series_labels=self.time_series_labels, t_diff_step=0.5)  # this function has loca</span>

                <span class="c1"># adjacency =adjacency_augmented_clus</span>
                <span class="c1"># adjacency.data.fill(1)</span>
                <span class="n">adjacency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>  <span class="c1"># not augmented or t_diff&#39;ed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjacency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span>
                                                            <span class="n">distances</span><span class="p">)</span>  <span class="c1"># , min_max_scale=True) #this function has local pruning based on edge distances</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_neighbor_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_array</span>
            <span class="n">adjacency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">adjacency</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())))</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">data</span><span class="p">})</span><span class="o">.</span><span class="n">similarity_jaccard</span><span class="p">(</span>
                <span class="n">pairs</span><span class="o">=</span><span class="n">edges</span><span class="p">))</span>  <span class="c1"># used to do igraph jaccard does not use  weight information to compute Jacc</span>
        <span class="c1"># sim = adjacency.data</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

        <span class="c1"># Prune Jacc weighted edges off graph on global level</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span> <span class="k">else</span> <span class="n">sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">strong_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># to be used for leiden paritionining clustering</span>
        <span class="n">g_local_global_jac</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">strong_locs</span><span class="p">]),</span>
                                      <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">strong_locs</span><span class="p">])})</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
            <span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>  <span class="c1"># used for the clustering step and has been locally and globally pruned</span>
        <span class="c1"># jac_sim_list = g_local_global_jac.similarity_jaccard(pairs=list(edges[strong_locs]))</span>
        <span class="c1"># g_local_global_jac =ig.Graph(n=self.nsamples, edges=list(edges[strong_locs]), edge_attrs={&#39;weight&#39;: jac_sim_list}).simplify(combine_edges=&#39;sum&#39;) #used for clustering (globally and locally pruned) and then jacc weighted (Jacc does not consider weights)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_glob_loc_pruned</span> <span class="o">=</span> <span class="n">get_sparse_from_igraph</span><span class="p">(</span><span class="n">g_local_global_jac</span><span class="p">,</span> <span class="n">weight_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Finished global pruning of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="si">}</span><span class="s2">-knn graph used for clustering at level of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span><span class="si">}</span><span class="s2">. Kept </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">strong_locs</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">tot</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2"> % of edges. &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coarse</span><span class="p">:</span>
            <span class="c1"># Construct full graph with no pruning - used for cluster graph edges, not listed in any order of proximity</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

                <span class="n">csr_full_graph</span> <span class="o">=</span> <span class="n">adjacency_augmented</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># when time_series data is available</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RW2_mode</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;saving csr for RW2&quot;</span><span class="p">)</span>
                    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">save_npz</span>
                    <span class="n">str_date</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unique ID for RW2 file </span><span class="si">{</span><span class="n">str_date</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">save_npz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">working_dir_fp</span> <span class="o">+</span> <span class="s1">&#39;pc&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_knn&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;kseq&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;krev&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential_reverse</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;RW2_&#39;</span> <span class="o">+</span> <span class="n">str_date</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">,</span>
                             <span class="n">csr_full_graph</span><span class="p">)</span>

            <span class="c1"># when no time-series data is available, in this iteration of weighting the edges we do not locally prune based on edge-weights becasue we intend to use all neighborhood info towards the edges in the clustergraph and ensuring the clustergraph is connected</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">csr_full_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_csrmatrix_noselfloop</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">auto_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_max_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                 <span class="n">time_series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series</span><span class="p">,</span>
                                                                 <span class="n">time_series_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">)</span>  <span class="c1"># no local pruning: auto_ set to false #min_max_scale=True</span>
            <span class="n">n_original_comp</span><span class="p">,</span> <span class="n">n_original_comp_labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Number of connected components used for clustergraph  is </span><span class="si">{</span><span class="n">n_original_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pca_loadings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

                <span class="n">edges_preClustergraph</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">csr_full_graph</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()))</span>  <span class="c1"># in the case of time-series, this is the augmented graph</span>
                <span class="c1"># projected_distances are the inverted Projected_distances (affinities) based on velocity adjusted location of neighbors</span>
                <span class="n">projected_distances</span> <span class="o">=</span> <span class="n">get_projected_distances</span><span class="p">(</span><span class="n">loadings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pca_loadings</span><span class="p">,</span> <span class="n">gene_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span><span class="p">,</span>
                                                              <span class="n">velocity_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span><span class="p">,</span>
                                                              <span class="n">edgelist</span><span class="o">=</span><span class="n">edges_preClustergraph</span><span class="p">,</span> <span class="n">current_pc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">ig_full_graph</span> <span class="o">=</span> <span class="n">_composite_jacAffinity_distanceAffinity</span><span class="p">(</span><span class="n">sc_csr_graph</span><span class="o">=</span><span class="n">csr_full_graph</span><span class="p">,</span>
                                                                             <span class="n">projected_distances</span><span class="o">=</span><span class="n">projected_distances</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this will be used for making the clustergraph. Note that in the case of time-series, this is the augmented graph with weights given by a composite metric of Jaccard and affinities</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ig_full_graph</span> <span class="o">=</span> <span class="n">_composite_jacAffinity_distanceAffinity</span><span class="p">(</span>
                    <span class="n">csr_full_graph</span><span class="p">)</span>  <span class="c1"># 0&lt;J&lt;1 #combining distance-based affinities and jac-based affinities</span>
            <span class="c1"># for VIA we local and global prune the vertex cluster graph *after* making the clustergraph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned</span> <span class="o">=</span> <span class="n">adjacency</span>  <span class="c1"># this graph has only been locally pruned and in the case of time-series, it is not the augmented knn. it then subsequently in later code will be subject to global pruning, followed by Leiden clustering. saving it here for non-coarse runs</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned_augmented</span> <span class="o">=</span> <span class="n">adjacency_augmented</span>  <span class="c1"># t_diff edges removed and is sequentially augmented affinity graph (no Jaccard metric is added)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">csr_array_locally_pruned_augmented</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span> <span class="o">=</span> <span class="n">csr_full_graph</span>  <span class="c1"># for timeseries, this is the sequentially augmented graph, and later used in sc_transitions. This can also be used for hnsw_umap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_neighbor_array</span> <span class="o">=</span> <span class="n">neighbors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_array</span> <span class="o">=</span> <span class="n">distances</span>

            <span class="c1"># knn graph used for making trajectory drawing on the visualization</span>
            <span class="c1"># self.full_graph_shortpath = self.full_graph_paths(self.data, n_original_comp)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_neighbor_array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Commencing community detection&quot;</span><span class="p">)</span>  <span class="c1"># this is done on the non-time-series augmented graph to avoid clustering largely based on prior known time-level data</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_weighted_edges</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># type = leidenalg.ModularityVertexPartition if self.partition_type == &#39;ModularityVP&#39; else leidenalg.RBConfigurationVertexPartition</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_type</span> <span class="o">==</span> <span class="s1">&#39;ModularityVP&#39;</span><span class="p">:</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">g_local_global_jac</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span>
                                                     <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
                <span class="c1"># print(&#39;partition type MVP&#39;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">g_local_global_jac</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">,</span>
                                                     <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter_leiden</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">,</span>
                                                     <span class="n">resolution_parameter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_parameter</span><span class="p">)</span>
            <span class="c1"># partition = leidenalg.find_partition(g_local_global_jac, partition_type=type, weights=weights,                                             n_iterations=self.n_iter_leiden, seed=self.random_seed)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Finished running Leiden algorithm. Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span><span class="si">}</span><span class="s2"> clusters.&quot;</span><span class="p">)</span>

            <span class="c1"># Searching for clusters that are too big and split them</span>
            <span class="n">too_big_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">too_big_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">too_big_clusters</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">too_big_clusters</span><span class="p">)</span><span class="si">}</span><span class="s2"> clusters that are too big&quot;</span><span class="p">)</span>

            <span class="n">time0_big</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">count_big_pop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">too_big_clusters</span><span class="p">)</span>
            <span class="n">num_times_expanded</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># TODO - add max running time condition</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">too_big_clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0_big</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">num_times_expanded</span> <span class="o">&gt;=</span> <span class="n">count_big_pop</span><span class="p">))):</span>
                <span class="c1"># while len(too_big_clusters) &amp; (not((time.time() - time0_big &gt;200) &amp; (num_times_expanded &gt;= count_big_pop))):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Examining clusters that are above the too_big threshold&quot;</span><span class="p">)</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">too_big_clusters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">cluster</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2"> contains &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">too_big_factor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="si">}</span><span class="s2"> samples and is too big&quot;</span><span class="p">)</span>

                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">membership</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_toobig_subPARC</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">num_times_expanded</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">membership</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">membership</span>
                    <span class="n">too_big_clusters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">too_big_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Could not expand cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Search for clusters that are too small (like singletons) and merge them to non-small clusters based on neighbors&#39; majority vote</span>
            <span class="c1"># first we make a quick pass through all clusters to remove very small outliers by merging with a larger cluster</span>
            <span class="c1"># print(&#39;before final small cluster handling we have&#39;,len(set(labels)), &#39;communities&#39;)</span>

            <span class="n">too_small_clusters</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_pop</span><span class="p">}</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Merging </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">too_small_clusters</span><span class="p">))</span><span class="si">}</span><span class="s2"> very small clusters (&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">small_pop</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">too_small_clusters</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">neighbours_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">neighbours_labels</span><span class="p">]):</span>
                <span class="c1"># Retrieve the first non small cluster, with highest number of neighbours</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">()</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">too_small_clusters</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># label = next((label for label, n in Counter(nl).most_common()), None)</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># recall 0 is a valid label value</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

                <span class="c1"># too_small_clusters = {k for k, v in Counter(labels).items() if v &lt; self.small_pop}</span>
            <span class="n">too_small_clusters</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_pop</span><span class="p">}</span>
            <span class="c1"># in this pass we allow clusters to be merged even if they are not a Large Cluster.. as multiple smaller ones might come together to form an acceptably large cluster</span>
            <span class="n">do_while_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">too_small_clusters</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">do_while_time</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">):</span>
                <span class="c1"># membership of neighbours of samples in small clusters</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">too_small_clusters</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neighbours_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">neighbours_labels</span><span class="p">]):</span>
                    <span class="c1"># Retrieve the first non small cluster, with highest number of neighbours</span>
                    <span class="c1"># label = next((label for label, n in Counter(nl).most_common() if label not in too_small_clusters), None)</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># recall 0 is a valid label value</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
                <span class="c1"># Update set of too small clusters, stopping if converged</span>
                <span class="n">too_small_clusters</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_pop</span><span class="p">}</span>
            <span class="c1"># Reset labels to begin from zero and with no missing numbers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Finished detecting communities. Found&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)),</span> <span class="s1">&#39;communities&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Using predfined labels provided by user (this must be provided as an array)&#39;</span><span class="p">)</span>

        <span class="c1"># end community detection</span>
        <span class="c1"># do kmeans instead</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        from sklearn.cluster import KMeans</span>
<span class="sd">        kmeans = KMeans(n_clusters=20, random_state=1).fit(X_data)</span>
<span class="sd">        self.labels = kmeans.labels_</span>
<span class="sd">        n_clus = len(set(self.labels))</span>
<span class="sd">        self.labels = kmeans.labels_.flatten().tolist()</span>

<span class="sd">        pop_list = []</span>
<span class="sd">        pop_list_raw = []</span>
<span class="sd">        for item in range(len(set(PARC_labels_leiden))):</span>
<span class="sd">            pop_item = PARC_labels_leiden.count(item)</span>
<span class="sd">            pop_list.append((item, pop_item))</span>
<span class="sd">            pop_list_raw.append(pop_item)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Make cluster-graph</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Making cluster graph. Global cluster graph pruning level: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_graph_pruning</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">VertexClustering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ig_full_graph</span><span class="p">,</span> <span class="n">membership</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">cluster_graph</span><span class="p">(</span><span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">recompute_weights</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>  <span class="c1"># returns csr matrix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_graph_csr_not_pruned</span> <span class="o">=</span> <span class="n">graph</span>  <span class="c1"># type csr NOT PRUNED</span>
        <span class="n">edgeweights_pruned_clustergraph</span><span class="p">,</span> <span class="n">edges_pruned_clustergraph</span><span class="p">,</span> <span class="n">comp_labels</span> <span class="o">=</span> <span class="n">pruning_clustergraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span>
                                                                                                       <span class="n">global_pruning_std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_graph_pruning</span><span class="p">,</span>
                                                                                                       <span class="n">preserve_disconnected</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected</span><span class="p">,</span>
                                                                                                       <span class="n">preserve_disconnected_after_pruning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected_after_pruning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connected_comp_labels</span> <span class="o">=</span> <span class="n">comp_labels</span>
        <span class="c1"># ig.graph() creates an undirected graph,in which case get_spare_from_igraph will be symmetric for each edge (u,v) and edge (v,u) is created</span>
        <span class="n">locallytrimmed_g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges_pruned_clustergraph</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span>
            <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">edgeweights_pruned_clustergraph</span><span class="p">})</span>  <span class="c1"># .simplify(combine_edges=&#39;sum&#39;) #forward biasing happens later</span>

        <span class="n">locallytrimmed_sparse_vc</span> <span class="o">=</span> <span class="n">get_sparse_from_igraph</span><span class="p">(</span><span class="n">locallytrimmed_g</span><span class="p">,</span> <span class="n">weight_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_graph_pruning</span><span class="p">:</span>

            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">locallytrimmed_sparse_vc</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># clip weights to prevent distorted visual scale</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span>
                                                       <span class="mi">90</span><span class="p">))</span>  <span class="c1"># want to clip the weights used to get the layout</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">)</span>

            <span class="n">g_layout</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">locallytrimmed_sparse_vc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())),</span>
                                <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weights_for_layout</span><span class="p">})</span>


        <span class="c1"># if using a different pruning for visualized edge bundles than the one specified in self.cluster_graph_pruning</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">edgeweights_layout</span><span class="p">,</span> <span class="n">edges_layout</span><span class="p">,</span> <span class="n">comp_labels_layout</span> <span class="o">=</span> <span class="n">pruning_clustergraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span>
                                                                                        <span class="n">global_pruning_std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning</span><span class="p">,</span>
                                                                                        <span class="n">preserve_disconnected</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected</span><span class="p">,</span>
                                                                                        <span class="n">preserve_disconnected_after_pruning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected_after_pruning</span><span class="p">)</span>

            <span class="c1"># layout = locallytrimmed_g.layout_fruchterman_reingold(weights=&#39;weight&#39;) #uses non-clipped weights but this can skew layout due to one or two outlier edges</span>
            <span class="n">layout_g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges_layout</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">edgeweights_layout</span><span class="p">})</span>  <span class="c1"># .simplify(combine_edges=&#39;sum&#39;) remving the &#39;combined_edges=&#39;sum&#39; as it does not handle diagonal self loops which we require to be retained for singleton clusters that are not connected to other clusters</span>

            <span class="n">layout_g_csr</span> <span class="o">=</span> <span class="n">get_sparse_from_igraph</span><span class="p">(</span><span class="n">layout_g</span><span class="p">,</span> <span class="n">weight_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout_g_csr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">weights_for_layout</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># clip weights to prevent distorted visual scale in layout</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">)</span>

            <span class="n">g_layout</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">layout_g_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())),</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weights_for_layout</span><span class="p">})</span>
        <span class="c1"># the layout of the graph is determine by a pruned clustergraph and the directionality of edges will be based on the final markov pseudotimes</span>
        <span class="c1"># the edgeweights of the bundle-edges is determined by the distance based metrics and jaccard similarities and not by the pseudotimes</span>
        <span class="c1"># for the transition matrix used in the markov pseudotime and differentiation probability computations, the edges will be further biased by the hittings times and markov pseudotimes</span>

        <span class="c1"># layout = g_layout.layout_fruchterman_reingold(weights=&#39;weight&#39;)</span>

        <span class="c1"># globally trimmed link</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgelist_unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">locallytrimmed_sparse_vc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()))</span>  <span class="c1"># keep only one of (0,1) and (1,0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span> <span class="o">=</span> <span class="n">edges_pruned_clustergraph</span>  <span class="c1"># after one round of global and local pruning of graph to be used for MCMCs</span>

        <span class="c1"># number of components</span>
        <span class="n">n_components</span><span class="p">,</span> <span class="n">labels_cc</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">locallytrimmed_sparse_vc</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">df_graph</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">locallytrimmed_sparse_vc</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">df_velocity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;size velocity matrix&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">df_velocity</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
            <span class="n">velocity_mean</span> <span class="o">=</span> <span class="n">df_velocity</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">gene_mean</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_matrix</span><span class="p">)</span>
            <span class="n">gene_mean</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
            <span class="n">gene_mean</span> <span class="o">=</span> <span class="n">gene_mean</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">CSM</span><span class="p">,</span> <span class="n">velo_root_top3</span> <span class="o">=</span> <span class="n">velocity_transition</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">df_graph</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">velocity_mean</span><span class="p">,</span>
                                                                        <span class="n">G</span><span class="o">=</span><span class="n">gene_mean</span><span class="p">)</span>  <span class="c1"># velocity directed transition matrix</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell type of suggested roots:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">velo_root_top3</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell stage of suggested roots:&#39;</span><span class="p">,</span>
                                                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">velo_root_top3</span><span class="p">])</span>

        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;cc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels_cc</span>
        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;majority_truth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;maj truth&#39;</span>
        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;graph_node_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;node label&#39;</span>

        <span class="n">PARC_labels_leiden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="n">set_parc_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">))</span>
        <span class="n">set_parc_labels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">tsi_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
        <span class="n">terminal_clus</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of cluster labels that are found to be terminal clusters</span>
        <span class="n">node_deg_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">super_terminal_clus_revised</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pd_columnnames_terminal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dict_terminal_super_sub_pairs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">large_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_components</span><span class="p">):</span>
            <span class="n">loc_compi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels_cc</span> <span class="o">==</span> <span class="n">comp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_compi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># need at least 2 nodes in in a component to make edges</span>
                <span class="n">large_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_compi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">loc_compi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 0</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">loc_compi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 0</span>

        <span class="k">for</span> <span class="n">comp_i</span> <span class="ow">in</span> <span class="n">large_components</span><span class="p">:</span>  <span class="c1"># range(n_components):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">component number&#39;</span><span class="p">,</span> <span class="n">comp_i</span><span class="p">,</span> <span class="s1">&#39;out of &#39;</span><span class="p">,</span> <span class="n">large_components</span><span class="p">)</span>
            <span class="n">loc_compi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels_cc</span> <span class="o">==</span> <span class="n">comp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">a_i</span> <span class="o">=</span> <span class="n">df_graph</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">loc_compi</span><span class="p">][</span><span class="n">loc_compi</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># transition matrix of relevant component</span>
            <span class="c1"># A_velo, CSM = velocity_transition(A=a_i, V=velocity_mean,   G=gene_mean)  # velocity directed transition matrix</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">A_velo</span><span class="p">,</span> <span class="n">CSM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span><span class="p">[</span><span class="n">loc_compi</span><span class="p">,</span> <span class="p">:][</span><span class="n">loc_compi</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">CSM</span><span class="p">[</span><span class="n">loc_compi</span><span class="p">,</span> <span class="p">:][</span>
                                                                                               <span class="n">loc_compi</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">a_i</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="p">(</span><span class="n">a_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">cluster_labels_subi</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">loc_compi</span><span class="p">]</span>
            <span class="c1"># print(&#39;cluster_labels_subi&#39;, cluster_labels_subi)</span>
            <span class="n">sc_labels_subi</span> <span class="o">=</span> <span class="p">[</span><span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">))</span> <span class="k">if</span>
                              <span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_labels_subi</span><span class="p">)]</span>

            <span class="n">sc_truelabels_subi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">))</span> <span class="k">if</span>
                                  <span class="p">(</span><span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_labels_subi</span><span class="p">)]</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># in case the root cluster is a singleton, move on to the next nominee in initial states</span>
                <span class="n">root_i</span> <span class="o">=</span> <span class="n">velo_root_top3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_labels_subi</span><span class="p">)</span> <span class="o">==</span> <span class="n">root_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_i_loc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">root_i</span> <span class="o">=</span> <span class="n">velo_root_top3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_labels_subi</span><span class="p">)</span> <span class="o">==</span> <span class="n">root_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_i_loc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">root_i</span> <span class="o">=</span> <span class="n">velo_root_top3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_labels_subi</span><span class="p">)</span> <span class="o">==</span> <span class="n">root_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_i_loc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">root_i</span> <span class="o">=</span> <span class="n">velo_root_top3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">node_deg_list_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_majority_truth_cluster_labels</span><span class="p">(</span>
                    <span class="n">PARC_labels_leiden</span><span class="o">=</span><span class="n">sc_labels_subi</span><span class="p">,</span> <span class="n">true_labels</span><span class="o">=</span><span class="n">sc_truelabels_subi</span><span class="p">,</span> <span class="n">graph_dense</span><span class="o">=</span><span class="n">a_i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">velo_root_candidate_i</span> <span class="ow">in</span> <span class="n">velo_root_top3</span><span class="p">:</span>
                    <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_labels_subi</span><span class="p">)</span> <span class="o">==</span> <span class="n">velo_root_candidate_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">majority_truth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_truelabels_subi</span><span class="p">)[</span><span class="n">cluster_i_loc</span><span class="p">])))</span>
                    <span class="k">if</span> <span class="n">velo_root_candidate_i</span> <span class="o">==</span> <span class="n">root_i</span><span class="p">:</span> <span class="n">majority_truth_veloroot0</span> <span class="o">=</span> <span class="n">majority_truth</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Using the RNA velocity graph, A top3 candidate for initial state is </span><span class="si">{</span><span class="n">velo_root_candidate_i</span><span class="si">}</span><span class="s2"> comprising predominantly of </span><span class="si">{</span><span class="n">majority_truth</span><span class="si">}</span><span class="s2"> cells&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Using the RNA velocity graph, the suggested initial root state is </span><span class="si">{</span><span class="n">root_i</span><span class="si">}</span><span class="s2"> comprising predominantly of </span><span class="si">{</span><span class="n">majority_truth_veloroot0</span><span class="si">}</span><span class="s2"> cells&quot;</span><span class="p">)</span>


            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;toy&#39;</span><span class="p">,</span> <span class="s1">&#39;faced&#39;</span><span class="p">,</span> <span class="s1">&#39;mESC&#39;</span><span class="p">,</span> <span class="s1">&#39;iPSC&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">root_user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># ((self.dataset == &#39;toy&#39;) | (self.dataset == &#39;faced&#39;)):</span>
                <span class="n">root_user_</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_user</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">group root method&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">sc_truelabels_subi</span><span class="p">:</span>
                        <span class="n">root_user_</span> <span class="o">=</span> <span class="n">ri</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">for component </span><span class="si">{</span><span class="n">comp_i</span><span class="si">}</span><span class="s2">, the root is </span><span class="si">{</span><span class="n">root_user_</span><span class="si">}</span><span class="s2"> and ri </span><span class="si">{</span><span class="n">ri</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root_user_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">root_user_</span> <span class="o">=</span> <span class="n">sc_truelabels_subi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">setting a dummy root&quot;</span><span class="p">)</span>


                <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">node_deg_list_i</span><span class="p">,</span> <span class="n">root_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_root_group</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span>
                                                                                                            <span class="n">sc_labels_subi</span><span class="p">,</span>
                                                                                                            <span class="n">root_user_</span><span class="p">,</span>
                                                                                                            <span class="n">sc_truelabels_subi</span><span class="p">,</span>
                                                                                                            <span class="p">[],</span> <span class="p">[])</span>


            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">==</span> <span class="s1">&#39;2M&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_user</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_labels_subi</span><span class="p">:</span> <span class="n">root_user_</span> <span class="o">=</span> <span class="n">ri</span>
                <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">node_deg_list_i</span><span class="p">,</span> <span class="n">root_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_root_2Morgan</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span>
                                                                                                          <span class="n">sc_labels_subi</span><span class="p">,</span>
                                                                                                          <span class="n">root_user_</span><span class="p">,</span>
                                                                                                          <span class="n">sc_truelabels_subi</span><span class="p">)</span>

            <span class="c1"># when root_user is given as a cell index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">root_user_</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">comp_i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_user</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">root_user_</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_user</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_labels_subi</span><span class="p">:</span>
                            <span class="n">root_user_</span> <span class="o">=</span> <span class="n">ri</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">The root index, </span><span class="si">{</span><span class="n">ri</span><span class="si">}</span><span class="s2"> provided by the user belongs to cluster number </span><span class="si">{</span><span class="n">PARC_labels_leiden</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="si">}</span><span class="s2"> and corresponds to cell type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root_user_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">root_user_</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">graph_node_label</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">node_deg_list_i</span><span class="p">,</span> <span class="n">root_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_root</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span>
                                                                                                  <span class="n">PARC_labels_leiden</span><span class="p">,</span>
                                                                                                  <span class="n">root_user_</span><span class="p">,</span>
                                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">majority_truth_labels</span>  <span class="c1"># single cell level &quot;Majority Truth of that Cluster + Clusterlabel&quot;</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node_deg_list_i</span><span class="p">:</span>
                <span class="n">node_deg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="n">new_root_index_found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">llabel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">root_i</span> <span class="o">==</span> <span class="n">llabel</span><span class="p">:</span>
                    <span class="n">new_root_index</span> <span class="o">=</span> <span class="n">ii</span>
                    <span class="n">new_root_index_found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_root_index_found</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find the new root index&#39;</span><span class="p">)</span>
                <span class="n">new_root_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Computing lazy-teleporting expected hitting times&quot;</span><span class="p">)</span>
            <span class="n">hitting_times</span><span class="p">,</span> <span class="n">roundtrip_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_hitting_time</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">new_root_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_lazy</span><span class="p">,</span>
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">alpha_teleport</span><span class="p">)</span>
            <span class="c1"># rescale hitting times</span>
            <span class="n">very_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hitting_times</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">hitting_times</span><span class="p">)</span>
            <span class="n">without_very_high_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">iii</span> <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="n">hitting_times</span> <span class="k">if</span> <span class="n">iii</span> <span class="o">&lt;</span> <span class="n">very_high</span><span class="p">]</span>
            <span class="n">new_very_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">without_very_high_pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">without_very_high_pt</span><span class="p">)</span>
            <span class="c1"># print(&#39;very high, and new very high&#39;, very_high, new_very_high)</span>
            <span class="n">new_hitting_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">very_high</span> <span class="k">else</span> <span class="n">very_high</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hitting_times</span><span class="p">]</span>
            <span class="n">hitting_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_hitting_times</span><span class="p">)</span>
            <span class="n">scaling_fac</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">hitting_times</span><span class="p">)</span>
            <span class="n">hitting_times</span> <span class="o">=</span> <span class="n">hitting_times</span> <span class="o">*</span> <span class="n">scaling_fac</span>
            <span class="n">s_ai</span><span class="p">,</span> <span class="n">t_ai</span> <span class="o">=</span> <span class="n">a_i</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="n">edgelist_ai</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">s_ai</span><span class="p">,</span> <span class="n">t_ai</span><span class="p">))</span>
            <span class="n">edgeweights_ai</span> <span class="o">=</span> <span class="n">a_i</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># print(&#39;edgelist ai&#39;, edgelist_ai)</span>
            <span class="c1"># print(&#39;edgeweight ai&#39;, edgeweights_ai)</span>
            <span class="c1"># bias the edges based on pseudotime from &quot;undirected&quot; pruned graph</span>
            <span class="n">biased_edgeweights_ai</span> <span class="o">=</span> <span class="n">get_biased_weights</span><span class="p">(</span><span class="n">edgelist_ai</span><span class="p">,</span> <span class="n">edgeweights_ai</span><span class="p">,</span> <span class="n">hitting_times</span><span class="p">)</span>

            <span class="c1"># biased_sparse = csr_matrix((biased_edgeweights, (row, col)))</span>
            <span class="n">adjacency_matrix_ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist_ai</span><span class="p">):</span>
                <span class="n">adjacency_matrix_ai</span><span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">biased_edgeweights_ai</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">markov_hitting_times_ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate_markov</span><span class="p">(</span><span class="n">adjacency_matrix_ai</span><span class="p">,</span>
                                                           <span class="n">new_root_index</span><span class="p">)</span>  <span class="c1"># +adjacency_matrix.T))</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            df_sc = pd.DataFrame()</span>
<span class="sd">            df_sc[&#39;parc&#39;] = self.labels</span>
<span class="sd">            df_sc[&#39;true_time&#39;] = self.time_series_labels</span>
<span class="sd">            df_ = df_sc.groupby([&#39;parc&#39;]).mean()</span>
<span class="sd">            df_[&#39;via_pt&#39;] = markov_hitting_times_ai</span>
<span class="sd">            df_[&#39;via_pt&#39;] = df_[&#39;via_pt&#39;].fillna(0)</span>

<span class="sd">            correlation = df_[&#39;via_pt&#39;].corr(df_[&#39;true_time&#39;])</span>
<span class="sd">            print(f&#39;correlation cluster level via original mcmc pt before scaling, {correlation}&#39;)</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;try rw2 hitting times setup&#39;</span><span class="p">)</span>
            <span class="n">memory_pt</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># 2</span>
            <span class="n">rw2_hittingtimes</span> <span class="o">=</span> <span class="n">_compute_rw2_hittingtimes</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">adjacency_matrix_ai</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">new_root_index</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">memory_pt</span><span class="p">,</span>
                                                        <span class="n">x_lazy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x_lazy</span><span class="p">,</span> <span class="n">alpha_teleport</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_teleport</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            df_sc = pd.DataFrame()</span>
<span class="sd">            df_sc[&#39;parc&#39;] = self.labels</span>
<span class="sd">            df_sc[&#39;true_time&#39;] = self.time_series_labels</span>
<span class="sd">            df_ = df_sc.groupby([&#39;parc&#39;]).mean()</span>
<span class="sd">            df_[&#39;via_pt&#39;] = rw2_hittingtimes</span>
<span class="sd">            df_[&#39;via_pt&#39;] = df_[&#39;via_pt&#39;].fillna(0)</span>


<span class="sd">            correlation = df_[&#39;via_pt&#39;].corr(df_[&#39;true_time&#39;])</span>
<span class="sd">            print(f&#39;correlation via rw2 pt at memory q={memory} before scaling, {correlation}&#39;)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;memory for rw2 hittings times  </span><span class="si">{</span><span class="n">memory_pt</span><span class="si">}</span><span class="s1">. Using rw2 based pt&#39;</span><span class="p">)</span>
            <span class="n">markov_hitting_times_ai</span> <span class="o">=</span> <span class="n">rw2_hittingtimes</span>

            <span class="c1"># print(&#39;no rw2&#39;)</span>
            <span class="c1"># print(&#39;skip scaling of pt&#39;)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;do scaling of pt&#39;</span><span class="p">)</span>

            <span class="n">very_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">)</span>  <span class="c1"># 1.5</span>
            <span class="n">very_high</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">very_high</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">))</span>
            <span class="c1"># without_very_high_pt = [iii for iii in markov_hitting_times_ai if iii &lt; very_high]</span>
            <span class="c1"># new_very_high = min(np.mean(without_very_high_pt) + np.std(without_very_high_pt), very_high)</span>

            <span class="n">new_markov_hitting_times_ai</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">very_high</span> <span class="k">else</span> <span class="n">very_high</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">markov_hitting_times_ai</span><span class="p">]</span>

            <span class="n">markov_hitting_times_ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_markov_hitting_times_ai</span><span class="p">)</span>
            <span class="n">scaling_fac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">)</span>
            <span class="n">markov_hitting_times_ai</span> <span class="o">=</span> <span class="n">markov_hitting_times_ai</span> <span class="o">*</span> <span class="n">scaling_fac</span>

            <span class="c1"># for eee, ttt in enumerate(markov_hitting_times_ai):print(&#39;cluster &#39;, eee, &#39; had markov time&#39;, ttt)</span>

            <span class="c1"># print(&#39;markov hitting times&#39;, [(i, j) for i, j in enumerate(markov_hitting_times_ai)])</span>
            <span class="c1"># print(&#39;hitting times&#39;, [(i, j) for i, j in enumerate(hitting_times)])</span>
            <span class="c1"># markov_hitting_times_ai = (markov_hitting_times_ai)  # + hitting_times)*.5 #consensus</span>
            <span class="n">adjacency_matrix_csr_ai</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adjacency_matrix_ai</span><span class="p">)</span>
            <span class="c1"># A_velo = velocity_transition(A=adjacency_matrix_ai, V=velocity_mean, G=gene_mean) #velocity directed transition matrix</span>
            <span class="c1"># print(&#39;A_velo&#39;, A_velo.shape)</span>
            <span class="c1"># print(A_velo)</span>
            <span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span> <span class="o">=</span> <span class="n">adjacency_matrix_csr_ai</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="n">edgelist_ai</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">targets</span><span class="p">))</span>
            <span class="n">weights_ai</span> <span class="o">=</span> <span class="n">adjacency_matrix_csr_ai</span><span class="o">.</span><span class="n">data</span>
            <span class="n">bias_weights_2_ai</span> <span class="o">=</span> <span class="n">get_biased_weights</span><span class="p">(</span><span class="n">edgelist_ai</span><span class="p">,</span> <span class="n">weights_ai</span><span class="p">,</span> <span class="n">markov_hitting_times_ai</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">adjacency_matrix2_ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">adjacency_matrix_ai</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">adjacency_matrix_ai</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># this will be the cluster transition matrix forward biased by pseudotimes</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist_ai</span><span class="p">):</span>
                <span class="n">adjacency_matrix2_ai</span><span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">bias_weights_2_ai</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># print(&#39;adjacency_matrix2_ai col sum&#39;, np.sum(adjacency_matrix2_ai, axis=1))</span>
            <span class="c1"># adjacency matrix used for branch prob and terminal states will be the weighted average of the pt_trans_matrix and the velo_trans_matrix</span>
            <span class="c1"># note that although A_velo and adjaccency_matrix2_ai do not have rows that sum to one due to the biasing steps, the transition matrix used for simulating branch probabilities will be normalized such that each row_sum = 1. This is done in the simulate_branch_prob function</span>
            <span class="c1"># however the biased weights without row normalization is used for visualization</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">adjacency_matrix2_ai</span> <span class="o">=</span> <span class="p">(</span>
                                                                           <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">adjacency_matrix2_ai</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span> <span class="o">*</span> <span class="n">A_velo</span>
            <span class="n">user_defined_terminal_clus_exists</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_cell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">user_defined_terminal_clus_exists</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_terminal_cells</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">user_defined_terminal_clus_exists</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>  <span class="c1"># when is_coarse = True, there is no list of terminal clusters/cells that are passed into VIA based on a previous iteration.</span>
                <span class="c1"># print(&#39;new_root_index&#39;, new_root_index, &#39; before get terminal&#39;)</span>
                <span class="n">terminal_clus_ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_terminal_clusters</span><span class="p">(</span><span class="n">adjacency_matrix2_ai</span><span class="p">,</span> <span class="n">markov_hitting_times_ai</span><span class="p">,</span>
                                                              <span class="n">new_root_index</span><span class="p">)</span>
                <span class="n">temp_terminal_clus_ai</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">threshold_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_threshold_TS</span><span class="p">)</span>
                <span class="c1">#print(&#39;!!! Remove the [0:2] just using to speed up testing&#39;)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terminal_clus_ai</span><span class="p">:</span><span class="c1">#[0:2]:</span>

                    <span class="k">if</span> <span class="n">markov_hitting_times_ai</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_</span><span class="p">:</span>
                        <span class="n">terminal_clus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">temp_terminal_clus_ai</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">terminal_clus_ai</span> <span class="o">=</span> <span class="n">temp_terminal_clus_ai</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_terminal_cells</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">user_defined_terminal_clus_exists</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">terminal_clus_ai</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">terminal_clus</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">threshold_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">markov_hitting_times_ai</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_threshold_TS</span><span class="p">)</span>
                <span class="n">terminal_clus_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_terminal_clusters_user_defined_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_cell</span><span class="p">,</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">user_defined_terminal_group</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">terminal_clus_temp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">ti</span> <span class="ow">in</span> <span class="n">loc_compi</span><span class="p">):</span>
                        <span class="n">terminal_clus_ai</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span>
                        <span class="n">terminal_clus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Terminal clusters corresponding to unique lineages in this component are </span><span class="si">{</span><span class="n">terminal_clus_ai</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">use_rw2_prob</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_rw2_prob</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_rw2_prob</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Via 1.0 lineage prob&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target_terminal</span> <span class="ow">in</span> <span class="n">terminal_clus_ai</span><span class="p">:</span>

                    <span class="n">prob_ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_branch_probability</span><span class="p">(</span><span class="n">target_terminal</span><span class="p">,</span>
                                                               <span class="n">adjacency_matrix2_ai</span><span class="p">,</span>
                                                               <span class="n">new_root_index</span><span class="p">,</span>
                                                               <span class="n">num_sim</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mcmc_simulations</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;terminal state </span><span class="si">{</span><span class="n">target_terminal</span><span class="si">}</span><span class="s1"> has probability </span><span class="si">{</span><span class="n">prob_ai</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">0.0000000</span>

                    <span class="n">pd_columnnames_terminal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">]))</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">prob_ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob_ai</span><span class="p">):</span>
                        <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                            <span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">])]</span> <span class="o">=</span> <span class="n">prob_ii</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span>
                <span class="n">p_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_memory</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;TESTING rw2_lineage probability at memory </span><span class="si">{</span><span class="n">memory</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># prob_linn_rw2 = _compute_rw2_lineageprobability(A=adjacency_matrix2_ai, memory=0.1, root=new_root_index, terminal_states=terminal_clus_ai)</span>
                <span class="c1"># prob_linn_rw2 = _compute_rw2_lineageprobability(A = adjacency_matrix2_ai, memory=1, root = new_root_index, terminal_states = terminal_clus_ai)</span>
                <span class="n">prob_lin_rw2</span> <span class="o">=</span> <span class="n">_compute_rw2_lineageprobability</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">adjacency_matrix2_ai</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">,</span>
                                                              <span class="n">root</span><span class="o">=</span><span class="n">new_root_index</span><span class="p">,</span>
                                                              <span class="n">terminal_states</span><span class="o">=</span><span class="n">terminal_clus_ai</span><span class="p">,</span> <span class="n">x_lazy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x_lazy</span><span class="p">,</span>
                                                              <span class="n">alpha_teleport</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_teleport</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">enum_ts</span><span class="p">,</span> <span class="n">target_terminal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terminal_clus_ai</span><span class="p">):</span>
                    <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">0.0000000</span>

                    <span class="n">pd_columnnames_terminal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">]))</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">prob_ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob_lin_rw2</span><span class="p">[:,</span> <span class="n">enum_ts</span><span class="p">]):</span>
                        <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;terminal_clus&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                            <span class="n">cluster_labels_subi</span><span class="p">[</span><span class="n">target_terminal</span><span class="p">])]</span> <span class="o">=</span> <span class="n">prob_ii</span>
            <span class="n">bp_array</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="n">pd_columnnames_terminal</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">bp_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">bp_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1e-8</span>

            <span class="n">bp_array</span> <span class="o">=</span> <span class="n">bp_array</span> <span class="o">/</span> <span class="n">bp_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># row normalization at the cluster level</span>
            <span class="n">bp_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">bp_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1e-8</span>

            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc_compi</span><span class="p">):</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hitting_times</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;graph_node_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_node_label</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;majority_truth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_node_label</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
                <span class="n">df_graph</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">markov_hitting_times_ai</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>

            <span class="n">locallytrimmed_g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;graph_node_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">hitting_times</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_adjacency</span> <span class="o">=</span> <span class="n">adjacency_matrix2_ai</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hitting_times</span> <span class="o">=</span> <span class="n">hitting_times</span>  <span class="c1"># not markov chain simulated</span>
        <span class="c1"># print(&#39;hitting times&#39;, hitting_times[0:10])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">markov_hitting_times</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># hitting_times on the forward biased#</span>
        <span class="c1"># print(&#39;markov hitting times,&#39;, self.markov_hitting_times[0:10])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminal_clusters</span> <span class="o">=</span> <span class="n">terminal_clus</span>

        <span class="n">dict_ts_mode</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terminal_clus</span><span class="p">:</span>
            <span class="n">loc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_mode</span> <span class="o">=</span> <span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)[</span><span class="n">loc__</span><span class="p">]))</span>
            <span class="n">dict_ts_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_mode</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">There are (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">terminal_clus</span><span class="p">)</span><span class="si">}</span><span class="s2">) terminal clusters corresponding to unique lineages </span><span class="si">{</span><span class="n">dict_ts_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># {self.terminal_clusters} &quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_degree_list</span> <span class="o">=</span> <span class="n">node_deg_list</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Begin projection of pseudotime and lineage likelihood&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_bp</span> <span class="o">=</span> <span class="n">bp_array</span>  <span class="c1"># there is row normalization at the cluster level so each row sums to 1</span>

        <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># 0</span>
        <span class="c1"># nan_count = df_graph[&#39;markov_pt&#39;].isna().sum()</span>
        <span class="c1"># print(&#39;df graph markov pt nan count&#39;, nan_count)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_branch_probability_sc</span><span class="p">(</span><span class="n">bp_array</span><span class="p">,</span> <span class="n">df_graph</span><span class="p">[</span>
            <span class="s1">&#39;markov_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;via_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span>
            <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;true_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span>
            <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;via_pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;via_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">correlation</span> <span class="o">=</span> <span class="n">df_</span><span class="p">[</span><span class="s1">&#39;via_pt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">df_</span><span class="p">[</span><span class="s1">&#39;true_time&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Start reading data&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Correlation of Via pseudotime with developmental stage </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">correlation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1"> %&#39;</span><span class="p">)</span>

        <span class="c1"># the single_cell_bp are not re-rownormalized. In fact we scale each column (lineage) by the max value in the lineage (column) to prevent rarer/smaller lineages from being under-represented.</span>
        <span class="c1"># to get a row-normalized results of the single-cell branching probabilities, we offer single_cell_bp_rownormed as an attribute so that the probabilities of each cell sum to 1.</span>

        <span class="n">single_cell_bp_rownormed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># row normalize</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">single_cell_bp_rownormed</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">single_cell_bp_rownormed</span> <span class="o">=</span> <span class="n">single_cell_bp_rownormed</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># print(f&#39;{datetime.now()}\tCheck cell 0 of sc pb rownormed {single_cell_bp_rownormed[0, :]},{single_cell_bp_rownormed.sum(axis=1)}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_cell_bp_rownormed</span> <span class="o">=</span> <span class="n">single_cell_bp_rownormed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_terminal_super_sub_pairs</span> <span class="o">=</span> <span class="n">dict_terminal_super_sub_pairs</span>
        <span class="n">hitting_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">markov_hitting_times</span>  <span class="c1"># cluster level</span>

        <span class="c1">### CONSTRUCT GRAPH USED FOR VISUALIZATION by doing further pruning so we can easily visualize the TI</span>

        <span class="c1"># rebias the edge weights based on the recomputed final markov hitting time and do a final pruning used for visualization (not MCMCs)</span>
        <span class="n">bias_weights_2_all</span> <span class="o">=</span> <span class="n">get_biased_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edgeweights_pruned_clustergraph</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">markov_hitting_times</span><span class="p">,</span>
                                                <span class="nb">round</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># edgeweights of initial globally and locally pruned graph (all components) need to be forward biased</span>

        <span class="n">n_clus</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">))</span>
        <span class="n">temp_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">bias_weights_2_all</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span><span class="p">))),</span>
                              <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clus</span><span class="p">,</span> <span class="n">n_clus</span><span class="p">))</span>  <span class="c1"># locally and globally pruned and used for adjacencyMatrix2ai</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_transition_matrix_all_components</span> <span class="o">=</span> <span class="n">temp_csr</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_transition_matrix_all_components</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_velo</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">temp_csr</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Transition matrix with weight of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">velo_weight</span><span class="si">}</span><span class="s2"> on RNA velocity&quot;</span><span class="p">)</span>
        <span class="c1"># the final array used for making the visual edgelists will be weighted average of A_velo and pt_based_trans (temp_csr)</span>
        <span class="n">final_transition_matrix_all_components</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">final_transition_matrix_all_components</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Cluster graph layout based on forward biasing&#39;</span><span class="p">)</span>
        <span class="c1"># print(&quot;**** USING OLD LAYOUT BEFORE BIASING ****&quot;)</span>

        <span class="c1"># ensure no extreme values distort layout:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        print(&#39;NEW, KEEP OR NOT? ensure no extreme values distort layout:&#39;)</span>
<span class="sd">        bias_weights_2_all_hi = np.mean(bias_weights_2_all) + 3*np.std(bias_weights_2_all)</span>
<span class="sd">        bias_weights_2_all_lo = np.mean(bias_weights_2_all) - 3*np.std(bias_weights_2_all)</span>
<span class="sd">        bias_weights_2_subset = [x for x in bias_weights_2_all if ((x &lt; bias_weights_2_all_hi) &amp; (x&gt; bias_weights_2_all_lo))]</span>
<span class="sd">        threshold_hi = np.percentile(bias_weights_2_subset,99)</span>
<span class="sd">        threshold_lo = np.percentile(bias_weights_2_subset,1)</span>
<span class="sd">        bias_weights_2_all = [x if x &lt; threshold_hi else threshold_hi for x in bias_weights_2_all ]</span>
<span class="sd">        bias_weights_2_all = [x if x &gt; threshold_lo else threshold_lo for x in bias_weights_2_all ]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">visual_g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">bias_weights_2_all</span><span class="p">})</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
            <span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>  <span class="c1"># used to be commented out</span>
        <span class="c1"># random.seed(self.random_seed)</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">visual_g</span><span class="o">.</span><span class="n">layout_fruchterman_reingold</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>  <span class="c1"># used to be commented out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_node_pos</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">layout</span>  <span class="c1"># reassign</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_compute_embedding</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">==</span> <span class="s1">&#39;via-atlas&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Run via-atlas&#39;</span><span class="p">)</span>

                <span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>
                <span class="c1"># row_stoch = normalize(self.csr_full_graph, norm=&#39;l1&#39;, axis=1)</span>
                <span class="c1">##row_stoch = row_stoch ** 3</span>
                <span class="c1"># temp_pca = csr_matrix(self.data)</span>
                <span class="c1"># X_diffused_data = row_stoch * temp_pca  # matrix multiplication to diffuse the pcs</span>
                <span class="c1"># X_input=self.data</span>
                <span class="k">for</span> <span class="n">random_state</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">]:</span>  <span class="c1"># 6 self.random_seed,6</span>
                    <span class="k">for</span> <span class="n">min_dist</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]:</span>  <span class="c1"># 35,0.3,0.25,0.2,0.1]:</span>
                        <span class="k">for</span> <span class="n">rw2_comp</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">]:</span>
                            <span class="kn">import</span> <span class="nn">random</span>
                            <span class="n">str_date</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
                            <span class="c1">#print(&#39;embedding pseudorand&#39;, str_date)</span>
                            <span class="n">distance_metric</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span>  <span class="c1"># &#39;cosine&#39; #</span>
                            <span class="c1">#print(                                f&#39;distance metric {distance_metric} and min_dist {min_dist} and randomstate {random_state} and pseudoid {str_date}&#39;)</span>
                            <span class="c1"># input = self.data</span>
                            <span class="c1"># &#39;/home/user/Trajectory/Datasets/EB_Phate/RW2_sparse_matrix510Pp1p5_R2Wemd.csv&#39;</span>

                            <span class="c1"># r2w_input = pd.read_csv( &#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/RW2/RW2_sparse_matrix5094_pc30_knn30_krev15_kseq15_rs0.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/RW2/RW2_P1_Q1_sparse_matrix5820_pc20_knn30_krev15_kseq15_rs0.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/WagnerZebrafish/RW2/knn100_pc30_kseq50RW2_sparse_matrix5820.csv&#39;)</span>

                            <span class="c1"># r2w_input = pd.read_csv( &#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/RW2/5000hvg/pc100_knn10kseq5krev5RW2_noparc137noK0871_walklength20_numwalks20_dim128.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/RW2/5000hvg/pc100_knn10kseq5krev5RW2_672_walklength80_numwalks20_dim64.csv&#39;)</span>

                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/RW2/2000hvg/pc100_knn20kseq5krev5RW2_120q10walklength20798.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv( &#39;/home/user/Trajectory/Datasets/EB_Phate/RW2/pc20_knn100kseq50krev50RW2_emd029.csv&#39;)</span>

                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/RW2/pc30_knn20kseq0krev0RW2_887_P20Q20.csv&#39;)# not this</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/RW2/pc30_knn50kseq0krev0RW2_gaussTrue_051_P1Q1.csv&#39;)  # not this</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/RW2/pc30_knn20kseq0krev0RW2_887.csv&#39;) not this</span>

                            <span class="c1"># r2w_input = pd.read_csv( &#39;/home/user/Trajectory/Datasets/EB_Phate/RW2/pc20_knn100kseq50krev50RW2_sparse_matrix029_P1_Qp001_numwalk20.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/EB_Phate/RW2/pc20_knn100kseq50krev50RW2_sparse_matrix029_P1_Q100_numwalk20.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/RW2/pc30_P1_Q1000_knn50kseq10krev10RW2_988.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/RW2/pc30_P1_Q1_knn50kseq10krev10RW2_988.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/2MOrgan/RW2/pc50_knn30kseq10krev0RW2_970_P1_Q10_rs42_tdiffstep2_gaussFalse_970.csv&#39;)</span>
                            <span class="c1">#r2w_input = pd.read_csv(                                &#39;/home/user/Trajectory/Datasets/Pijuan_Gastrulation/RW2/pc30_knn30kseq15krev15RW2_sparse_matrix_122.csv&#39;)  # pc30_knn30kseq15krev15RW2_emd_122.csv&#39;)</span>
                            <span class="c1"># r2w_input = pd.read_csv(&#39;/home/user/Trajectory/Datasets/Pijuan_Gastrulation/RW2/pc30_P1_Qp001_knn30kseq15krev15RW2_sparse_matrix_122.csv&#39;)</span>

                            <span class="c1">#r2w_input = r2w_input.drop([&#39;Unnamed: 0&#39;], axis=1).values</span>
                            <span class="c1">#input = r2w_input[:, 0:rw2_comp]</span>
                            <span class="c1"># print(&#39;NOT using rw2 embedding CANNOT USE THIS CODE ON GITHUB YET AS IT USES LOCAL FILES&#39;)</span>
                            <span class="nb">input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                            <span class="c1">#print(&#39;USING rw2 embedding CANNOT USE THIS CODE ON GITHUB YET AS IT USES LOCAL FILES&#39;)</span>

<span class="w">                            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                            from sklearn.preprocessing import normalize</span>
<span class="sd">                            row_stoch = self.csr_full_graph</span>
<span class="sd">                            row_stoch.data = np.clip(row_stoch.data, np.percentile(row_stoch.data, 10),</span>
<span class="sd">                                                     np.percentile(row_stoch.data, 90))</span>
<span class="sd">                            row_stoch = normalize(row_stoch, norm=&#39;l1&#39;, axis=1)</span>
<span class="sd">                            row_stoch = row_stoch ** 2  # level of diffusion</span>

<span class="sd">                            temp = csr_matrix(input)</span>

<span class="sd">                            input = row_stoch * temp  # matrix multiplication</span>
<span class="sd">                            &#39;&#39;&#39;</span>
                            <span class="n">do_initVia</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># input = self.data</span>
                            <span class="n">n_epochs</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># 100 usually</span>
                            <span class="c1"># input = self.data</span>
                            <span class="c1"># print(&#39;not using RW2 components&#39;)</span>
                            <span class="k">if</span> <span class="n">do_initVia</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">via_atlas_emb</span><span class="p">(</span><span class="n">X_input</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span>
                                                               <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span>
                                                               <span class="n">spread</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                               <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                                                               <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                                               <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">init_pos</span><span class="o">=</span><span class="s1">&#39;via&#39;</span><span class="p">,</span>
                                                               <span class="n">cluster_membership</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">via_atlas_emb</span><span class="p">(</span><span class="n">X_input</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span>
                                                               <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span>
                                                               <span class="n">spread</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                               <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                                                               <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                                               <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Completed via-atlas embedding&#39;</span><span class="p">)</span>
                            <span class="n">title_umap</span> <span class="o">=</span> <span class="s1">&#39;via-atlas rw2 knn/pc/knnseq:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_knnreverse&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential_reverse</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;tdiff&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">t_diff_step</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;mindist&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                <span class="n">min_dist</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;rs&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">color_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span>
                                <span class="n">f1</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">color_labels</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span>
                                                      <span class="n">title</span><span class="o">=</span><span class="n">title_umap</span><span class="p">,</span> <span class="n">text_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                <span class="n">f1</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

                                <span class="c1"># str_date = str(str(datetime.now())[-3:])</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/WagnerZebrafish/viaumap_RW2_5820_k&#39; + str(                                    self.knn) + &#39;TimeseriesAug&#39; + str(self.time_series) + &#39;_kseq&#39; + str(                                   self.knn_sequential) + &#39;_knnreverse&#39; + str(self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                    random_state) + &#39;_rsVIA&#39; + str(self.random_seed) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + &#39;viaInit&#39; + str(do_initVia) + str_date</span>

                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/WagnerZebrafish/viaumap_PCA_k&#39; + str(self.knn) + &#39;TimeseriesAug&#39;+str(self.time_series)+ &#39;_kseq&#39; + str(self.knn_sequential) + &#39;_knnreverse&#39; + str(  self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                random_state) + &#39;_rsVIA&#39; + str(self.random_seed) + &#39;doGauss&#39; + str(                                self.do_gaussian_kernel_edgeweights) + &#39;viaInit&#39;+str(do_initVia)+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/MEF_Schiebinger/viaumap_k&#39; + str(                                self.knn) + &#39;kseq&#39; + str(self.knn_sequential) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;rs&#39; + str(                                self.random_seed) + &#39;doGauss&#39; + str(                                self.do_gaussian_kernel_edgeweights) + str_date + &#39;stage&#39;</span>

                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/EB_Phate/viaumap_R2W_029_P1_Qp001_k&#39; + str( self.knn) +&#39;TimeseriesAug&#39;+str(self.time_series)+ &#39;kseq&#39; + str(self.knn_sequential) +&#39;_knnreverse&#39;+str(self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;_mainRS&#39;+str(self.random_seed)+&#39;mindist&#39; + str(min_dist) + &#39;rsUmap&#39; + str(random_state) + &#39;doGauss&#39; + str( self.do_gaussian_kernel_edgeweights) +&#39;_ViaInitLayout&#39;+str(do_initVia)+&#39;_nEpochs&#39;+str(n_epochs)+&#39;_&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/EB_Phate/viaumap_PCA_k&#39; + str(                                    self.knn) + &#39;TimeseriesAug&#39; + str(self.time_series) + &#39;kseq&#39; + str(                                    self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;_mainRS&#39; + str(self.random_seed) + &#39;mindist&#39; + str(                                    min_dist) + &#39;rsUmap&#39; + str(random_state) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + &#39;_ViaInitLayout&#39; + str(                                    do_initVia) + &#39;_nEpochs&#39; + str(n_epochs) + &#39;_&#39; + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/viaumap_RW2_P1_Q1_5820_k&#39; + str( self.knn) + &#39;TimeseriesAug&#39;+str(self.time_series)+ &#39;_kseq&#39; + str(self.knn_sequential) + &#39;_knnreverse&#39; + str(                                self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                random_state) +&#39;_rsVIA&#39;+str(self.random_seed)+ &#39;doGauss&#39; + str(                                self.do_gaussian_kernel_edgeweights) +&#39;viaInitLayout&#39;+str(do_initVia)+&#39;_nEpochs&#39;+str(n_epochs)+&#39;_&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/viaumap_PCA_k&#39; + str(                                    self.knn) + &#39;TimeseriesAug&#39; + str(self.time_series) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                    random_state) + &#39;_rsVIA&#39; + str(self.random_seed) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + &#39;viaInitLayout&#39; + str(                                    do_initVia) + &#39;_nEpochs&#39; + str(n_epochs) + &#39;_&#39; + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Pijuan_Gastrulation/viaumap_RW2_P1_Qp001_rw2comp&#39;+str(rw2_comp)+&#39;_122_k&#39; + str(                                    self.knn) +&#39;_TimeAug&#39;+str(self.time_series)+ &#39;_kseq&#39; + str(self.knn_sequential) +&#39;_knnreverse&#39;+str(self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;rs&#39; + str(                                    random_state) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + str_date +&#39;_viaInitTrue&#39;</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Pijuan_Gastrulation/viaumap_PCA_k&#39; + str(self.knn) + &#39;_TimeAug&#39; + str(                                    self.time_series) + &#39;_kseq&#39; + str(self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;rs&#39; + str(                                    random_state) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights)+&#39;_viaInit&#39;+str(do_initVia)      +str(n_epochs)+&#39;_&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/MouseNeuron/viaumap_RW2_P1_Q1000_rw2comp&#39; + str(rw2_comp) + &#39;_988_k&#39; + str(self.knn) + &#39;TimeseriesAug&#39;+str(self.time_series)+&#39;_kseq&#39; + str(self.knn_sequential) + &#39;_knnreverse&#39; + str( self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(self.t_diff_step) + &#39;mindist&#39; + str(min_dist) +&#39;_rsMain&#39;+str(self.random_seed)+ &#39;_rs&#39; + str(random_state) + &#39;doGauss&#39; + str( self.do_gaussian_kernel_edgeweights) +&#39;_viaInitLayout&#39;+str(do_initVia)+&#39;_nEpochs&#39;+str(n_epochs)+&#39;_&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/MouseNeuron/viaumap_PCA_k&#39; + str(self.knn) + &#39;TimeseriesAug&#39;+str(self.time_series)+&#39;_kseq&#39; + str(self.knn_sequential) + &#39;_knnreverse&#39; + str( self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(self.t_diff_step) + &#39;mindist&#39; + str(min_dist) +&#39;_rsMain&#39;+str(self.random_seed)+ &#39;_rs&#39; + str(random_state) + &#39;doGauss&#39; + str( self.do_gaussian_kernel_edgeweights) +&#39;_viaInitLayout&#39;+str(do_initVia)+&#39;_nEpochs&#39;+str(n_epochs)+&#39;_&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/2MOrgan/viaumap_RW2_P1_Q10_rw2comp&#39; + str(                                    rw2_comp) + &#39;_970_k&#39; + str(self.knn) + &#39;kseq&#39; + str(                                    self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;rs&#39; + str(                                    random_state) + &#39;doGauss&#39; + str(self.do_gaussian_kernel_edgeweights) +&#39;viaInitTrue&#39;+ str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/via_umaps_all/viaumap_2000hvg_k&#39; + str(                                    self.knn) + &#39;TimeseriesAug&#39; + str(self.time_series) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                    random_state) + &#39;_rsVIA&#39; + str(self.random_seed) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) +&#39;_distMet&#39;+distance_metric[0:3]+ &#39;viaInit&#39; + str(do_initVia) + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/RW2/embeddings/rw2_npz871_2000hvg_k&#39; + str(                                    self.knn) + &#39;TimeseriesAug&#39; + str(self.time_series) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_knnreverse&#39; + str(                                    self.knn_sequential_reverse) + &#39;_cluster_gp&#39;+str(self.cluster_graph_pruning)+&#39;_npc&#39; + str(self.ncomp) + &#39;tdiff&#39; + str(                                    self.t_diff_step) + &#39;mindist&#39; + str(min_dist) + &#39;_rsUmap&#39; + str(                                    random_state) + &#39;_rsVIA&#39; + str(self.random_seed) + &#39;doGauss&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + &#39;_distMet&#39; + distance_metric[                                                                                        0:3] + &#39;viaInit&#39; + str(                                    do_initVia) + str_date                                #df_umap.to_csv(&#39;/home/user/Trajectory/Datasets/MouseNeuron/2000hvg_viaumap_k&#39;+str(self.knn)+&#39;kseq&#39;+str(self.knn_sequential)+&#39;nps&#39;+str(self.ncomp)+&#39;tdiff&#39;+str(self.t_diff_step)+&#39;mindist&#39;+str(min_dist)+&#39;rs&#39;+str(self.random_seed)+&#39;stage&#39;+str_date+&quot;.csv&quot;)</span>
                                <span class="c1"># savefig_ = &#39;/home/user/Trajectory/Datasets/MouseNeuron/2000hvg_viaumap_k&#39;+str(self.knn)+&#39;kseq&#39;+str(self.knn_sequential)+&#39;nps&#39;+str(self.ncomp)+&#39;tdiff&#39;+str(self.t_diff_step)+&#39;mindist&#39;+str(min_dist)+&#39;rs&#39;+str(self.random_seed)+str_date+&#39;stage.png&#39;</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Qiu_Mouse_GastrulaPup/via-umap/5000hvg_viaumap_k&#39;+str(self.knn)+&#39;kseq&#39;+str(self.knn_sequential)+&#39;npcs&#39;+str(self.ncomp)+&#39;tdiff&#39;+str(self.t_diff_step)+&#39;doGaussianEdge&#39;+str(self.do_gaussian_kernel_edgeweights)+&#39;mindist&#39;+str(min_dist)+&#39;rs&#39;+str(self.random_seed)+&#39;_distmet&#39;+distance_metric+str(str_date)</span>
                                <span class="n">save_str</span> <span class="o">=</span> <span class="s1">&#39;/home/user/Trajectory/Datasets/Packer_Elegans2019/via-umap/5000hvg_viaumap_k&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;kseq&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_sequential</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;npcs&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;tdiff&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_diff_step</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;doGaussianEdge&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">do_gaussian_kernel_edgeweights</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;mindist&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;rs&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_distmet&#39;</span> <span class="o">+</span> <span class="n">distance_metric</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">str_date</span><span class="p">)</span>
                                <span class="n">df_umap</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">)</span>
                                <span class="c1"># df_umap.to_csv(save_str + &#39;.csv&#39;)</span>
                                <span class="c1"># f1.savefig(save_str + &#39;stage.png&#39;, facecolor=&#39;white&#39;, transparent=False)</span>

                            <span class="c1"># savefig_ = &#39;/home/user/Trajectory/Datasets/MouseNeuron/2000hvg_viaumap_k&#39;+str(self.knn)+&#39;kseq&#39;+str(self.knn_sequential)+&#39;nps&#39;+str(self.ncomp)+&#39;tdiff&#39;+str(self.t_diff_step)+&#39;mindist&#39;+str(min_dist)+&#39;rs&#39;+str(self.random_seed)+str_date+&#39;celltype.png&#39;</span>

                            <span class="n">celltype_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">]</span>  <span class="c1"># self.true_label</span>
                            <span class="n">f2</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">celltype_label</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title_umap</span><span class="p">,</span>
                                                  <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span><span class="p">)</span>
                            <span class="n">f2</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                            <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Rashmi2023/emt/&#39;+self.embedding_type+&#39;_knn&#39;+str(self.knn)</span>
                            <span class="c1"># f2.savefig(save_str + &#39;celltype.png&#39;, facecolor=&#39;white&#39;, transparent=False)</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">==</span> <span class="s1">&#39;via-mds&#39;</span><span class="p">:</span>
                <span class="n">str_date</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Run via-mds&#39;</span><span class="p">)</span>
                <span class="c1"># n_milestones = min(self.nsamples, max(10000, int(0.1*self.nsamples)))</span>

                <span class="k">for</span> <span class="n">rs_i</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">k_project_milestones</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span>  <span class="c1"># ,5,10]:</span>
                        <span class="k">for</span> <span class="n">k_mds_i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">25</span><span class="p">]:</span>  <span class="c1"># [5,10,15,25]:</span>
                            <span class="k">for</span> <span class="n">diffusion_i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span>  <span class="c1"># [2,5,10]:</span>
                                <span class="n">t_difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_diff_step</span>
                                <span class="n">k_seq_i</span> <span class="o">=</span> <span class="mi">2</span>
                                <span class="n">n_milestones_mds</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                                <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">via_mds</span><span class="p">(</span><span class="n">X_pca</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n_milestones</span><span class="o">=</span><span class="n">n_milestones_mds</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k_mds_i</span><span class="p">,</span>
                                                         <span class="n">knn_seq</span><span class="o">=</span><span class="n">k_seq_i</span><span class="p">,</span> <span class="n">k_project_milestones</span><span class="o">=</span><span class="n">k_project_milestones</span><span class="p">,</span>
                                                         <span class="c1"># neighbors_distances=self.full_neighbor_array,</span>

                                                         <span class="n">diffusion_op</span><span class="o">=</span><span class="n">diffusion_i</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">rs_i</span><span class="p">,</span>
                                                         <span class="n">viagraph_full</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">t_difference</span><span class="o">=</span><span class="n">t_difference</span><span class="p">,</span>
                                                         <span class="n">time_series_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">,</span> <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                                         <span class="n">double_diffusion</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                <span class="n">shape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">str_date</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Pijuan_Gastrulation/mds/viamds_singlediffusion_pcs&#39; + str(                                    shape_data) + &#39;_k&#39; + str(self.knn) + &#39;_milestones&#39; + str(                                   n_milestones_mds) + &#39;_kprojectmilestones&#39; + str(                                    k_project_milestones) + &#39;t_step&#39; + str(t_difference) + &#39;_knnmds&#39; + str(                                    k_mds_i) + &#39;_kseqmds&#39; + str(k_seq_i) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_nps&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(self.t_diff_step) + &#39;_randseed&#39; + str(self.random_seed) + &#39;_diffusionop&#39; + str(                                    diffusion_i) + &#39;_RsMds&#39; + str(rs_i) + &#39;_&#39; + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Zebrafish_Lange2023/via_mds/viamds_singlediffusion_pcs&#39; + str(                                    shape_data) + &#39;_k&#39; + str(self.knn) + &#39;_milestones&#39; + str(                                    n_milestones_mds) + &#39;_kprojectmilestones&#39; + str(                                    k_project_milestones) + &#39;t_step&#39; + str(t_difference) + &#39;_knnmds&#39; + str(                                    k_mds_i) + &#39;_kseqmds&#39; + str(k_seq_i) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_nps&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(                                    self.t_diff_step) + &#39;_randseed&#39; + str(self.random_seed) + &#39;_diffusionop&#39; + str(                                    diffusion_i) + &#39;_RsMds&#39; + str(rs_i) + &#39;_&#39; + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Qiu_Mouse_GastrulaPup/mds/viamds_singlediffusion_pcs&#39; + str(                                    shape_data) + &#39;_k&#39; + str(self.knn) + &#39;_milestones&#39; + str(                                    n_milestones_mds) + &#39;_kprojectmilestones&#39; + str(                                    k_project_milestones) + &#39;t_step&#39; + str(t_difference) + &#39;_knnmds&#39; + str(                                    k_mds_i) + &#39;_kseqmds&#39; + str(k_seq_i) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_nps&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(                                    self.t_diff_step) + &#39;_randseed&#39; + str(self.random_seed) + &#39;_diffusionop&#39; + str(                        diffusion_i) + &#39;_RsMds&#39; + str(rs_i) + &#39;_&#39; + str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/WagnerZebrafish/2000hvg/mds/singlediffusion_viamds/2000hvg_viamds_singlediffusion_pcs&#39;+str(shape_data)+&#39;_k&#39; + str(self.knn) + &#39;_milestones&#39;+str(n_milestones_mds)+&#39;_kprojectmilestones&#39;+str(k_project_milestones)+&#39;t_step&#39;+str(t_difference)+&#39;_knnmds&#39; + str(k_mds_i) +&#39;_kseqmds&#39; + str(k_seq_i) +&#39;_kseq&#39;+str(self.knn_sequential)+&#39;_nps&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(self.t_diff_step)+&#39;_randseed&#39;+str(self.random_seed)+ &#39;_diffusionop&#39;+str(diffusion_i)+&#39;_RsMds&#39;+str(rs_i)+&#39;_&#39;+str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/mds_theseare1000hvg/singlediffusion_viamds/1000hvg_viamds_singlediffusion_doExp&#39;+str(self.do_gaussian_kernel_edgeweights)+&#39;_k&#39; + str(self.knn) + &#39;_milestones&#39;+str(n_milestones_mds)+&#39;_kprojectmilestones&#39;+str(k_project_milestones)+&#39;t_stepmds&#39;+str(t_difference)+&#39;_knnmds&#39; + str(k_mds_i) +&#39;_kseqmds&#39; + str(k_seq_i) +&#39;_kseq&#39;+str(self.knn_sequential)+&#39;_nps&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(self.t_diff_step)+&#39;_randseed&#39;+str(self.random_seed)+ &#39;_diffusionop&#39;+str(diffusion_i)+&#39;_rsMds&#39;+str(rs_i)+&#39;_&#39;+str_date</span>
                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/EB_Phate/viamds_R2W_029_P1_Qp001_singlediffusion_prescaled_doExp&#39; + str(                                    self.do_gaussian_kernel_edgeweights) + &#39;_k&#39; + str(self.knn) + &#39;_milestones&#39; + str(                                    n_milestones_mds) + &#39;_kprojectmilestones&#39; + str(                                    k_project_milestones) + &#39;t_stepmds&#39; + str(t_difference) + &#39;_knnmds&#39; + str(                                    k_mds_i) + &#39;_kseqmds&#39; + str(k_seq_i) + &#39;_kseq&#39; + str(                                    self.knn_sequential) + &#39;_npc&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(                                    self.t_diff_step) + &#39;_randseed&#39; + str(self.random_seed) + &#39;_diffusionop&#39; + str(                                    diffusion_i) + &#39;_rsMds&#39; + str(rs_i) + &#39;_&#39; + str_date                                # save_str = &#39;/home/user/Trajectory/Datasets/MEF_Schiebinger/viamds_singlediffusion_prescaled_doExp&#39;+str(self.do_gaussian_kernel_edgeweights)+&#39;_k&#39; + str(self.knn) + &#39;_milestones&#39;+str(n_milestones_mds)+&#39;_kprojectmilestones&#39;+str(k_project_milestones)+&#39;t_stepmds&#39;+str(t_difference)+&#39;_knnmds&#39; + str(k_mds_i) +&#39;_kseqmds&#39; + str(k_seq_i) +&#39;_kseq&#39;+str(self.knn_sequential)+&#39;_npc&#39; + str(self.ncomp) + &#39;_tdiff&#39; + str(self.t_diff_step)+&#39;_randseed&#39;+str(self.random_seed)+ &#39;_diffusionop&#39;+str(diffusion_i)+&#39;_rsMds&#39;+str(rs_i)+&#39;_&#39;+str_date</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Completed via-mds&#39;</span><span class="p">)</span>

                                <span class="c1"># save_str = &#39;/home/user/Trajectory/Datasets/Qiu_Mouse_GastrulaPup/mds/&#39; + self.embedding_type + &#39;_knn&#39; + str(                                    self.knn) + &#39;_projectmilestones&#39; + str(k_project_milestones) + &#39;_kmds&#39; + str(                                    k_mds_i) + &#39;_diffusion&#39; + str(diffusion_i)+&#39;_strdate&#39;+str(str_date)</span>
                                <span class="n">save_str</span> <span class="o">=</span> <span class="s1">&#39;/home/user/Trajectory/Datasets/Packer_Elegans2019/via-mds/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">+</span> <span class="s1">&#39;_knn&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_projectmilestones&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k_project_milestones</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_kmds&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="n">k_mds_i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_diffusion&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">diffusion_i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_strdate&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">str_date</span><span class="p">)</span>
                                <span class="n">df_mds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">)</span>
                                <span class="n">df_mds</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">save_str</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span><span class="p">)</span>
                                <span class="n">celltype_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">]</span>  <span class="c1"># self.true_label</span>
                                <span class="n">f1</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">celltype_label</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;via-mds&#39;</span><span class="p">,</span>
                                                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">text_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                                <span class="n">f1</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                                <span class="c1">#f1.savefig(save_str + &#39;_celltype.png&#39;, facecolor=&#39;white&#39;, transparent=False)</span>

                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">f2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">,</span>
                                                           <span class="n">title</span><span class="o">=</span><span class="s1">&#39;via-mds&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">)</span>

                                    <span class="n">f2</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                                    <span class="c1">#f2.savefig(save_str + &#39;_stage.png&#39;, facecolor=&#39;white&#39;, transparent=False)</span>



            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">==</span> <span class="s1">&#39;via-force&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Run via-force&#39;</span><span class="p">)</span>
                <span class="c1"># n_milestone = min(self.nsamples, max(5000, int(0.1*self.nsamples)))</span>
                <span class="n">n_milestones</span> <span class="o">=</span> <span class="mi">3000</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">via_forcelayout</span><span class="p">(</span><span class="n">X_pca</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">viagraph_full</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csr_full_graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">knn_seq</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                 <span class="n">n_milestones</span><span class="o">=</span><span class="n">n_milestones</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">color_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">color_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">color_labels</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;via-force&#39;</span><span class="p">,</span> <span class="n">categorical</span><span class="o">=</span><span class="n">categorical</span><span class="p">)</span>
                <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;via-mds&#39;</span><span class="p">,</span> <span class="n">categorical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">No embedding will be computed: if you wish to compute a via-embedding specify one of via-force, via-mds or via-umap&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning_twice</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># print(&#39;creating bundle with single round of global pruning at a level of&#39;, self.edgebundle_pruning)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Starting make edgebundle viagraph...&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hammerbundle_cluster</span> <span class="o">=</span> <span class="n">make_edgebundle_viagraph</span><span class="p">(</span><span class="n">layout</span><span class="p">,</span> <span class="n">g_layout</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">viagraph_decay</span><span class="p">)</span>

        <span class="c1"># simplifying structure of edges used on the visual layout</span>
        <span class="n">edgeweights_maxout_2</span><span class="p">,</span> <span class="n">edgelist_maxout_2</span><span class="p">,</span> <span class="n">comp_labels_2</span> <span class="o">=</span> <span class="n">pruning_clustergraph</span><span class="p">(</span>
            <span class="n">final_transition_matrix_all_components</span><span class="p">,</span>
            <span class="n">global_pruning_std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">visual_cluster_graph_pruning</span><span class="p">,</span>
            <span class="n">max_outgoing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_visual_outgoing_edges</span><span class="p">,</span>
            <span class="n">preserve_disconnected</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_disconnected</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgebundle_pruning_twice</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Additional Visual cluster graph pruning for edge bundling at level: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visual_cluster_graph_pruning</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">layout_g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">edgeweights_maxout_2</span><span class="p">})</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
                <span class="n">combine_edges</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
            <span class="n">layout_g_csr</span> <span class="o">=</span> <span class="n">get_sparse_from_igraph</span><span class="p">(</span><span class="n">layout_g</span><span class="p">,</span> <span class="n">weight_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">layout_g_csr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># clip weights to prevent distorted visual scale in layout</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
            <span class="n">weights_for_layout</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights_for_layout</span><span class="p">)</span>
            <span class="n">graph_for_layout</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">layout_g_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())),</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weights_for_layout</span><span class="p">})</span>
            <span class="c1"># edge bundle is based on the visually (double) pruned graph rather than the inital graph used for Velo and Pseudotime</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hammerbundle_cluster</span> <span class="o">=</span> <span class="n">make_edgebundle_viagraph</span><span class="p">(</span><span class="n">layout</span><span class="p">,</span> <span class="n">graph_for_layout</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        else:</span>
<span class="sd">            print(f&#39;redoing cluster graph layout based on forward biased edges&#39;)</span>
<span class="sd">            layout_g = ig.Graph(edgelist_maxout_2, edge_attrs={&#39;weight&#39;: bias_weights_2_all}).simplify(</span>
<span class="sd">                combine_edges=&#39;sum&#39;)</span>
<span class="sd">            layout_g_csr = get_sparse_from_igraph(layout_g, weight_attr=&#39;weight&#39;)</span>
<span class="sd">            weights_for_layout = np.asarray(layout_g_csr.data)</span>
<span class="sd">            # clip weights to prevent distorted visual scale in layout</span>
<span class="sd">            weights_for_layout = np.clip(weights_for_layout, np.percentile(weights_for_layout, 10),</span>
<span class="sd">                                         np.percentile(weights_for_layout, 90))</span>
<span class="sd">            weights_for_layout = list(weights_for_layout)</span>
<span class="sd">            graph_for_layout = ig.Graph(list(zip(*layout_g_csr.nonzero())), edge_attrs={&#39;weight&#39;: weights_for_layout})</span>
<span class="sd">            # edge bundle is based on the visually (double) pruned graph rather than the inital graph used for Velo and Pseudotime</span>
<span class="sd">            self.hammerbundle_cluster = make_edgebundle_viagraph(layout, graph_for_layout)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">temp_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edgeweights_maxout_2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">edgelist_maxout_2</span><span class="p">))),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clus</span><span class="p">,</span> <span class="n">n_clus</span><span class="p">))</span>
        <span class="n">temp_csr</span> <span class="o">=</span> <span class="n">temp_csr</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span> <span class="o">+</span> <span class="n">temp_csr</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
        <span class="n">temp_csr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">temp_csr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># elements along the main diagonal and above are set to zero</span>
        <span class="n">temp_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">temp_csr</span><span class="p">)</span>
        <span class="n">edgeweights_maxout_2</span> <span class="o">=</span> <span class="n">temp_csr</span><span class="o">.</span><span class="n">data</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">edgeweights_maxout_2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">edgeweights_maxout_2</span><span class="p">)</span>
        <span class="n">edgeweights_maxout_2</span> <span class="o">=</span> <span class="p">[((</span><span class="n">wi</span> <span class="o">+</span> <span class="mf">.1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.5</span> <span class="o">/</span> <span class="n">scale_factor</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="n">edgeweights_maxout_2</span><span class="p">]</span>

        <span class="n">sources</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">temp_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">edgelist_maxout_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgelist_maxout</span> <span class="o">=</span> <span class="n">edgelist_maxout_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgeweights_maxout</span> <span class="o">=</span> <span class="n">edgeweights_maxout_2</span>

        <span class="n">remove_outliers</span> <span class="o">=</span> <span class="n">hitting_times</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">remove_outliers</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>  <span class="c1"># np.mean(remove_outliers) + 1* np.std(remove_outliers)</span>
        <span class="n">th_hitting_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="n">threshold</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hitting_times</span><span class="p">]</span>
        <span class="n">remove_outliers_low</span> <span class="o">=</span> <span class="n">hitting_times</span><span class="p">[</span><span class="n">hitting_times</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hitting_times</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">hitting_times</span><span class="p">))]</span>
        <span class="n">threshold_low</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">remove_outliers_low</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">remove_outliers_low</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">th_hitting_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold_low</span> <span class="k">else</span> <span class="n">threshold_low</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">th_hitting_times</span><span class="p">]</span>

        <span class="n">scaled_hitting_times</span> <span class="o">=</span> <span class="p">(</span><span class="n">th_hitting_times</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">th_hitting_times</span><span class="p">))</span>
        <span class="n">npmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scaled_hitting_times</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="n">scaled_hitting_times</span> <span class="o">=</span> <span class="n">scaled_hitting_times</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="n">npmax</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_hitting_times</span> <span class="o">=</span> <span class="n">scaled_hitting_times</span>  <span class="c1"># cluster mcmc pt cluster level</span>
        <span class="n">scaled_hitting_times</span> <span class="o">=</span> <span class="n">scaled_hitting_times</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">pal</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">drawing</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">AdvancedGradientPalette</span><span class="p">([</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">1001</span><span class="p">)</span>

        <span class="c1"># making a new &quot;augmented&quot; single-cell graph based on the computed pseudotimes - useful when there are no time-series labels for (optionally) guiding the graph structure</span>
        <span class="n">use_pt_to_guide_graph</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_pt_to_guide_graph</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Make pt-augmented knn&#39;</span><span class="p">)</span>
            <span class="n">pt_augmented_adjacency_igraph</span><span class="p">,</span> <span class="n">adjacency_augmented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_pt_augmented_adjacency_igraph</span><span class="p">(</span>
                <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="n">distances</span><span class="p">,</span> <span class="n">k_reverse</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Run via-umap on pt-augmented knn&#39;</span><span class="p">)</span>  <span class="c1"># graph=csr_full_graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">via_atlas_emb</span><span class="p">(</span><span class="n">X_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency_pt_augmented</span><span class="p">,</span> <span class="n">n_epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="n">distance_metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                           <span class="n">saveto</span><span class="o">=</span><span class="s1">&#39;/home/user/Trajectory/Datasets/HumanCD34/pt-aug/not_ptaug_umap_.csv&#39;</span><span class="p">)</span>  <span class="c1"># usually min_dist default =0.1, for cd34 0.8</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        self.embedding = via_mds(X_pca=self.data, k=15, t_diffusion=2,</span>
<span class="sd">                                 n_milestones=min(self.nsamples, max(10000, int(0.1 * self.nsamples))),</span>
<span class="sd">                                 viagraph_full=adjacency_pt_augmented, time_series_labels=[int(i*10) for i in self.single_cell_pt_markov],</span>
<span class="sd">                                 saveto=&#39;&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>


        <span class="n">all_colors</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># TODO clean up this paragraph/put into a separate function</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scaled_hitting_times</span><span class="p">:</span>
            <span class="n">all_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pal</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">locallytrimmed_g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;hitting_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaled_hitting_times</span>
        <span class="n">locallytrimmed_g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pal</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scaled_hitting_times</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">group_color</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">locallytrimmed_g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]]</span>  <span class="c1"># based on ygb scale</span>
        <span class="n">viridis_cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis_r&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">group_color_cmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span>
                                 <span class="n">viridis_cmap</span><span class="p">(</span><span class="n">scaled_hitting_times</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)]</span>  <span class="c1"># based on ygb scale</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph_node_label</span> <span class="o">=</span> <span class="n">df_graph</span><span class="p">[</span><span class="s1">&#39;graph_node_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgeweight</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">locallytrimmed_g</span><span class="o">.</span><span class="n">es</span><span class="p">]</span>

        <span class="c1"># print(&#39;To draw viagraph edges without bundling and plot piechart composition of cell types: use self.draw_piechart_graph_nobundle()&#39;)</span>
        <span class="c1"># self.draw_piechart_graph_nobundle()</span>
        <span class="c1"># print(&#39;drawing with bundle piechart... Use self.draw_piechart_graph() to reproduce this plot&#39;)</span>

        <span class="n">initial_bandwidth</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># 0.05</span>
        <span class="n">decay</span> <span class="o">=</span> <span class="mf">0.7</span>  <span class="c1"># 0.7</span>
        <span class="n">n_milestones</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># f you min(self.nsamples, max(500, int(0.1 * self.nsamples)))</span>

        <span class="c1"># print(f&#39;milestones for edgebundling {n_milestones}&#39;)</span>
        <span class="n">global_visual_pruning</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">extra_title_text</span> <span class="o">=</span> <span class="s1">&#39;jac_visual:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">global_visual_pruning</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; bw:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
            <span class="n">initial_bandwidth</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; decay:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">decay</span><span class="p">)</span>
        <span class="c1"># sc_graph = self.csr_full_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hammerbundle_milestone_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s2">Start making edgebundle milestone with </span><span class="si">{</span><span class="n">n_milestones</span><span class="si">}</span><span class="s2"> milestones...This can be recomputed with make_edgebundle_milestone()&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hammerbundle_milestone_dict</span> <span class="o">=</span> <span class="n">make_edgebundle_milestone</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span>
                                                                         <span class="n">sc_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ig_full_graph</span><span class="p">,</span>
                                                                         <span class="n">n_milestones</span><span class="o">=</span><span class="n">n_milestones</span><span class="p">,</span>
                                                                         <span class="n">global_visual_pruning</span><span class="o">=</span><span class="n">global_visual_pruning</span><span class="p">,</span>
                                                                         <span class="n">initial_bandwidth</span><span class="o">=</span><span class="n">initial_bandwidth</span><span class="p">,</span>
                                                                         <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span>
                                                                         <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">sc_labels_numeric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_series_labels</span><span class="p">,</span>
                                                                         <span class="n">sc_pt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">,</span>
                                                                         <span class="n">terminal_cluster_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">,</span>
                                                                         <span class="n">single_cell_lineage_prob</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cell_bp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mode</span>
        <span class="k">for</span> <span class="n">tsi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_clusters</span><span class="p">:</span>
            <span class="n">loc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">val_pt</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_i</span><span class="p">]</span>

            <span class="n">th_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">val_pt</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># 50</span>
            <span class="n">loc_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_pt</span><span class="p">))</span> <span class="k">if</span> <span class="n">val_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_pt</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">loc_i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">labelsq</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span><span class="o">.</span><span class="n">knn_query</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">tsi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelsq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;REMEMBER TO RE-INCLUDE the PLT.SHOW HERE - COMMENTING IT OUT FOR NOW&#39;</span><span class="p">)</span>
            <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cell_pt_markov</span><span class="p">,</span> <span class="n">sc_index_terminal_states</span><span class="o">=</span><span class="n">tsi_list</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s1">&#39;pseudotime and terminal states&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">true_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)</span>

            <span class="n">plot_scatter</span><span class="p">(</span><span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">,</span>
                         <span class="n">sc_index_terminal_states</span><span class="o">=</span><span class="n">tsi_list</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;lineage and terminal states&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span>
                         <span class="n">true_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#plt.show()</span>

        <span class="k">return</span>


    <span class="k">def</span> <span class="nf">accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onevsall</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="n">true_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_label</span>
        <span class="n">Index_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">PARC_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">)</span>
        <span class="n">n_cancer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">onevsall</span><span class="p">)</span>
        <span class="n">n_pbmc</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">n_cancer</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">Index_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">num_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Index_dict</span><span class="p">)</span>
        <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">Index_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">error_count</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pbmc_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">thp1_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">f1_score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Index_dict</span><span class="p">[</span><span class="n">kk</span><span class="p">]]</span>
            <span class="n">majority_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="c1"># if majority_val == onevsall: print(&#39;cluster&#39;, kk, &#39; has majority&#39;, onevsall, &#39;with population&#39;, len(vals))</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">len_unknown</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="c1"># print(&#39;len unknown&#39;, len_unknown)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">majority_val</span> <span class="o">==</span> <span class="n">onevsall</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">thp1_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">+</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">onevsall</span><span class="p">])</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">onevsall</span><span class="p">])</span>
                <span class="n">list_error</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">majority_val</span><span class="p">]</span>
                <span class="n">e_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_error</span><span class="p">)</span>
                <span class="n">error_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_count</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">majority_val</span> <span class="o">!=</span> <span class="n">onevsall</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">pbmc_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="n">tn</span> <span class="o">=</span> <span class="n">tn</span> <span class="o">+</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">onevsall</span><span class="p">])</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">+</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">onevsall</span><span class="p">])</span>
                <span class="n">error_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">majority_val</span><span class="p">]))</span>

        <span class="n">predict_class_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">)</span>
        <span class="n">PARC_labels_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">)</span>
        <span class="n">number_clusters_for_target</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thp1_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cancer_class</span> <span class="ow">in</span> <span class="n">thp1_labels</span><span class="p">:</span>
            <span class="n">predict_class_array</span><span class="p">[</span><span class="n">PARC_labels_array</span> <span class="o">==</span> <span class="n">cancer_class</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">benign_class</span> <span class="ow">in</span> <span class="n">pbmc_labels</span><span class="p">:</span>
            <span class="n">predict_class_array</span><span class="p">[</span><span class="n">PARC_labels_array</span> <span class="o">==</span> <span class="n">benign_class</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">predict_class_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">predict_class_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">error_rate</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">error_count</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">n_target</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span>
        <span class="n">tnr</span> <span class="o">=</span> <span class="n">tn</span> <span class="o">/</span> <span class="n">n_pbmc</span>
        <span class="n">fnr</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">/</span> <span class="n">n_cancer</span>
        <span class="n">tpr</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="n">n_cancer</span>
        <span class="n">fpr</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">/</span> <span class="n">n_pbmc</span>

        <span class="k">if</span> <span class="n">tp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">fn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">recall</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>  <span class="c1"># ability to find all positives</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">fp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>  <span class="c1"># ability to not misclassify negatives as positives</span>
        <span class="k">if</span> <span class="n">precision</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">recall</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f1_score</span> <span class="o">=</span> <span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span><span class="p">)</span>

        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">true_labels</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">):</span>
            <span class="n">cluster_i_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">PARC_labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">true_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">true_labels</span><span class="p">)</span>
            <span class="n">majority_truth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_mode</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">true_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]))</span>
            <span class="n">majority_truth_labels</span><span class="p">[</span><span class="n">cluster_i_loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">majority_truth</span>

        <span class="n">majority_truth_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">majority_truth_labels</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">accuracy_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_rate</span><span class="p">,</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">tnr</span><span class="p">,</span> <span class="n">fnr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">fpr</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                        <span class="n">recall</span><span class="p">,</span> <span class="n">num_groups</span><span class="p">,</span> <span class="n">n_target</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">accuracy_val</span><span class="p">,</span> <span class="n">predict_class_array</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">number_clusters_for_target</span>

    <span class="k">def</span> <span class="nf">run_VIA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Running VIA over input data of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> (samples) x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> (features)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Knngraph has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="si">}</span><span class="s1"> neighbors&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">knn_struct</span> <span class="o">=</span> <span class="n">_construct_knn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">knn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_subPARC</span><span class="p">()</span>
        <span class="n">run_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">st</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\t</span><span class="s1">Time elapsed </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">run_time</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
        <span class="n">do_accuracy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">do_accuracy</span><span class="p">:</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">))</span>
            <span class="n">targets</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f1_accumulated</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f1_mean</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span><span class="s1">&#39;edgepruning_clustering_resolution&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span><span class="p">],</span> <span class="s1">&#39;edgepruning_clustering_resolution_local&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution_local</span><span class="p">],</span>
                 <span class="s1">&#39;runtime(s)&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">run_time</span><span class="p">]})</span>
            <span class="c1"># self.majority_truth_labels = []</span>
            <span class="n">list_roc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">f1_accumulated</span><span class="p">,</span> <span class="n">f1_acc_noweighting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">onevsall_val</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                    <span class="c1"># print(&#39;target is&#39;, onevsall_val)</span>
                    <span class="n">vals_roc</span><span class="p">,</span> <span class="n">predict_class_array</span><span class="p">,</span> <span class="n">majority_truth_labels</span><span class="p">,</span> <span class="n">numclusters_targetval</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">onevsall</span><span class="o">=</span><span class="n">onevsall_val</span><span class="p">)</span>
                    <span class="n">f1_current</span> <span class="o">=</span> <span class="n">vals_roc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">f1_accumulated</span> <span class="o">=</span> <span class="n">f1_accumulated</span> <span class="o">+</span> <span class="n">f1_current</span> <span class="o">*</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">true_label</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">onevsall_val</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span>
                    <span class="n">f1_acc_noweighting</span> <span class="o">=</span> <span class="n">f1_acc_noweighting</span> <span class="o">+</span> <span class="n">f1_current</span>

                    <span class="n">list_roc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgepruning_clustering_resolution_local</span><span class="p">,</span> <span class="n">onevsall_val</span><span class="p">]</span> <span class="o">+</span>
                                    <span class="n">vals_roc</span> <span class="o">+</span> <span class="p">[</span><span class="n">numclusters_targetval</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">run_time</span><span class="p">])</span>

                <span class="n">f1_mean</span> <span class="o">=</span> <span class="n">f1_acc_noweighting</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>

                <span class="n">df_accuracy</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">list_roc</span><span class="p">,</span>
                                           <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;edgepruning_clustering_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;edgepruning_clustering_resolution_local&#39;</span><span class="p">,</span> <span class="s1">&#39;onevsall-target&#39;</span><span class="p">,</span> <span class="s1">&#39;error rate&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;f1-score&#39;</span><span class="p">,</span> <span class="s1">&#39;tnr&#39;</span><span class="p">,</span> <span class="s1">&#39;fnr&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;tpr&#39;</span><span class="p">,</span> <span class="s1">&#39;fpr&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;recall&#39;</span><span class="p">,</span> <span class="s1">&#39;num_groups&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;population of target&#39;</span><span class="p">,</span> <span class="s1">&#39;num clusters&#39;</span><span class="p">,</span> <span class="s1">&#39;clustering runtime&#39;</span><span class="p">])</span>
                <span class="c1"># df_accuracy.to_csv(&#39;/home/user/Trajectory/Datasets/Cao_ProtoVert/df_accuracy_.csv&#39;)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">f1_accumulated</span> <span class="o">=</span> <span class="n">f1_accumulated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f1_mean</span> <span class="o">=</span> <span class="n">f1_mean</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stats_df</span> <span class="o">=</span> <span class="n">df_accuracy</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, shobana stassen
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>